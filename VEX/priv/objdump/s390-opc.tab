/*
   This file is part of Valgrind, a dynamic binary instrumentation
   framework.

   This program is free software; you can redistribute it and/or
   modify it under the terms of the GNU General Public License as
   published by the Free Software Foundation; either version 3 of the
   License, or (at your option) any later version.

   This program is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, see <http://www.gnu.org/licenses/>.

   The GNU General Public License is contained in the file COPYING.
*/

/* The opcode table. This file was generated by s390-mkopc.

   The format of the opcode table is:

   NAME	     OPCODE	MASK	OPERANDS

   Name is the name of the instruction.
   OPCODE is the instruction opcode.
   MASK is the opcode mask; this is used to tell the disassembler
     which bits in the actual opcode must match OPCODE.
   OPERANDS is the list of operands.

   The disassembler reads the table in order and prints the first
   instruction which matches.
   MODE_BITS - zarch or esa
   MIN_CPU - number of the min cpu level required
   FLAGS - instruction flags.
   DESCRIPTION - description of the instruction.  */

const struct s390_opcode s390_opcodes[] =
  {
  { "dp", OP8(0xfdLL), MASK_SS_LLRDRD, INSTR_SS_LLRDRD, 3, 0, 0, "divide decimal" },
  { "mp", OP8(0xfcLL), MASK_SS_LLRDRD, INSTR_SS_LLRDRD, 3, 0, 0, "multiply decimal" },
  { "sp", OP8(0xfbLL), MASK_SS_LLRDRD, INSTR_SS_LLRDRD, 3, 0, 0, "subtract decimal" },
  { "ap", OP8(0xfaLL), MASK_SS_LLRDRD, INSTR_SS_LLRDRD, 3, 0, 0, "add decimal" },
  { "cp", OP8(0xf9LL), MASK_SS_LLRDRD, INSTR_SS_LLRDRD, 3, 0, 0, "compare decimal" },
  { "zap", OP8(0xf8LL), MASK_SS_LLRDRD, INSTR_SS_LLRDRD, 3, 0, 0, "zero and add" },
  { "unpk", OP8(0xf3LL), MASK_SS_LLRDRD, INSTR_SS_LLRDRD, 3, 0, 0, "unpack" },
  { "pack", OP8(0xf2LL), MASK_SS_LLRDRD, INSTR_SS_LLRDRD, 3, 0, 0, "pack" },
  { "mvo", OP8(0xf1LL), MASK_SS_LLRDRD, INSTR_SS_LLRDRD, 3, 0, 0, "move with offset" },
  { "srp", OP8(0xf0LL), MASK_SS_LIRDRD, INSTR_SS_LIRDRD, 3, 0, 0, "shift and round decimal" },
  { "lmd", OP8(0xefLL), MASK_SS_RRRDRD3, INSTR_SS_RRRDRD3, 2, 2, 0, "load multiple disjoint" },
  { "plo", OP8(0xeeLL), MASK_SS_RRRDRD2, INSTR_SS_RRRDRD2, 3, 0, 0, "perform locked operation" },
  { "cxpt", OP48(0xed00000000afLL), MASK_RSL_LRDFEU, INSTR_RSL_LRDFEU, 2, 9, 0, "convert from packed to extended dfp" },
  { "cdpt", OP48(0xed00000000aeLL), MASK_RSL_LRDFU, INSTR_RSL_LRDFU, 2, 9, 0, "convert from packed to long dfp" },
  { "cpxt", OP48(0xed00000000adLL), MASK_RSL_LRDFEU, INSTR_RSL_LRDFEU, 2, 9, 0, "convert from extended dfp to packed" },
  { "cpdt", OP48(0xed00000000acLL), MASK_RSL_LRDFU, INSTR_RSL_LRDFU, 2, 9, 0, "convert from long dfp to packed" },
  { "cxzt", OP48(0xed00000000abLL), MASK_RSL_LRDFEU, INSTR_RSL_LRDFEU, 2, 8, 0, "convert from zoned extended" },
  { "cdzt", OP48(0xed00000000aaLL), MASK_RSL_LRDFU, INSTR_RSL_LRDFU, 2, 8, 0, "convert from zoned long" },
  { "czxt", OP48(0xed00000000a9LL), MASK_RSL_LRDFEU, INSTR_RSL_LRDFEU, 2, 8, 0, "convert to zoned extended" },
  { "czdt", OP48(0xed00000000a8LL), MASK_RSL_LRDFU, INSTR_RSL_LRDFU, 2, 8, 0, "convert to zoned long" },
  { "stdy", OP48(0xed0000000067LL), MASK_RXY_FRRD, INSTR_RXY_FRRD, 2, 3, 0, "store (long) with long offset" },
  { "stey", OP48(0xed0000000066LL), MASK_RXY_FRRD, INSTR_RXY_FRRD, 2, 3, 0, "store (short) with long offset" },
  { "ldy", OP48(0xed0000000065LL), MASK_RXY_FRRD, INSTR_RXY_FRRD, 2, 3, 0, "load (long) with long offset" },
  { "ley", OP48(0xed0000000064LL), MASK_RXY_FRRD, INSTR_RXY_FRRD, 2, 3, 0, "load (short) with long offset" },
  { "tdgxt", OP48(0xed0000000059LL), MASK_RXE_FERRD, INSTR_RXE_FERRD, 2, 5, 0, "test data group extended dfp" },
  { "tdcxt", OP48(0xed0000000058LL), MASK_RXE_FERRD, INSTR_RXE_FERRD, 2, 5, 0, "test data class extended dfp" },
  { "tdgdt", OP48(0xed0000000055LL), MASK_RXE_FRRD, INSTR_RXE_FRRD, 2, 5, 0, "test data group long dfp" },
  { "tdcdt", OP48(0xed0000000054LL), MASK_RXE_FRRD, INSTR_RXE_FRRD, 2, 5, 0, "test data class long dfp" },
  { "tdget", OP48(0xed0000000051LL), MASK_RXE_FRRD, INSTR_RXE_FRRD, 2, 5, 0, "test data group short dfp" },
  { "tdcet", OP48(0xed0000000050LL), MASK_RXE_FRRD, INSTR_RXE_FRRD, 2, 5, 0, "test data class short dfp" },
  { "srxt", OP48(0xed0000000049LL), MASK_RXF_FERRDFE, INSTR_RXF_FERRDFE, 2, 5, 0, "shift coefficient right extended dfp" },
  { "slxt", OP48(0xed0000000048LL), MASK_RXF_FERRDFE, INSTR_RXF_FERRDFE, 2, 5, 0, "shift coefficient left extended dfp" },
  { "srdt", OP48(0xed0000000041LL), MASK_RXF_FRRDF, INSTR_RXF_FRRDF, 2, 5, 0, "shift coefficient right long dfp" },
  { "sldt", OP48(0xed0000000040LL), MASK_RXF_FRRDF, INSTR_RXF_FRRDF, 2, 5, 0, "shift coefficient left long dfp" },
  { "msd", OP48(0xed000000003fLL), MASK_RXF_FRRDF, INSTR_RXF_FRRDF, 3, 3, 0, "multiply and subtract long hfp" },
  { "mad", OP48(0xed000000003eLL), MASK_RXF_FRRDF, INSTR_RXF_FRRDF, 3, 3, 0, "multiply and add long hfp" },
  { "myh", OP48(0xed000000003dLL), MASK_RXF_FRRDF, INSTR_RXF_FRRDF, 2, 4, 0, "multiply unnormalized long hfp high" },
  { "mayh", OP48(0xed000000003cLL), MASK_RXF_FRRDF, INSTR_RXF_FRRDF, 2, 4, 0, "multiply and add unnormalized long hfp high" },
  { "my", OP48(0xed000000003bLL), MASK_RXF_FRRDFE, INSTR_RXF_FRRDFE, 2, 4, 0, "multiply unnormalized long hfp" },
  { "may", OP48(0xed000000003aLL), MASK_RXF_FRRDF, INSTR_RXF_FRRDF, 2, 4, 0, "multiply and add unnormalized long hfp" },
  { "myl", OP48(0xed0000000039LL), MASK_RXF_FRRDF, INSTR_RXF_FRRDF, 2, 4, 0, "multiply unnormalized long hfp low" },
  { "mayl", OP48(0xed0000000038LL), MASK_RXF_FRRDF, INSTR_RXF_FRRDF, 2, 4, 0, "multiply and add unnormalized long hfp low" },
  { "mee", OP48(0xed0000000037LL), MASK_RXE_FRRD, INSTR_RXE_FRRD, 3, 0, 0, "multiply short hfp" },
  { "sqd", OP48(0xed0000000035LL), MASK_RXE_FRRD, INSTR_RXE_FRRD, 3, 0, 0, "square root long hfp" },
  { "sqe", OP48(0xed0000000034LL), MASK_RXE_FRRD, INSTR_RXE_FRRD, 3, 0, 0, "square root short hfp" },
  { "mse", OP48(0xed000000002fLL), MASK_RXF_FRRDF, INSTR_RXF_FRRDF, 3, 3, 0, "multiply and subttract short hfp" },
  { "mae", OP48(0xed000000002eLL), MASK_RXF_FRRDF, INSTR_RXF_FRRDF, 3, 3, 0, "multiply and add short hfp" },
  { "lxe", OP48(0xed0000000026LL), MASK_RXE_FERRD, INSTR_RXE_FERRD, 3, 0, 0, "load lengthened short to extended hfp" },
  { "lxd", OP48(0xed0000000025LL), MASK_RXE_FERRD, INSTR_RXE_FERRD, 3, 0, 0, "load lengthened long to extended hfp" },
  { "lde", OP48(0xed0000000024LL), MASK_RXE_FRRD, INSTR_RXE_FRRD, 3, 0, 0, "load lengthened short to long hfp" },
  { "msdb", OP48(0xed000000001fLL), MASK_RXF_FRRDF, INSTR_RXF_FRRDF, 3, 0, 0, "multiply and subtract long bfp" },
  { "madb", OP48(0xed000000001eLL), MASK_RXF_FRRDF, INSTR_RXF_FRRDF, 3, 0, 0, "multiply and add long bfp" },
  { "ddb", OP48(0xed000000001dLL), MASK_RXE_FRRD, INSTR_RXE_FRRD, 3, 0, 0, "divide long bfp" },
  { "mdb", OP48(0xed000000001cLL), MASK_RXE_FRRD, INSTR_RXE_FRRD, 3, 0, 0, "multiply long bfp" },
  { "sdb", OP48(0xed000000001bLL), MASK_RXE_FRRD, INSTR_RXE_FRRD, 3, 0, 0, "subtract long bfp" },
  { "adb", OP48(0xed000000001aLL), MASK_RXE_FRRD, INSTR_RXE_FRRD, 3, 0, 0, "add long bfp" },
  { "cdb", OP48(0xed0000000019LL), MASK_RXE_FRRD, INSTR_RXE_FRRD, 3, 0, 0, "compare long bfp" },
  { "kdb", OP48(0xed0000000018LL), MASK_RXE_FRRD, INSTR_RXE_FRRD, 3, 0, 0, "compare and signal long bfp" },
  { "meeb", OP48(0xed0000000017LL), MASK_RXE_FRRD, INSTR_RXE_FRRD, 3, 0, 0, "multiply short bfp" },
  { "sqdb", OP48(0xed0000000015LL), MASK_RXE_FRRD, INSTR_RXE_FRRD, 3, 0, 0, "square root long bfp" },
  { "sqeb", OP48(0xed0000000014LL), MASK_RXE_FRRD, INSTR_RXE_FRRD, 3, 0, 0, "square root short bfp" },
  { "tcxb", OP48(0xed0000000012LL), MASK_RXE_FERRD, INSTR_RXE_FERRD, 3, 0, 0, "test data class extended bfp" },
  { "tcdb", OP48(0xed0000000011LL), MASK_RXE_FRRD, INSTR_RXE_FRRD, 3, 0, 0, "test data class long bfp" },
  { "tceb", OP48(0xed0000000010LL), MASK_RXE_FRRD, INSTR_RXE_FRRD, 3, 0, 0, "test data class short bfp" },
  { "mseb", OP48(0xed000000000fLL), MASK_RXF_FRRDF, INSTR_RXF_FRRDF, 3, 0, 0, "multiply and subtract short bfp" },
  { "maeb", OP48(0xed000000000eLL), MASK_RXF_FRRDF, INSTR_RXF_FRRDF, 3, 0, 0, "multiply and add short bfp" },
  { "deb", OP48(0xed000000000dLL), MASK_RXE_FRRD, INSTR_RXE_FRRD, 3, 0, 0, "divide short bfp" },
  { "mdeb", OP48(0xed000000000cLL), MASK_RXE_FRRD, INSTR_RXE_FRRD, 3, 0, 0, "multiply short to long bfp" },
  { "seb", OP48(0xed000000000bLL), MASK_RXE_FRRD, INSTR_RXE_FRRD, 3, 0, 0, "subtract short bfp" },
  { "aeb", OP48(0xed000000000aLL), MASK_RXE_FRRD, INSTR_RXE_FRRD, 3, 0, 0, "add short bfp" },
  { "ceb", OP48(0xed0000000009LL), MASK_RXE_FRRD, INSTR_RXE_FRRD, 3, 0, 0, "compare short bfp" },
  { "keb", OP48(0xed0000000008LL), MASK_RXE_FRRD, INSTR_RXE_FRRD, 3, 0, 0, "compare and signal short bfp" },
  { "mxdb", OP48(0xed0000000007LL), MASK_RXE_FERRD, INSTR_RXE_FERRD, 3, 0, 0, "multiply long to extended bfp" },
  { "lxeb", OP48(0xed0000000006LL), MASK_RXE_FERRD, INSTR_RXE_FERRD, 3, 0, 0, "load lengthened short to extended bfp" },
  { "lxdb", OP48(0xed0000000005LL), MASK_RXE_FERRD, INSTR_RXE_FERRD, 3, 0, 0, "load lengthened long to extended bfp" },
  { "ldeb", OP48(0xed0000000004LL), MASK_RXE_FRRD, INSTR_RXE_FRRD, 3, 0, 0, "load lengthened short to long bfp" },
  { "lochhino", OP48(0xec0e0000004eLL), MASK_RIE_R0I0, INSTR_RIE_R0I0, 2, 9, 0, "load halfword high immediate on condition on not overflow / if not ones" },
  { "locghino", OP48(0xec0e00000046LL), MASK_RIE_R0I0, INSTR_RIE_R0I0, 2, 9, 0, "load halfword immediate on condition into 64 bit gpr on not overflow / if not ones" },
  { "lochino", OP48(0xec0e00000042LL), MASK_RIE_R0I0, INSTR_RIE_R0I0, 2, 9, 0, "load halfword immediate on condition into 32 bit gpr on not overflow / if not ones" },
  { "lochhinh", OP48(0xec0d0000004eLL), MASK_RIE_R0I0, INSTR_RIE_R0I0, 2, 9, 0, "load halfword high immediate on condition on A not high" },
  { "lochhinp", OP48(0xec0d0000004eLL), MASK_RIE_R0I0, INSTR_RIE_R0I0, 2, 9, 0, "load halfword high immediate on condition on not plus" },
  { "locghinh", OP48(0xec0d00000046LL), MASK_RIE_R0I0, INSTR_RIE_R0I0, 2, 9, 0, "load halfword immediate on condition into 64 bit gpr on A not high" },
  { "locghinp", OP48(0xec0d00000046LL), MASK_RIE_R0I0, INSTR_RIE_R0I0, 2, 9, 0, "load halfword immediate on condition into 64 bit gpr on not plus" },
  { "lochinh", OP48(0xec0d00000042LL), MASK_RIE_R0I0, INSTR_RIE_R0I0, 2, 9, 0, "load halfword immediate on condition into 32 bit gpr on A not high" },
  { "lochinp", OP48(0xec0d00000042LL), MASK_RIE_R0I0, INSTR_RIE_R0I0, 2, 9, 0, "load halfword immediate on condition into 32 bit gpr on not plus" },
  { "clibnh", OP48(0xec0c000000ffLL), MASK_RIS_R0RDU, INSTR_RIS_R0RDU, 2, 6, 0, "compare logical immediate and branch (32<8) on A not high" },
  { "clible", OP48(0xec0c000000ffLL), MASK_RIS_R0RDU, INSTR_RIS_R0RDU, 2, 6, 0, "compare logical immediate and branch (32<8) on low or equal" },
  { "cibnh", OP48(0xec0c000000feLL), MASK_RIS_R0RDI, INSTR_RIS_R0RDI, 2, 6, 0, "compare immediate and branch (32<8) on A not high" },
  { "cible", OP48(0xec0c000000feLL), MASK_RIS_R0RDI, INSTR_RIS_R0RDI, 2, 6, 0, "compare immediate and branch (32<8) on low or equal" },
  { "clgibnh", OP48(0xec0c000000fdLL), MASK_RIS_R0RDU, INSTR_RIS_R0RDU, 2, 6, 0, "compare logical immediate and branch (64<8) on A not high" },
  { "clgible", OP48(0xec0c000000fdLL), MASK_RIS_R0RDU, INSTR_RIS_R0RDU, 2, 6, 0, "compare logical immediate and branch (64<8) on low or equal" },
  { "cgibnh", OP48(0xec0c000000fcLL), MASK_RIS_R0RDI, INSTR_RIS_R0RDI, 2, 6, 0, "compare immediate and branch (64<8) on A not high" },
  { "cgible", OP48(0xec0c000000fcLL), MASK_RIS_R0RDI, INSTR_RIS_R0RDI, 2, 6, 0, "compare immediate and branch (64<8) on low or equal" },
  { "clijnh", OP48(0xec0c0000007fLL), MASK_RIE_R0PU, INSTR_RIE_R0PU, 2, 6, 112, "compare logical immediate and branch relative (32<8) on A not high" },
  { "clijle", OP48(0xec0c0000007fLL), MASK_RIE_R0PU, INSTR_RIE_R0PU, 2, 6, 112, "compare logical immediate and branch relative (32<8) on low or equal" },
  { "cijnh", OP48(0xec0c0000007eLL), MASK_RIE_R0PI, INSTR_RIE_R0PI, 2, 6, 112, "compare immediate and branch relative (32<8) on A not high" },
  { "cijle", OP48(0xec0c0000007eLL), MASK_RIE_R0PI, INSTR_RIE_R0PI, 2, 6, 112, "compare immediate and branch relative (32<8) on low or equal" },
  { "clgijnh", OP48(0xec0c0000007dLL), MASK_RIE_R0PU, INSTR_RIE_R0PU, 2, 6, 112, "compare logical immediate and branch relative (64<8) on A not high" },
  { "clgijle", OP48(0xec0c0000007dLL), MASK_RIE_R0PU, INSTR_RIE_R0PU, 2, 6, 112, "compare logical immediate and branch relative (64<8) on low or equal" },
  { "cgijnh", OP48(0xec0c0000007cLL), MASK_RIE_R0PI, INSTR_RIE_R0PI, 2, 6, 112, "compare immediate and branch relative (64<8) on A not high" },
  { "cgijle", OP48(0xec0c0000007cLL), MASK_RIE_R0PI, INSTR_RIE_R0PI, 2, 6, 112, "compare immediate and branch relative (64<8) on low or equal" },
  { "lochhile", OP48(0xec0c0000004eLL), MASK_RIE_R0I0, INSTR_RIE_R0I0, 2, 9, 0, "load halfword high immediate on condition on low or equal" },
  { "locghile", OP48(0xec0c00000046LL), MASK_RIE_R0I0, INSTR_RIE_R0I0, 2, 9, 0, "load halfword immediate on condition into 64 bit gpr on low or equal" },
  { "lochile", OP48(0xec0c00000042LL), MASK_RIE_R0I0, INSTR_RIE_R0I0, 2, 9, 0, "load halfword immediate on condition into 32 bit gpr on low or equal" },
  { "lochhinl", OP48(0xec0b0000004eLL), MASK_RIE_R0I0, INSTR_RIE_R0I0, 2, 9, 0, "load halfword high immediate on condition on A not low" },
  { "lochhinm", OP48(0xec0b0000004eLL), MASK_RIE_R0I0, INSTR_RIE_R0I0, 2, 9, 0, "load halfword high immediate on condition on not minus / if not mixed" },
  { "locghinl", OP48(0xec0b00000046LL), MASK_RIE_R0I0, INSTR_RIE_R0I0, 2, 9, 0, "load halfword immediate on condition into 64 bit gpr on A not low" },
  { "locghinm", OP48(0xec0b00000046LL), MASK_RIE_R0I0, INSTR_RIE_R0I0, 2, 9, 0, "load halfword immediate on condition into 64 bit gpr on not minus / if not mixed" },
  { "lochinl", OP48(0xec0b00000042LL), MASK_RIE_R0I0, INSTR_RIE_R0I0, 2, 9, 0, "load halfword immediate on condition into 32 bit gpr on A not low" },
  { "lochinm", OP48(0xec0b00000042LL), MASK_RIE_R0I0, INSTR_RIE_R0I0, 2, 9, 0, "load halfword immediate on condition into 32 bit gpr on not minus / if not mixed" },
  { "clibnl", OP48(0xec0a000000ffLL), MASK_RIS_R0RDU, INSTR_RIS_R0RDU, 2, 6, 0, "compare logical immediate and branch (32<8) on A not low" },
  { "clibhe", OP48(0xec0a000000ffLL), MASK_RIS_R0RDU, INSTR_RIS_R0RDU, 2, 6, 0, "compare logical immediate and branch (32<8) on high or equal" },
  { "cibnl", OP48(0xec0a000000feLL), MASK_RIS_R0RDI, INSTR_RIS_R0RDI, 2, 6, 0, "compare immediate and branch (32<8) on A not low" },
  { "cibhe", OP48(0xec0a000000feLL), MASK_RIS_R0RDI, INSTR_RIS_R0RDI, 2, 6, 0, "compare immediate and branch (32<8) on high or equal" },
  { "clgibnl", OP48(0xec0a000000fdLL), MASK_RIS_R0RDU, INSTR_RIS_R0RDU, 2, 6, 0, "compare logical immediate and branch (64<8) on A not low" },
  { "clgibhe", OP48(0xec0a000000fdLL), MASK_RIS_R0RDU, INSTR_RIS_R0RDU, 2, 6, 0, "compare logical immediate and branch (64<8) on high or equal" },
  { "cgibnl", OP48(0xec0a000000fcLL), MASK_RIS_R0RDI, INSTR_RIS_R0RDI, 2, 6, 0, "compare immediate and branch (64<8) on A not low" },
  { "cgibhe", OP48(0xec0a000000fcLL), MASK_RIS_R0RDI, INSTR_RIS_R0RDI, 2, 6, 0, "compare immediate and branch (64<8) on high or equal" },
  { "clijnl", OP48(0xec0a0000007fLL), MASK_RIE_R0PU, INSTR_RIE_R0PU, 2, 6, 112, "compare logical immediate and branch relative (32<8) on A not low" },
  { "clijhe", OP48(0xec0a0000007fLL), MASK_RIE_R0PU, INSTR_RIE_R0PU, 2, 6, 112, "compare logical immediate and branch relative (32<8) on high or equal" },
  { "cijnl", OP48(0xec0a0000007eLL), MASK_RIE_R0PI, INSTR_RIE_R0PI, 2, 6, 112, "compare immediate and branch relative (32<8) on A not low" },
  { "cijhe", OP48(0xec0a0000007eLL), MASK_RIE_R0PI, INSTR_RIE_R0PI, 2, 6, 112, "compare immediate and branch relative (32<8) on high or equal" },
  { "clgijnl", OP48(0xec0a0000007dLL), MASK_RIE_R0PU, INSTR_RIE_R0PU, 2, 6, 112, "compare logical immediate and branch relative (64<8) on A not low" },
  { "clgijhe", OP48(0xec0a0000007dLL), MASK_RIE_R0PU, INSTR_RIE_R0PU, 2, 6, 112, "compare logical immediate and branch relative (64<8) on high or equal" },
  { "cgijnl", OP48(0xec0a0000007cLL), MASK_RIE_R0PI, INSTR_RIE_R0PI, 2, 6, 112, "compare immediate and branch relative (64<8) on A not low" },
  { "cgijhe", OP48(0xec0a0000007cLL), MASK_RIE_R0PI, INSTR_RIE_R0PI, 2, 6, 112, "compare immediate and branch relative (64<8) on high or equal" },
  { "lochhihe", OP48(0xec0a0000004eLL), MASK_RIE_R0I0, INSTR_RIE_R0I0, 2, 9, 0, "load halfword high immediate on condition on high or equal" },
  { "locghihe", OP48(0xec0a00000046LL), MASK_RIE_R0I0, INSTR_RIE_R0I0, 2, 9, 0, "load halfword immediate on condition into 64 bit gpr on high or equal" },
  { "lochihe", OP48(0xec0a00000042LL), MASK_RIE_R0I0, INSTR_RIE_R0I0, 2, 9, 0, "load halfword immediate on condition into 32 bit gpr on high or equal" },
  { "lochhinlh", OP48(0xec090000004eLL), MASK_RIE_R0I0, INSTR_RIE_R0I0, 2, 9, 0, "load halfword high immediate on condition on not low or high" },
  { "locghinlh", OP48(0xec0900000046LL), MASK_RIE_R0I0, INSTR_RIE_R0I0, 2, 9, 0, "load halfword immediate on condition into 64 bit gpr on not low or high" },
  { "lochinlh", OP48(0xec0900000042LL), MASK_RIE_R0I0, INSTR_RIE_R0I0, 2, 9, 0, "load halfword immediate on condition into 32 bit gpr on not low or high" },
  { "clibe", OP48(0xec08000000ffLL), MASK_RIS_R0RDU, INSTR_RIS_R0RDU, 2, 6, 0, "compare logical immediate and branch (32<8) on A equal B" },
  { "clibnlh", OP48(0xec08000000ffLL), MASK_RIS_R0RDU, INSTR_RIS_R0RDU, 2, 6, 0, "compare logical immediate and branch (32<8) on not low or high" },
  { "cibe", OP48(0xec08000000feLL), MASK_RIS_R0RDI, INSTR_RIS_R0RDI, 2, 6, 0, "compare immediate and branch (32<8) on A equal B" },
  { "cibnlh", OP48(0xec08000000feLL), MASK_RIS_R0RDI, INSTR_RIS_R0RDI, 2, 6, 0, "compare immediate and branch (32<8) on not low or high" },
  { "clgibe", OP48(0xec08000000fdLL), MASK_RIS_R0RDU, INSTR_RIS_R0RDU, 2, 6, 0, "compare logical immediate and branch (64<8) on A equal B" },
  { "clgibnlh", OP48(0xec08000000fdLL), MASK_RIS_R0RDU, INSTR_RIS_R0RDU, 2, 6, 0, "compare logical immediate and branch (64<8) on not low or high" },
  { "cgibe", OP48(0xec08000000fcLL), MASK_RIS_R0RDI, INSTR_RIS_R0RDI, 2, 6, 0, "compare immediate and branch (64<8) on A equal B" },
  { "cgibnlh", OP48(0xec08000000fcLL), MASK_RIS_R0RDI, INSTR_RIS_R0RDI, 2, 6, 0, "compare immediate and branch (64<8) on not low or high" },
  { "clije", OP48(0xec080000007fLL), MASK_RIE_R0PU, INSTR_RIE_R0PU, 2, 6, 112, "compare logical immediate and branch relative (32<8) on A equal B" },
  { "clijnlh", OP48(0xec080000007fLL), MASK_RIE_R0PU, INSTR_RIE_R0PU, 2, 6, 112, "compare logical immediate and branch relative (32<8) on not low or high" },
  { "cije", OP48(0xec080000007eLL), MASK_RIE_R0PI, INSTR_RIE_R0PI, 2, 6, 112, "compare immediate and branch relative (32<8) on A equal B" },
  { "cijnlh", OP48(0xec080000007eLL), MASK_RIE_R0PI, INSTR_RIE_R0PI, 2, 6, 112, "compare immediate and branch relative (32<8) on not low or high" },
  { "clgije", OP48(0xec080000007dLL), MASK_RIE_R0PU, INSTR_RIE_R0PU, 2, 6, 112, "compare logical immediate and branch relative (64<8) on A equal B" },
  { "clgijnlh", OP48(0xec080000007dLL), MASK_RIE_R0PU, INSTR_RIE_R0PU, 2, 6, 112, "compare logical immediate and branch relative (64<8) on not low or high" },
  { "cgije", OP48(0xec080000007cLL), MASK_RIE_R0PI, INSTR_RIE_R0PI, 2, 6, 112, "compare immediate and branch relative (64<8) on A equal B" },
  { "cgijnlh", OP48(0xec080000007cLL), MASK_RIE_R0PI, INSTR_RIE_R0PI, 2, 6, 112, "compare immediate and branch relative (64<8) on not low or high" },
  { "lochhie", OP48(0xec080000004eLL), MASK_RIE_R0I0, INSTR_RIE_R0I0, 2, 9, 0, "load halfword high immediate on condition on A equal B" },
  { "lochhiz", OP48(0xec080000004eLL), MASK_RIE_R0I0, INSTR_RIE_R0I0, 2, 9, 0, "load halfword high immediate on condition on zero / if zeros" },
  { "locghie", OP48(0xec0800000046LL), MASK_RIE_R0I0, INSTR_RIE_R0I0, 2, 9, 0, "load halfword immediate on condition into 64 bit gpr on A equal B" },
  { "locghiz", OP48(0xec0800000046LL), MASK_RIE_R0I0, INSTR_RIE_R0I0, 2, 9, 0, "load halfword immediate on condition into 64 bit gpr on zero / if zeros" },
  { "lochie", OP48(0xec0800000042LL), MASK_RIE_R0I0, INSTR_RIE_R0I0, 2, 9, 0, "load halfword immediate on condition into 32 bit gpr on A equal B" },
  { "lochiz", OP48(0xec0800000042LL), MASK_RIE_R0I0, INSTR_RIE_R0I0, 2, 9, 0, "load halfword immediate on condition into 32 bit gpr on zero / if zeros" },
  { "lochhine", OP48(0xec070000004eLL), MASK_RIE_R0I0, INSTR_RIE_R0I0, 2, 9, 0, "load halfword high immediate on condition on A not equal B" },
  { "lochhinz", OP48(0xec070000004eLL), MASK_RIE_R0I0, INSTR_RIE_R0I0, 2, 9, 0, "load halfword high immediate on condition on not zero / if not zeros" },
  { "locghine", OP48(0xec0700000046LL), MASK_RIE_R0I0, INSTR_RIE_R0I0, 2, 9, 0, "load halfword immediate on condition into 64 bit gpr on A not equal B" },
  { "locghinz", OP48(0xec0700000046LL), MASK_RIE_R0I0, INSTR_RIE_R0I0, 2, 9, 0, "load halfword immediate on condition into 64 bit gpr on not zero / if not zeros" },
  { "lochine", OP48(0xec0700000042LL), MASK_RIE_R0I0, INSTR_RIE_R0I0, 2, 9, 0, "load halfword immediate on condition into 32 bit gpr on A not equal B" },
  { "lochinz", OP48(0xec0700000042LL), MASK_RIE_R0I0, INSTR_RIE_R0I0, 2, 9, 0, "load halfword immediate on condition into 32 bit gpr on not zero / if not zeros" },
  { "clibne", OP48(0xec06000000ffLL), MASK_RIS_R0RDU, INSTR_RIS_R0RDU, 2, 6, 0, "compare logical immediate and branch (32<8) on A not equal B" },
  { "cliblh", OP48(0xec06000000ffLL), MASK_RIS_R0RDU, INSTR_RIS_R0RDU, 2, 6, 0, "compare logical immediate and branch (32<8) on low or high" },
  { "cibne", OP48(0xec06000000feLL), MASK_RIS_R0RDI, INSTR_RIS_R0RDI, 2, 6, 0, "compare immediate and branch (32<8) on A not equal B" },
  { "ciblh", OP48(0xec06000000feLL), MASK_RIS_R0RDI, INSTR_RIS_R0RDI, 2, 6, 0, "compare immediate and branch (32<8) on low or high" },
  { "clgibne", OP48(0xec06000000fdLL), MASK_RIS_R0RDU, INSTR_RIS_R0RDU, 2, 6, 0, "compare logical immediate and branch (64<8) on A not equal B" },
  { "clgiblh", OP48(0xec06000000fdLL), MASK_RIS_R0RDU, INSTR_RIS_R0RDU, 2, 6, 0, "compare logical immediate and branch (64<8) on low or high" },
  { "cgibne", OP48(0xec06000000fcLL), MASK_RIS_R0RDI, INSTR_RIS_R0RDI, 2, 6, 0, "compare immediate and branch (64<8) on A not equal B" },
  { "cgiblh", OP48(0xec06000000fcLL), MASK_RIS_R0RDI, INSTR_RIS_R0RDI, 2, 6, 0, "compare immediate and branch (64<8) on low or high" },
  { "clijne", OP48(0xec060000007fLL), MASK_RIE_R0PU, INSTR_RIE_R0PU, 2, 6, 112, "compare logical immediate and branch relative (32<8) on A not equal B" },
  { "clijlh", OP48(0xec060000007fLL), MASK_RIE_R0PU, INSTR_RIE_R0PU, 2, 6, 112, "compare logical immediate and branch relative (32<8) on low or high" },
  { "cijne", OP48(0xec060000007eLL), MASK_RIE_R0PI, INSTR_RIE_R0PI, 2, 6, 112, "compare immediate and branch relative (32<8) on A not equal B" },
  { "cijlh", OP48(0xec060000007eLL), MASK_RIE_R0PI, INSTR_RIE_R0PI, 2, 6, 112, "compare immediate and branch relative (32<8) on low or high" },
  { "clgijne", OP48(0xec060000007dLL), MASK_RIE_R0PU, INSTR_RIE_R0PU, 2, 6, 112, "compare logical immediate and branch relative (64<8) on A not equal B" },
  { "clgijlh", OP48(0xec060000007dLL), MASK_RIE_R0PU, INSTR_RIE_R0PU, 2, 6, 112, "compare logical immediate and branch relative (64<8) on low or high" },
  { "cgijne", OP48(0xec060000007cLL), MASK_RIE_R0PI, INSTR_RIE_R0PI, 2, 6, 112, "compare immediate and branch relative (64<8) on A not equal B" },
  { "cgijlh", OP48(0xec060000007cLL), MASK_RIE_R0PI, INSTR_RIE_R0PI, 2, 6, 112, "compare immediate and branch relative (64<8) on low or high" },
  { "lochhilh", OP48(0xec060000004eLL), MASK_RIE_R0I0, INSTR_RIE_R0I0, 2, 9, 0, "load halfword high immediate on condition on low or high" },
  { "locghilh", OP48(0xec0600000046LL), MASK_RIE_R0I0, INSTR_RIE_R0I0, 2, 9, 0, "load halfword immediate on condition into 64 bit gpr on low or high" },
  { "lochilh", OP48(0xec0600000042LL), MASK_RIE_R0I0, INSTR_RIE_R0I0, 2, 9, 0, "load halfword immediate on condition into 32 bit gpr on low or high" },
  { "lochhinhe", OP48(0xec050000004eLL), MASK_RIE_R0I0, INSTR_RIE_R0I0, 2, 9, 0, "load halfword high immediate on condition on not high or equal" },
  { "locghinhe", OP48(0xec0500000046LL), MASK_RIE_R0I0, INSTR_RIE_R0I0, 2, 9, 0, "load halfword immediate on condition into 64 bit gpr on not high or equal" },
  { "lochinhe", OP48(0xec0500000042LL), MASK_RIE_R0I0, INSTR_RIE_R0I0, 2, 9, 0, "load halfword immediate on condition into 32 bit gpr on not high or equal" },
  { "clibl", OP48(0xec04000000ffLL), MASK_RIS_R0RDU, INSTR_RIS_R0RDU, 2, 6, 0, "compare logical immediate and branch (32<8) on A low" },
  { "clibnhe", OP48(0xec04000000ffLL), MASK_RIS_R0RDU, INSTR_RIS_R0RDU, 2, 6, 0, "compare logical immediate and branch (32<8) on not high or equal" },
  { "cibl", OP48(0xec04000000feLL), MASK_RIS_R0RDI, INSTR_RIS_R0RDI, 2, 6, 0, "compare immediate and branch (32<8) on A low" },
  { "cibnhe", OP48(0xec04000000feLL), MASK_RIS_R0RDI, INSTR_RIS_R0RDI, 2, 6, 0, "compare immediate and branch (32<8) on not high or equal" },
  { "clgibl", OP48(0xec04000000fdLL), MASK_RIS_R0RDU, INSTR_RIS_R0RDU, 2, 6, 0, "compare logical immediate and branch (64<8) on A low" },
  { "clgibnhe", OP48(0xec04000000fdLL), MASK_RIS_R0RDU, INSTR_RIS_R0RDU, 2, 6, 0, "compare logical immediate and branch (64<8) on not high or equal" },
  { "cgibl", OP48(0xec04000000fcLL), MASK_RIS_R0RDI, INSTR_RIS_R0RDI, 2, 6, 0, "compare immediate and branch (64<8) on A low" },
  { "cgibnhe", OP48(0xec04000000fcLL), MASK_RIS_R0RDI, INSTR_RIS_R0RDI, 2, 6, 0, "compare immediate and branch (64<8) on not high or equal" },
  { "clijl", OP48(0xec040000007fLL), MASK_RIE_R0PU, INSTR_RIE_R0PU, 2, 6, 112, "compare logical immediate and branch relative (32<8) on A low" },
  { "clijnhe", OP48(0xec040000007fLL), MASK_RIE_R0PU, INSTR_RIE_R0PU, 2, 6, 112, "compare logical immediate and branch relative (32<8) on not high or equal" },
  { "cijl", OP48(0xec040000007eLL), MASK_RIE_R0PI, INSTR_RIE_R0PI, 2, 6, 112, "compare immediate and branch relative (32<8) on A low" },
  { "cijnhe", OP48(0xec040000007eLL), MASK_RIE_R0PI, INSTR_RIE_R0PI, 2, 6, 112, "compare immediate and branch relative (32<8) on not high or equal" },
  { "clgijl", OP48(0xec040000007dLL), MASK_RIE_R0PU, INSTR_RIE_R0PU, 2, 6, 112, "compare logical immediate and branch relative (64<8) on A low" },
  { "clgijnhe", OP48(0xec040000007dLL), MASK_RIE_R0PU, INSTR_RIE_R0PU, 2, 6, 112, "compare logical immediate and branch relative (64<8) on not high or equal" },
  { "cgijl", OP48(0xec040000007cLL), MASK_RIE_R0PI, INSTR_RIE_R0PI, 2, 6, 112, "compare immediate and branch relative (64<8) on A low" },
  { "cgijnhe", OP48(0xec040000007cLL), MASK_RIE_R0PI, INSTR_RIE_R0PI, 2, 6, 112, "compare immediate and branch relative (64<8) on not high or equal" },
  { "lochhil", OP48(0xec040000004eLL), MASK_RIE_R0I0, INSTR_RIE_R0I0, 2, 9, 0, "load halfword high immediate on condition on A low" },
  { "lochhim", OP48(0xec040000004eLL), MASK_RIE_R0I0, INSTR_RIE_R0I0, 2, 9, 0, "load halfword high immediate on condition on minus / if mixed" },
  { "locghil", OP48(0xec0400000046LL), MASK_RIE_R0I0, INSTR_RIE_R0I0, 2, 9, 0, "load halfword immediate on condition into 64 bit gpr on A low" },
  { "locghim", OP48(0xec0400000046LL), MASK_RIE_R0I0, INSTR_RIE_R0I0, 2, 9, 0, "load halfword immediate on condition into 64 bit gpr on minus / if mixed" },
  { "lochil", OP48(0xec0400000042LL), MASK_RIE_R0I0, INSTR_RIE_R0I0, 2, 9, 0, "load halfword immediate on condition into 32 bit gpr on A low" },
  { "lochim", OP48(0xec0400000042LL), MASK_RIE_R0I0, INSTR_RIE_R0I0, 2, 9, 0, "load halfword immediate on condition into 32 bit gpr on minus / if mixed" },
  { "lochhinle", OP48(0xec030000004eLL), MASK_RIE_R0I0, INSTR_RIE_R0I0, 2, 9, 0, "load halfword high immediate on condition on not low or equal" },
  { "locghinle", OP48(0xec0300000046LL), MASK_RIE_R0I0, INSTR_RIE_R0I0, 2, 9, 0, "load halfword immediate on condition into 64 bit gpr on not low or equal" },
  { "lochinle", OP48(0xec0300000042LL), MASK_RIE_R0I0, INSTR_RIE_R0I0, 2, 9, 0, "load halfword immediate on condition into 32 bit gpr on not low or equal" },
  { "clibh", OP48(0xec02000000ffLL), MASK_RIS_R0RDU, INSTR_RIS_R0RDU, 2, 6, 0, "compare logical immediate and branch (32<8) on A high" },
  { "clibnle", OP48(0xec02000000ffLL), MASK_RIS_R0RDU, INSTR_RIS_R0RDU, 2, 6, 0, "compare logical immediate and branch (32<8) on not low or equal" },
  { "cibh", OP48(0xec02000000feLL), MASK_RIS_R0RDI, INSTR_RIS_R0RDI, 2, 6, 0, "compare immediate and branch (32<8) on A high" },
  { "cibnle", OP48(0xec02000000feLL), MASK_RIS_R0RDI, INSTR_RIS_R0RDI, 2, 6, 0, "compare immediate and branch (32<8) on not low or equal" },
  { "clgibh", OP48(0xec02000000fdLL), MASK_RIS_R0RDU, INSTR_RIS_R0RDU, 2, 6, 0, "compare logical immediate and branch (64<8) on A high" },
  { "clgibnle", OP48(0xec02000000fdLL), MASK_RIS_R0RDU, INSTR_RIS_R0RDU, 2, 6, 0, "compare logical immediate and branch (64<8) on not low or equal" },
  { "cgibh", OP48(0xec02000000fcLL), MASK_RIS_R0RDI, INSTR_RIS_R0RDI, 2, 6, 0, "compare immediate and branch (64<8) on A high" },
  { "cgibnle", OP48(0xec02000000fcLL), MASK_RIS_R0RDI, INSTR_RIS_R0RDI, 2, 6, 0, "compare immediate and branch (64<8) on not low or equal" },
  { "clijh", OP48(0xec020000007fLL), MASK_RIE_R0PU, INSTR_RIE_R0PU, 2, 6, 112, "compare logical immediate and branch relative (32<8) on A high" },
  { "clijnle", OP48(0xec020000007fLL), MASK_RIE_R0PU, INSTR_RIE_R0PU, 2, 6, 112, "compare logical immediate and branch relative (32<8) on not low or equal" },
  { "cijh", OP48(0xec020000007eLL), MASK_RIE_R0PI, INSTR_RIE_R0PI, 2, 6, 112, "compare immediate and branch relative (32<8) on A high" },
  { "cijnle", OP48(0xec020000007eLL), MASK_RIE_R0PI, INSTR_RIE_R0PI, 2, 6, 112, "compare immediate and branch relative (32<8) on not low or equal" },
  { "clgijh", OP48(0xec020000007dLL), MASK_RIE_R0PU, INSTR_RIE_R0PU, 2, 6, 112, "compare logical immediate and branch relative (64<8) on A high" },
  { "clgijnle", OP48(0xec020000007dLL), MASK_RIE_R0PU, INSTR_RIE_R0PU, 2, 6, 112, "compare logical immediate and branch relative (64<8) on not low or equal" },
  { "cgijh", OP48(0xec020000007cLL), MASK_RIE_R0PI, INSTR_RIE_R0PI, 2, 6, 112, "compare immediate and branch relative (64<8) on A high" },
  { "cgijnle", OP48(0xec020000007cLL), MASK_RIE_R0PI, INSTR_RIE_R0PI, 2, 6, 112, "compare immediate and branch relative (64<8) on not low or equal" },
  { "lochhih", OP48(0xec020000004eLL), MASK_RIE_R0I0, INSTR_RIE_R0I0, 2, 9, 0, "load halfword high immediate on condition on A high" },
  { "lochhip", OP48(0xec020000004eLL), MASK_RIE_R0I0, INSTR_RIE_R0I0, 2, 9, 0, "load halfword high immediate on condition on plus" },
  { "locghih", OP48(0xec0200000046LL), MASK_RIE_R0I0, INSTR_RIE_R0I0, 2, 9, 0, "load halfword immediate on condition into 64 bit gpr on A high" },
  { "locghip", OP48(0xec0200000046LL), MASK_RIE_R0I0, INSTR_RIE_R0I0, 2, 9, 0, "load halfword immediate on condition into 64 bit gpr on plus" },
  { "lochih", OP48(0xec0200000042LL), MASK_RIE_R0I0, INSTR_RIE_R0I0, 2, 9, 0, "load halfword immediate on condition into 32 bit gpr on A high" },
  { "lochip", OP48(0xec0200000042LL), MASK_RIE_R0I0, INSTR_RIE_R0I0, 2, 9, 0, "load halfword immediate on condition into 32 bit gpr on plus" },
  { "lochhio", OP48(0xec010000004eLL), MASK_RIE_R0I0, INSTR_RIE_R0I0, 2, 9, 0, "load halfword high immediate on condition on overflow / if ones" },
  { "locghio", OP48(0xec0100000046LL), MASK_RIE_R0I0, INSTR_RIE_R0I0, 2, 9, 0, "load halfword immediate on condition into 64 bit gpr on overflow / if ones" },
  { "lochio", OP48(0xec0100000042LL), MASK_RIE_R0I0, INSTR_RIE_R0I0, 2, 9, 0, "load halfword immediate on condition into 32 bit gpr on overflow / if ones" },
  { "rxsbgt", OP48(0xec0080000057LL), MASK_RIE_RRUUU4, INSTR_RIE_RRUUU4, 2, 6, 1, "rotate then exclusive or selected bits and test results" },
  { "rosbgt", OP48(0xec0080000056LL), MASK_RIE_RRUUU4, INSTR_RIE_RRUUU4, 2, 6, 1, "rotate then or selected bits and test results" },
  { "rnsbgt", OP48(0xec0080000054LL), MASK_RIE_RRUUU4, INSTR_RIE_RRUUU4, 2, 6, 1, "rotate then and selected bits and test results" },
  { "risbhgz", OP48(0xec000080005dLL), MASK_RIE_RRUUU3, INSTR_RIE_RRUUU3, 2, 7, 1, "rotate then insert selected bits high and zero remaining bits" },
  { "risbgnz", OP48(0xec0000800059LL), MASK_RIE_RRUUU2, INSTR_RIE_RRUUU2, 2, 8, 1, "rotate then insert selected bits and zero remaining bits nocc" },
  { "risbgz", OP48(0xec0000800055LL), MASK_RIE_RRUUU2, INSTR_RIE_RRUUU2, 2, 6, 1, "rotate then insert selected bits and zero remaining bits" },
  { "risblgz", OP48(0xec0000800051LL), MASK_RIE_RRUUU3, INSTR_RIE_RRUUU3, 2, 7, 1, "rotate then insert selected bits low and zero remaining bits" },
  { "clrbnh", OP48(0xec000000c0f7LL), MASK_RRS_RRRD0, INSTR_RRS_RRRD0, 2, 6, 0, "compare logical and branch (32) on A not high" },
  { "clrble", OP48(0xec000000c0f7LL), MASK_RRS_RRRD0, INSTR_RRS_RRRD0, 2, 6, 0, "compare logical and branch (32) on low or equal" },
  { "crbnh", OP48(0xec000000c0f6LL), MASK_RRS_RRRD0, INSTR_RRS_RRRD0, 2, 6, 0, "compare and branch (32) on A not high" },
  { "crble", OP48(0xec000000c0f6LL), MASK_RRS_RRRD0, INSTR_RRS_RRRD0, 2, 6, 0, "compare and branch (32) on low or equal" },
  { "clgrbnh", OP48(0xec000000c0e5LL), MASK_RRS_RRRD0, INSTR_RRS_RRRD0, 2, 6, 0, "compare logical and branch (64) on A not high" },
  { "clgrble", OP48(0xec000000c0e5LL), MASK_RRS_RRRD0, INSTR_RRS_RRRD0, 2, 6, 0, "compare logical and branch (64) on low or equal" },
  { "cgrbnh", OP48(0xec000000c0e4LL), MASK_RRS_RRRD0, INSTR_RRS_RRRD0, 2, 6, 0, "compare and branch (64) on A not high" },
  { "cgrble", OP48(0xec000000c0e4LL), MASK_RRS_RRRD0, INSTR_RRS_RRRD0, 2, 6, 0, "compare and branch (64) on low or equal" },
  { "clrjnh", OP48(0xec000000c077LL), MASK_RIE_RRP0, INSTR_RIE_RRP0, 2, 6, 112, "compare logical and branch relative (32) on A not high" },
  { "clrjle", OP48(0xec000000c077LL), MASK_RIE_RRP0, INSTR_RIE_RRP0, 2, 6, 112, "compare logical and branch relative (32) on low or equal" },
  { "crjnh", OP48(0xec000000c076LL), MASK_RIE_RRP0, INSTR_RIE_RRP0, 2, 6, 112, "compare and branch relative (32) on A not high" },
  { "crjle", OP48(0xec000000c076LL), MASK_RIE_RRP0, INSTR_RIE_RRP0, 2, 6, 112, "compare and branch relative (32) on low or equal" },
  { "clfitnh", OP48(0xec000000c073LL), MASK_RIE_R0U0, INSTR_RIE_R0U0, 2, 6, 0, "compare logical and trap (32<16) on A not high" },
  { "clfitle", OP48(0xec000000c073LL), MASK_RIE_R0U0, INSTR_RIE_R0U0, 2, 6, 0, "compare logical and trap (32<16) on low or equal" },
  { "citnh", OP48(0xec000000c072LL), MASK_RIE_R0I0, INSTR_RIE_R0I0, 2, 6, 0, "compare immediate and trap (32<16) on A not high" },
  { "citle", OP48(0xec000000c072LL), MASK_RIE_R0I0, INSTR_RIE_R0I0, 2, 6, 0, "compare immediate and trap (32<16) on low or equal" },
  { "clgitnh", OP48(0xec000000c071LL), MASK_RIE_R0U0, INSTR_RIE_R0U0, 2, 6, 0, "compare logical and trap (64<16) on A not high" },
  { "clgitle", OP48(0xec000000c071LL), MASK_RIE_R0U0, INSTR_RIE_R0U0, 2, 6, 0, "compare logical and trap (64<16) on low or equal" },
  { "cgitnh", OP48(0xec000000c070LL), MASK_RIE_R0I0, INSTR_RIE_R0I0, 2, 6, 0, "compare immediate and trap (64<16) on A not high" },
  { "cgitle", OP48(0xec000000c070LL), MASK_RIE_R0I0, INSTR_RIE_R0I0, 2, 6, 0, "compare immediate and trap (64<16) on low or equal" },
  { "clgrjnh", OP48(0xec000000c065LL), MASK_RIE_RRP0, INSTR_RIE_RRP0, 2, 6, 112, "compare logical and branch relative (64) on A not high" },
  { "clgrjle", OP48(0xec000000c065LL), MASK_RIE_RRP0, INSTR_RIE_RRP0, 2, 6, 112, "compare logical and branch relative (64) on low or equal" },
  { "cgrjnh", OP48(0xec000000c064LL), MASK_RIE_RRP0, INSTR_RIE_RRP0, 2, 6, 112, "compare and branch relative (64) on A not high" },
  { "cgrjle", OP48(0xec000000c064LL), MASK_RIE_RRP0, INSTR_RIE_RRP0, 2, 6, 112, "compare and branch relative (64) on low or equal" },
  { "clrbnl", OP48(0xec000000a0f7LL), MASK_RRS_RRRD0, INSTR_RRS_RRRD0, 2, 6, 0, "compare logical and branch (32) on A not low" },
  { "clrbhe", OP48(0xec000000a0f7LL), MASK_RRS_RRRD0, INSTR_RRS_RRRD0, 2, 6, 0, "compare logical and branch (32) on high or equal" },
  { "crbnl", OP48(0xec000000a0f6LL), MASK_RRS_RRRD0, INSTR_RRS_RRRD0, 2, 6, 0, "compare and branch (32) on A not low" },
  { "crbhe", OP48(0xec000000a0f6LL), MASK_RRS_RRRD0, INSTR_RRS_RRRD0, 2, 6, 0, "compare and branch (32) on high or equal" },
  { "clgrbnl", OP48(0xec000000a0e5LL), MASK_RRS_RRRD0, INSTR_RRS_RRRD0, 2, 6, 0, "compare logical and branch (64) on A not low" },
  { "clgrbhe", OP48(0xec000000a0e5LL), MASK_RRS_RRRD0, INSTR_RRS_RRRD0, 2, 6, 0, "compare logical and branch (64) on high or equal" },
  { "cgrbnl", OP48(0xec000000a0e4LL), MASK_RRS_RRRD0, INSTR_RRS_RRRD0, 2, 6, 0, "compare and branch (64) on A not low" },
  { "cgrbhe", OP48(0xec000000a0e4LL), MASK_RRS_RRRD0, INSTR_RRS_RRRD0, 2, 6, 0, "compare and branch (64) on high or equal" },
  { "clrjnl", OP48(0xec000000a077LL), MASK_RIE_RRP0, INSTR_RIE_RRP0, 2, 6, 112, "compare logical and branch relative (32) on A not low" },
  { "clrjhe", OP48(0xec000000a077LL), MASK_RIE_RRP0, INSTR_RIE_RRP0, 2, 6, 112, "compare logical and branch relative (32) on high or equal" },
  { "crjnl", OP48(0xec000000a076LL), MASK_RIE_RRP0, INSTR_RIE_RRP0, 2, 6, 112, "compare and branch relative (32) on A not low" },
  { "crjhe", OP48(0xec000000a076LL), MASK_RIE_RRP0, INSTR_RIE_RRP0, 2, 6, 112, "compare and branch relative (32) on high or equal" },
  { "clfitnl", OP48(0xec000000a073LL), MASK_RIE_R0U0, INSTR_RIE_R0U0, 2, 6, 0, "compare logical and trap (32<16) on A not low" },
  { "clfithe", OP48(0xec000000a073LL), MASK_RIE_R0U0, INSTR_RIE_R0U0, 2, 6, 0, "compare logical and trap (32<16) on high or equal" },
  { "citnl", OP48(0xec000000a072LL), MASK_RIE_R0I0, INSTR_RIE_R0I0, 2, 6, 0, "compare immediate and trap (32<16) on A not low" },
  { "cithe", OP48(0xec000000a072LL), MASK_RIE_R0I0, INSTR_RIE_R0I0, 2, 6, 0, "compare immediate and trap (32<16) on high or equal" },
  { "clgitnl", OP48(0xec000000a071LL), MASK_RIE_R0U0, INSTR_RIE_R0U0, 2, 6, 0, "compare logical and trap (64<16) on A not low" },
  { "clgithe", OP48(0xec000000a071LL), MASK_RIE_R0U0, INSTR_RIE_R0U0, 2, 6, 0, "compare logical and trap (64<16) on high or equal" },
  { "cgitnl", OP48(0xec000000a070LL), MASK_RIE_R0I0, INSTR_RIE_R0I0, 2, 6, 0, "compare immediate and trap (64<16) on A not low" },
  { "cgithe", OP48(0xec000000a070LL), MASK_RIE_R0I0, INSTR_RIE_R0I0, 2, 6, 0, "compare immediate and trap (64<16) on high or equal" },
  { "clgrjnl", OP48(0xec000000a065LL), MASK_RIE_RRP0, INSTR_RIE_RRP0, 2, 6, 112, "compare logical and branch relative (64) on A not low" },
  { "clgrjhe", OP48(0xec000000a065LL), MASK_RIE_RRP0, INSTR_RIE_RRP0, 2, 6, 112, "compare logical and branch relative (64) on high or equal" },
  { "cgrjnl", OP48(0xec000000a064LL), MASK_RIE_RRP0, INSTR_RIE_RRP0, 2, 6, 112, "compare and branch relative (64) on A not low" },
  { "cgrjhe", OP48(0xec000000a064LL), MASK_RIE_RRP0, INSTR_RIE_RRP0, 2, 6, 112, "compare and branch relative (64) on high or equal" },
  { "clrbe", OP48(0xec00000080f7LL), MASK_RRS_RRRD0, INSTR_RRS_RRRD0, 2, 6, 0, "compare logical and branch (32) on A equal B" },
  { "clrbnlh", OP48(0xec00000080f7LL), MASK_RRS_RRRD0, INSTR_RRS_RRRD0, 2, 6, 0, "compare logical and branch (32) on not low or high" },
  { "crbe", OP48(0xec00000080f6LL), MASK_RRS_RRRD0, INSTR_RRS_RRRD0, 2, 6, 0, "compare and branch (32) on A equal B" },
  { "crbnlh", OP48(0xec00000080f6LL), MASK_RRS_RRRD0, INSTR_RRS_RRRD0, 2, 6, 0, "compare and branch (32) on not low or high" },
  { "clgrbe", OP48(0xec00000080e5LL), MASK_RRS_RRRD0, INSTR_RRS_RRRD0, 2, 6, 0, "compare logical and branch (64) on A equal B" },
  { "clgrbnlh", OP48(0xec00000080e5LL), MASK_RRS_RRRD0, INSTR_RRS_RRRD0, 2, 6, 0, "compare logical and branch (64) on not low or high" },
  { "cgrbe", OP48(0xec00000080e4LL), MASK_RRS_RRRD0, INSTR_RRS_RRRD0, 2, 6, 0, "compare and branch (64) on A equal B" },
  { "cgrbnlh", OP48(0xec00000080e4LL), MASK_RRS_RRRD0, INSTR_RRS_RRRD0, 2, 6, 0, "compare and branch (64) on not low or high" },
  { "clrje", OP48(0xec0000008077LL), MASK_RIE_RRP0, INSTR_RIE_RRP0, 2, 6, 112, "compare logical and branch relative (32) on A equal B" },
  { "clrjnlh", OP48(0xec0000008077LL), MASK_RIE_RRP0, INSTR_RIE_RRP0, 2, 6, 112, "compare logical and branch relative (32) on not low or high" },
  { "crje", OP48(0xec0000008076LL), MASK_RIE_RRP0, INSTR_RIE_RRP0, 2, 6, 112, "compare and branch relative (32) on A equal B" },
  { "crjnlh", OP48(0xec0000008076LL), MASK_RIE_RRP0, INSTR_RIE_RRP0, 2, 6, 112, "compare and branch relative (32) on not low or high" },
  { "clfite", OP48(0xec0000008073LL), MASK_RIE_R0U0, INSTR_RIE_R0U0, 2, 6, 0, "compare logical and trap (32<16) on A equal B" },
  { "clfitnlh", OP48(0xec0000008073LL), MASK_RIE_R0U0, INSTR_RIE_R0U0, 2, 6, 0, "compare logical and trap (32<16) on not low or high" },
  { "cite", OP48(0xec0000008072LL), MASK_RIE_R0I0, INSTR_RIE_R0I0, 2, 6, 0, "compare immediate and trap (32<16) on A equal B" },
  { "citnlh", OP48(0xec0000008072LL), MASK_RIE_R0I0, INSTR_RIE_R0I0, 2, 6, 0, "compare immediate and trap (32<16) on not low or high" },
  { "clgite", OP48(0xec0000008071LL), MASK_RIE_R0U0, INSTR_RIE_R0U0, 2, 6, 0, "compare logical and trap (64<16) on A equal B" },
  { "clgitnlh", OP48(0xec0000008071LL), MASK_RIE_R0U0, INSTR_RIE_R0U0, 2, 6, 0, "compare logical and trap (64<16) on not low or high" },
  { "cgite", OP48(0xec0000008070LL), MASK_RIE_R0I0, INSTR_RIE_R0I0, 2, 6, 0, "compare immediate and trap (64<16) on A equal B" },
  { "cgitnlh", OP48(0xec0000008070LL), MASK_RIE_R0I0, INSTR_RIE_R0I0, 2, 6, 0, "compare immediate and trap (64<16) on not low or high" },
  { "clgrje", OP48(0xec0000008065LL), MASK_RIE_RRP0, INSTR_RIE_RRP0, 2, 6, 112, "compare logical and branch relative (64) on A equal B" },
  { "clgrjnlh", OP48(0xec0000008065LL), MASK_RIE_RRP0, INSTR_RIE_RRP0, 2, 6, 112, "compare logical and branch relative (64) on not low or high" },
  { "cgrje", OP48(0xec0000008064LL), MASK_RIE_RRP0, INSTR_RIE_RRP0, 2, 6, 112, "compare and branch relative (64) on A equal B" },
  { "cgrjnlh", OP48(0xec0000008064LL), MASK_RIE_RRP0, INSTR_RIE_RRP0, 2, 6, 112, "compare and branch relative (64) on not low or high" },
  { "clrbne", OP48(0xec00000060f7LL), MASK_RRS_RRRD0, INSTR_RRS_RRRD0, 2, 6, 0, "compare logical and branch (32) on A not equal B" },
  { "clrblh", OP48(0xec00000060f7LL), MASK_RRS_RRRD0, INSTR_RRS_RRRD0, 2, 6, 0, "compare logical and branch (32) on low or high" },
  { "crbne", OP48(0xec00000060f6LL), MASK_RRS_RRRD0, INSTR_RRS_RRRD0, 2, 6, 0, "compare and branch (32) on A not equal B" },
  { "crblh", OP48(0xec00000060f6LL), MASK_RRS_RRRD0, INSTR_RRS_RRRD0, 2, 6, 0, "compare and branch (32) on low or high" },
  { "clgrbne", OP48(0xec00000060e5LL), MASK_RRS_RRRD0, INSTR_RRS_RRRD0, 2, 6, 0, "compare logical and branch (64) on A not equal B" },
  { "clgrblh", OP48(0xec00000060e5LL), MASK_RRS_RRRD0, INSTR_RRS_RRRD0, 2, 6, 0, "compare logical and branch (64) on low or high" },
  { "cgrbne", OP48(0xec00000060e4LL), MASK_RRS_RRRD0, INSTR_RRS_RRRD0, 2, 6, 0, "compare and branch (64) on A not equal B" },
  { "cgrblh", OP48(0xec00000060e4LL), MASK_RRS_RRRD0, INSTR_RRS_RRRD0, 2, 6, 0, "compare and branch (64) on low or high" },
  { "clrjne", OP48(0xec0000006077LL), MASK_RIE_RRP0, INSTR_RIE_RRP0, 2, 6, 112, "compare logical and branch relative (32) on A not equal B" },
  { "clrjlh", OP48(0xec0000006077LL), MASK_RIE_RRP0, INSTR_RIE_RRP0, 2, 6, 112, "compare logical and branch relative (32) on low or high" },
  { "crjne", OP48(0xec0000006076LL), MASK_RIE_RRP0, INSTR_RIE_RRP0, 2, 6, 112, "compare and branch relative (32) on A not equal B" },
  { "crjlh", OP48(0xec0000006076LL), MASK_RIE_RRP0, INSTR_RIE_RRP0, 2, 6, 112, "compare and branch relative (32) on low or high" },
  { "clfitne", OP48(0xec0000006073LL), MASK_RIE_R0U0, INSTR_RIE_R0U0, 2, 6, 0, "compare logical and trap (32<16) on A not equal B" },
  { "clfitlh", OP48(0xec0000006073LL), MASK_RIE_R0U0, INSTR_RIE_R0U0, 2, 6, 0, "compare logical and trap (32<16) on low or high" },
  { "citne", OP48(0xec0000006072LL), MASK_RIE_R0I0, INSTR_RIE_R0I0, 2, 6, 0, "compare immediate and trap (32<16) on A not equal B" },
  { "citlh", OP48(0xec0000006072LL), MASK_RIE_R0I0, INSTR_RIE_R0I0, 2, 6, 0, "compare immediate and trap (32<16) on low or high" },
  { "clgitne", OP48(0xec0000006071LL), MASK_RIE_R0U0, INSTR_RIE_R0U0, 2, 6, 0, "compare logical and trap (64<16) on A not equal B" },
  { "clgitlh", OP48(0xec0000006071LL), MASK_RIE_R0U0, INSTR_RIE_R0U0, 2, 6, 0, "compare logical and trap (64<16) on low or high" },
  { "cgitne", OP48(0xec0000006070LL), MASK_RIE_R0I0, INSTR_RIE_R0I0, 2, 6, 0, "compare immediate and trap (64<16) on A not equal B" },
  { "cgitlh", OP48(0xec0000006070LL), MASK_RIE_R0I0, INSTR_RIE_R0I0, 2, 6, 0, "compare immediate and trap (64<16) on low or high" },
  { "clgrjne", OP48(0xec0000006065LL), MASK_RIE_RRP0, INSTR_RIE_RRP0, 2, 6, 112, "compare logical and branch relative (64) on A not equal B" },
  { "clgrjlh", OP48(0xec0000006065LL), MASK_RIE_RRP0, INSTR_RIE_RRP0, 2, 6, 112, "compare logical and branch relative (64) on low or high" },
  { "cgrjne", OP48(0xec0000006064LL), MASK_RIE_RRP0, INSTR_RIE_RRP0, 2, 6, 112, "compare and branch relative (64) on A not equal B" },
  { "cgrjlh", OP48(0xec0000006064LL), MASK_RIE_RRP0, INSTR_RIE_RRP0, 2, 6, 112, "compare and branch relative (64) on low or high" },
  { "clrbl", OP48(0xec00000040f7LL), MASK_RRS_RRRD0, INSTR_RRS_RRRD0, 2, 6, 0, "compare logical and branch (32) on A low" },
  { "clrbnhe", OP48(0xec00000040f7LL), MASK_RRS_RRRD0, INSTR_RRS_RRRD0, 2, 6, 0, "compare logical and branch (32) on not high or equal" },
  { "crbl", OP48(0xec00000040f6LL), MASK_RRS_RRRD0, INSTR_RRS_RRRD0, 2, 6, 0, "compare and branch (32) on A low" },
  { "crbnhe", OP48(0xec00000040f6LL), MASK_RRS_RRRD0, INSTR_RRS_RRRD0, 2, 6, 0, "compare and branch (32) on not high or equal" },
  { "clgrbl", OP48(0xec00000040e5LL), MASK_RRS_RRRD0, INSTR_RRS_RRRD0, 2, 6, 0, "compare logical and branch (64) on A low" },
  { "clgrbnhe", OP48(0xec00000040e5LL), MASK_RRS_RRRD0, INSTR_RRS_RRRD0, 2, 6, 0, "compare logical and branch (64) on not high or equal" },
  { "cgrbl", OP48(0xec00000040e4LL), MASK_RRS_RRRD0, INSTR_RRS_RRRD0, 2, 6, 0, "compare and branch (64) on A low" },
  { "cgrbnhe", OP48(0xec00000040e4LL), MASK_RRS_RRRD0, INSTR_RRS_RRRD0, 2, 6, 0, "compare and branch (64) on not high or equal" },
  { "clrjl", OP48(0xec0000004077LL), MASK_RIE_RRP0, INSTR_RIE_RRP0, 2, 6, 112, "compare logical and branch relative (32) on A low" },
  { "clrjnhe", OP48(0xec0000004077LL), MASK_RIE_RRP0, INSTR_RIE_RRP0, 2, 6, 112, "compare logical and branch relative (32) on not high or equal" },
  { "crjl", OP48(0xec0000004076LL), MASK_RIE_RRP0, INSTR_RIE_RRP0, 2, 6, 112, "compare and branch relative (32) on A low" },
  { "crjnhe", OP48(0xec0000004076LL), MASK_RIE_RRP0, INSTR_RIE_RRP0, 2, 6, 112, "compare and branch relative (32) on not high or equal" },
  { "clfitl", OP48(0xec0000004073LL), MASK_RIE_R0U0, INSTR_RIE_R0U0, 2, 6, 0, "compare logical and trap (32<16) on A low" },
  { "clfitnhe", OP48(0xec0000004073LL), MASK_RIE_R0U0, INSTR_RIE_R0U0, 2, 6, 0, "compare logical and trap (32<16) on not high or equal" },
  { "citl", OP48(0xec0000004072LL), MASK_RIE_R0I0, INSTR_RIE_R0I0, 2, 6, 0, "compare immediate and trap (32<16) on A low" },
  { "citnhe", OP48(0xec0000004072LL), MASK_RIE_R0I0, INSTR_RIE_R0I0, 2, 6, 0, "compare immediate and trap (32<16) on not high or equal" },
  { "clgitl", OP48(0xec0000004071LL), MASK_RIE_R0U0, INSTR_RIE_R0U0, 2, 6, 0, "compare logical and trap (64<16) on A low" },
  { "clgitnhe", OP48(0xec0000004071LL), MASK_RIE_R0U0, INSTR_RIE_R0U0, 2, 6, 0, "compare logical and trap (64<16) on not high or equal" },
  { "cgitl", OP48(0xec0000004070LL), MASK_RIE_R0I0, INSTR_RIE_R0I0, 2, 6, 0, "compare immediate and trap (64<16) on A low" },
  { "cgitnhe", OP48(0xec0000004070LL), MASK_RIE_R0I0, INSTR_RIE_R0I0, 2, 6, 0, "compare immediate and trap (64<16) on not high or equal" },
  { "clgrjl", OP48(0xec0000004065LL), MASK_RIE_RRP0, INSTR_RIE_RRP0, 2, 6, 112, "compare logical and branch relative (64) on A low" },
  { "clgrjnhe", OP48(0xec0000004065LL), MASK_RIE_RRP0, INSTR_RIE_RRP0, 2, 6, 112, "compare logical and branch relative (64) on not high or equal" },
  { "cgrjl", OP48(0xec0000004064LL), MASK_RIE_RRP0, INSTR_RIE_RRP0, 2, 6, 112, "compare and branch relative (64) on A low" },
  { "cgrjnhe", OP48(0xec0000004064LL), MASK_RIE_RRP0, INSTR_RIE_RRP0, 2, 6, 112, "compare and branch relative (64) on not high or equal" },
  { "clrbh", OP48(0xec00000020f7LL), MASK_RRS_RRRD0, INSTR_RRS_RRRD0, 2, 6, 0, "compare logical and branch (32) on A high" },
  { "clrbnle", OP48(0xec00000020f7LL), MASK_RRS_RRRD0, INSTR_RRS_RRRD0, 2, 6, 0, "compare logical and branch (32) on not low or equal" },
  { "crbh", OP48(0xec00000020f6LL), MASK_RRS_RRRD0, INSTR_RRS_RRRD0, 2, 6, 0, "compare and branch (32) on A high" },
  { "crbnle", OP48(0xec00000020f6LL), MASK_RRS_RRRD0, INSTR_RRS_RRRD0, 2, 6, 0, "compare and branch (32) on not low or equal" },
  { "clgrbh", OP48(0xec00000020e5LL), MASK_RRS_RRRD0, INSTR_RRS_RRRD0, 2, 6, 0, "compare logical and branch (64) on A high" },
  { "clgrbnle", OP48(0xec00000020e5LL), MASK_RRS_RRRD0, INSTR_RRS_RRRD0, 2, 6, 0, "compare logical and branch (64) on not low or equal" },
  { "cgrbh", OP48(0xec00000020e4LL), MASK_RRS_RRRD0, INSTR_RRS_RRRD0, 2, 6, 0, "compare and branch (64) on A high" },
  { "cgrbnle", OP48(0xec00000020e4LL), MASK_RRS_RRRD0, INSTR_RRS_RRRD0, 2, 6, 0, "compare and branch (64) on not low or equal" },
  { "clrjh", OP48(0xec0000002077LL), MASK_RIE_RRP0, INSTR_RIE_RRP0, 2, 6, 112, "compare logical and branch relative (32) on A high" },
  { "clrjnle", OP48(0xec0000002077LL), MASK_RIE_RRP0, INSTR_RIE_RRP0, 2, 6, 112, "compare logical and branch relative (32) on not low or equal" },
  { "crjh", OP48(0xec0000002076LL), MASK_RIE_RRP0, INSTR_RIE_RRP0, 2, 6, 112, "compare and branch relative (32) on A high" },
  { "crjnle", OP48(0xec0000002076LL), MASK_RIE_RRP0, INSTR_RIE_RRP0, 2, 6, 112, "compare and branch relative (32) on not low or equal" },
  { "clfith", OP48(0xec0000002073LL), MASK_RIE_R0U0, INSTR_RIE_R0U0, 2, 6, 0, "compare logical and trap (32<16) on A high" },
  { "clfitnle", OP48(0xec0000002073LL), MASK_RIE_R0U0, INSTR_RIE_R0U0, 2, 6, 0, "compare logical and trap (32<16) on not low or equal" },
  { "cith", OP48(0xec0000002072LL), MASK_RIE_R0I0, INSTR_RIE_R0I0, 2, 6, 0, "compare immediate and trap (32<16) on A high" },
  { "citnle", OP48(0xec0000002072LL), MASK_RIE_R0I0, INSTR_RIE_R0I0, 2, 6, 0, "compare immediate and trap (32<16) on not low or equal" },
  { "clgith", OP48(0xec0000002071LL), MASK_RIE_R0U0, INSTR_RIE_R0U0, 2, 6, 0, "compare logical and trap (64<16) on A high" },
  { "clgitnle", OP48(0xec0000002071LL), MASK_RIE_R0U0, INSTR_RIE_R0U0, 2, 6, 0, "compare logical and trap (64<16) on not low or equal" },
  { "cgith", OP48(0xec0000002070LL), MASK_RIE_R0I0, INSTR_RIE_R0I0, 2, 6, 0, "compare immediate and trap (64<16) on A high" },
  { "cgitnle", OP48(0xec0000002070LL), MASK_RIE_R0I0, INSTR_RIE_R0I0, 2, 6, 0, "compare immediate and trap (64<16) on not low or equal" },
  { "clgrjh", OP48(0xec0000002065LL), MASK_RIE_RRP0, INSTR_RIE_RRP0, 2, 6, 112, "compare logical and branch relative (64) on A high" },
  { "clgrjnle", OP48(0xec0000002065LL), MASK_RIE_RRP0, INSTR_RIE_RRP0, 2, 6, 112, "compare logical and branch relative (64) on not low or equal" },
  { "cgrjh", OP48(0xec0000002064LL), MASK_RIE_RRP0, INSTR_RIE_RRP0, 2, 6, 112, "compare and branch relative (64) on A high" },
  { "cgrjnle", OP48(0xec0000002064LL), MASK_RIE_RRP0, INSTR_RIE_RRP0, 2, 6, 112, "compare and branch relative (64) on not low or equal" },
  { "clib", OP48(0xec00000000ffLL), MASK_RIS_RURDU, INSTR_RIS_RURDU, 2, 6, 0, "compare logical immediate and branch (32<8)" },
  { "cib", OP48(0xec00000000feLL), MASK_RIS_RURDI, INSTR_RIS_RURDI, 2, 6, 0, "compare immediate and branch (32<8)" },
  { "clgib", OP48(0xec00000000fdLL), MASK_RIS_RURDU, INSTR_RIS_RURDU, 2, 6, 0, "compare logical immediate and branch (64<8)" },
  { "cgib", OP48(0xec00000000fcLL), MASK_RIS_RURDI, INSTR_RIS_RURDI, 2, 6, 0, "compare immediate and branch (64<8)" },
  { "clrb", OP48(0xec00000000f7LL), MASK_RRS_RRRDU, INSTR_RRS_RRRDU, 2, 6, 0, "compare logical and branch (32)" },
  { "crb", OP48(0xec00000000f6LL), MASK_RRS_RRRDU, INSTR_RRS_RRRDU, 2, 6, 0, "compare and branch (32)" },
  { "clgrb", OP48(0xec00000000e5LL), MASK_RRS_RRRDU, INSTR_RRS_RRRDU, 2, 6, 0, "compare logical and branch (64)" },
  { "cgrb", OP48(0xec00000000e4LL), MASK_RRS_RRRDU, INSTR_RRS_RRRDU, 2, 6, 0, "compare and branch (64)" },
  { "alghsik", OP48(0xec00000000dbLL), MASK_RIE_RRI0, INSTR_RIE_RRI0, 2, 7, 0, "add logical immediate 3 operands 64 bit" },
  { "alhsik", OP48(0xec00000000daLL), MASK_RIE_RRI0, INSTR_RIE_RRI0, 2, 7, 0, "add logical immediate 3 operands 32 bit" },
  { "aghik", OP48(0xec00000000d9LL), MASK_RIE_RRI0, INSTR_RIE_RRI0, 2, 7, 0, "add immediate 3 operands 64 bit" },
  { "ahik", OP48(0xec00000000d8LL), MASK_RIE_RRI0, INSTR_RIE_RRI0, 2, 7, 0, "add immediate 3 operands 32 bit" },
  { "clij", OP48(0xec000000007fLL), MASK_RIE_RUPU, INSTR_RIE_RUPU, 2, 6, 112, "compare logical immediate and branch relative (32<8)" },
  { "cij", OP48(0xec000000007eLL), MASK_RIE_RUPI, INSTR_RIE_RUPI, 2, 6, 112, "compare immediate and branch relative (32<8)" },
  { "clgij", OP48(0xec000000007dLL), MASK_RIE_RUPU, INSTR_RIE_RUPU, 2, 6, 112, "compare logical immediate and branch relative (64<8)" },
  { "cgij", OP48(0xec000000007cLL), MASK_RIE_RUPI, INSTR_RIE_RUPI, 2, 6, 112, "compare immediate and branch relative (64<8)" },
  { "clrj", OP48(0xec0000000077LL), MASK_RIE_RRPU, INSTR_RIE_RRPU, 2, 6, 112, "compare logical and branch relative (32)" },
  { "crj", OP48(0xec0000000076LL), MASK_RIE_RRPU, INSTR_RIE_RRPU, 2, 6, 112, "compare and branch relative (32)" },
  { "clfit", OP48(0xec0000000073LL), MASK_RIE_R0UU, INSTR_RIE_R0UU, 2, 6, 0, "compare logical and trap (32<16)" },
  { "cit", OP48(0xec0000000072LL), MASK_RIE_R0IU, INSTR_RIE_R0IU, 2, 6, 0, "compare immediate and trap (32<16)" },
  { "clgit", OP48(0xec0000000071LL), MASK_RIE_R0UU, INSTR_RIE_R0UU, 2, 6, 0, "compare logical and trap (64<16)" },
  { "cgit", OP48(0xec0000000070LL), MASK_RIE_R0IU, INSTR_RIE_R0IU, 2, 6, 0, "compare immediate and trap (64<16)" },
  { "clgrj", OP48(0xec0000000065LL), MASK_RIE_RRPU, INSTR_RIE_RRPU, 2, 6, 112, "compare logical and branch relative (64)" },
  { "cgrj", OP48(0xec0000000064LL), MASK_RIE_RRPU, INSTR_RIE_RRPU, 2, 6, 112, "compare and branch relative (64)" },
  { "risbhg", OP48(0xec000000005dLL), MASK_RIE_RRUUU, INSTR_RIE_RRUUU, 2, 7, 1, "rotate then insert selected bits high" },
  { "risbgn", OP48(0xec0000000059LL), MASK_RIE_RRUUU, INSTR_RIE_RRUUU, 2, 8, 1, "rotate then insert selected bits nocc" },
  { "rxsbg", OP48(0xec0000000057LL), MASK_RIE_RRUUU, INSTR_RIE_RRUUU, 2, 6, 1, "rotate then exclusive or selected bits" },
  { "rosbg", OP48(0xec0000000056LL), MASK_RIE_RRUUU, INSTR_RIE_RRUUU, 2, 6, 1, "rotate then or selected bits" },
  { "risbg", OP48(0xec0000000055LL), MASK_RIE_RRUUU, INSTR_RIE_RRUUU, 2, 6, 1, "rotate then insert selected bits" },
  { "rnsbg", OP48(0xec0000000054LL), MASK_RIE_RRUUU, INSTR_RIE_RRUUU, 2, 6, 1, "rotate then and selected bits" },
  { "risblg", OP48(0xec0000000051LL), MASK_RIE_RRUUU, INSTR_RIE_RRUUU, 2, 7, 1, "rotate then insert selected bits low" },
  { "lochhi", OP48(0xec000000004eLL), MASK_RIE_RUI0, INSTR_RIE_RUI0, 2, 9, 0, "load halfword high immediate on condition" },
  { "locghi", OP48(0xec0000000046LL), MASK_RIE_RUI0, INSTR_RIE_RUI0, 2, 9, 0, "load halfword immediate on condition into 64 bit gpr" },
  { "brxlg", OP48(0xec0000000045LL), MASK_RIE_RRP, INSTR_RIE_RRP, 2, 2, 112, "branch relative on index low or equal 64" },
  { "jxleg", OP48(0xec0000000045LL), MASK_RIE_RRP, INSTR_RIE_RRP, 2, 2, 112, "branch relative on index low or equal 64" },
  { "brxhg", OP48(0xec0000000044LL), MASK_RIE_RRP, INSTR_RIE_RRP, 2, 2, 112, "branch relative on index high 64" },
  { "jxhg", OP48(0xec0000000044LL), MASK_RIE_RRP, INSTR_RIE_RRP, 2, 2, 112, "branch relative on index high 64" },
  { "lochi", OP48(0xec0000000042LL), MASK_RIE_RUI0, INSTR_RIE_RUI0, 2, 9, 0, "load halfword immediate on condition into 32 bit gpr" },
  { "stocno", OP48(0xeb0e000000f3LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 7, 0, "store on condition 32 bit on not overflow / if not ones" },
  { "locno", OP48(0xeb0e000000f2LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 7, 0, "load on condition 32 bit on not overflow / if not ones" },
  { "stocgno", OP48(0xeb0e000000e3LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 7, 0, "store on condition 64 bit on not overflow / if not ones" },
  { "locgno", OP48(0xeb0e000000e2LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 7, 0, "load on condition 64 bit on not overflow / if not ones" },
  { "stocfhno", OP48(0xeb0e000000e1LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 9, 0, "store high on condition on not overflow / if not ones" },
  { "locfhno", OP48(0xeb0e000000e0LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 9, 0, "load high on condition from memory on not overflow / if not ones" },
  { "stocnh", OP48(0xeb0d000000f3LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 7, 0, "store on condition 32 bit on A not high" },
  { "stocnp", OP48(0xeb0d000000f3LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 7, 0, "store on condition 32 bit on not plus" },
  { "locnh", OP48(0xeb0d000000f2LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 7, 0, "load on condition 32 bit on A not high" },
  { "locnp", OP48(0xeb0d000000f2LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 7, 0, "load on condition 32 bit on not plus" },
  { "stocgnh", OP48(0xeb0d000000e3LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 7, 0, "store on condition 64 bit on A not high" },
  { "stocgnp", OP48(0xeb0d000000e3LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 7, 0, "store on condition 64 bit on not plus" },
  { "locgnh", OP48(0xeb0d000000e2LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 7, 0, "load on condition 64 bit on A not high" },
  { "locgnp", OP48(0xeb0d000000e2LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 7, 0, "load on condition 64 bit on not plus" },
  { "stocfhnh", OP48(0xeb0d000000e1LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 9, 0, "store high on condition on A not high" },
  { "stocfhnp", OP48(0xeb0d000000e1LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 9, 0, "store high on condition on not plus" },
  { "locfhnh", OP48(0xeb0d000000e0LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 9, 0, "load high on condition from memory on A not high" },
  { "locfhnp", OP48(0xeb0d000000e0LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 9, 0, "load high on condition from memory on not plus" },
  { "stocle", OP48(0xeb0c000000f3LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 7, 0, "store on condition 32 bit on low or equal" },
  { "locle", OP48(0xeb0c000000f2LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 7, 0, "load on condition 32 bit on low or equal" },
  { "stocgle", OP48(0xeb0c000000e3LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 7, 0, "store on condition 64 bit on low or equal" },
  { "locgle", OP48(0xeb0c000000e2LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 7, 0, "load on condition 64 bit on low or equal" },
  { "stocfhle", OP48(0xeb0c000000e1LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 9, 0, "store high on condition on low or equal" },
  { "locfhle", OP48(0xeb0c000000e0LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 9, 0, "load high on condition from memory on low or equal" },
  { "clgtnh", OP48(0xeb0c0000002bLL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 8, 0, "compare logical and trap 64 bit reg-mem on A not high" },
  { "clgtle", OP48(0xeb0c0000002bLL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 8, 0, "compare logical and trap 64 bit reg-mem on low or equal" },
  { "cltnh", OP48(0xeb0c00000023LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 8, 0, "compare logical and trap 32 bit reg-mem on A not high" },
  { "cltle", OP48(0xeb0c00000023LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 8, 0, "compare logical and trap 32 bit reg-mem on low or equal" },
  { "stocnl", OP48(0xeb0b000000f3LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 7, 0, "store on condition 32 bit on A not low" },
  { "stocnm", OP48(0xeb0b000000f3LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 7, 0, "store on condition 32 bit on not minus / if not mixed" },
  { "locnl", OP48(0xeb0b000000f2LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 7, 0, "load on condition 32 bit on A not low" },
  { "locnm", OP48(0xeb0b000000f2LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 7, 0, "load on condition 32 bit on not minus / if not mixed" },
  { "stocgnl", OP48(0xeb0b000000e3LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 7, 0, "store on condition 64 bit on A not low" },
  { "stocgnm", OP48(0xeb0b000000e3LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 7, 0, "store on condition 64 bit on not minus / if not mixed" },
  { "locgnl", OP48(0xeb0b000000e2LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 7, 0, "load on condition 64 bit on A not low" },
  { "locgnm", OP48(0xeb0b000000e2LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 7, 0, "load on condition 64 bit on not minus / if not mixed" },
  { "stocfhnl", OP48(0xeb0b000000e1LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 9, 0, "store high on condition on A not low" },
  { "stocfhnm", OP48(0xeb0b000000e1LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 9, 0, "store high on condition on not minus / if not mixed" },
  { "locfhnl", OP48(0xeb0b000000e0LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 9, 0, "load high on condition from memory on A not low" },
  { "locfhnm", OP48(0xeb0b000000e0LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 9, 0, "load high on condition from memory on not minus / if not mixed" },
  { "stoche", OP48(0xeb0a000000f3LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 7, 0, "store on condition 32 bit on high or equal" },
  { "loche", OP48(0xeb0a000000f2LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 7, 0, "load on condition 32 bit on high or equal" },
  { "stocghe", OP48(0xeb0a000000e3LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 7, 0, "store on condition 64 bit on high or equal" },
  { "locghe", OP48(0xeb0a000000e2LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 7, 0, "load on condition 64 bit on high or equal" },
  { "stocfhhe", OP48(0xeb0a000000e1LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 9, 0, "store high on condition on high or equal" },
  { "locfhhe", OP48(0xeb0a000000e0LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 9, 0, "load high on condition from memory on high or equal" },
  { "clgtnl", OP48(0xeb0a0000002bLL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 8, 0, "compare logical and trap 64 bit reg-mem on A not low" },
  { "clgthe", OP48(0xeb0a0000002bLL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 8, 0, "compare logical and trap 64 bit reg-mem on high or equal" },
  { "cltnl", OP48(0xeb0a00000023LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 8, 0, "compare logical and trap 32 bit reg-mem on A not low" },
  { "clthe", OP48(0xeb0a00000023LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 8, 0, "compare logical and trap 32 bit reg-mem on high or equal" },
  { "stocnlh", OP48(0xeb09000000f3LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 7, 0, "store on condition 32 bit on not low or high" },
  { "locnlh", OP48(0xeb09000000f2LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 7, 0, "load on condition 32 bit on not low or high" },
  { "stocgnlh", OP48(0xeb09000000e3LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 7, 0, "store on condition 64 bit on not low or high" },
  { "locgnlh", OP48(0xeb09000000e2LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 7, 0, "load on condition 64 bit on not low or high" },
  { "stocfhnlh", OP48(0xeb09000000e1LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 9, 0, "store high on condition on not low or high" },
  { "locfhnlh", OP48(0xeb09000000e0LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 9, 0, "load high on condition from memory on not low or high" },
  { "stoce", OP48(0xeb08000000f3LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 7, 0, "store on condition 32 bit on A equal B" },
  { "stocz", OP48(0xeb08000000f3LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 7, 0, "store on condition 32 bit on zero / if zeros" },
  { "loce", OP48(0xeb08000000f2LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 7, 0, "load on condition 32 bit on A equal B" },
  { "locz", OP48(0xeb08000000f2LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 7, 0, "load on condition 32 bit on zero / if zeros" },
  { "stocge", OP48(0xeb08000000e3LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 7, 0, "store on condition 64 bit on A equal B" },
  { "stocgz", OP48(0xeb08000000e3LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 7, 0, "store on condition 64 bit on zero / if zeros" },
  { "locge", OP48(0xeb08000000e2LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 7, 0, "load on condition 64 bit on A equal B" },
  { "locgz", OP48(0xeb08000000e2LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 7, 0, "load on condition 64 bit on zero / if zeros" },
  { "stocfhe", OP48(0xeb08000000e1LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 9, 0, "store high on condition on A equal B" },
  { "stocfhz", OP48(0xeb08000000e1LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 9, 0, "store high on condition on zero / if zeros" },
  { "locfhe", OP48(0xeb08000000e0LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 9, 0, "load high on condition from memory on A equal B" },
  { "locfhz", OP48(0xeb08000000e0LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 9, 0, "load high on condition from memory on zero / if zeros" },
  { "clgte", OP48(0xeb080000002bLL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 8, 0, "compare logical and trap 64 bit reg-mem on A equal B" },
  { "clgtnlh", OP48(0xeb080000002bLL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 8, 0, "compare logical and trap 64 bit reg-mem on not low or high" },
  { "clte", OP48(0xeb0800000023LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 8, 0, "compare logical and trap 32 bit reg-mem on A equal B" },
  { "cltnlh", OP48(0xeb0800000023LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 8, 0, "compare logical and trap 32 bit reg-mem on not low or high" },
  { "stocne", OP48(0xeb07000000f3LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 7, 0, "store on condition 32 bit on A not equal B" },
  { "stocnz", OP48(0xeb07000000f3LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 7, 0, "store on condition 32 bit on not zero / if not zeros" },
  { "locne", OP48(0xeb07000000f2LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 7, 0, "load on condition 32 bit on A not equal B" },
  { "locnz", OP48(0xeb07000000f2LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 7, 0, "load on condition 32 bit on not zero / if not zeros" },
  { "stocgne", OP48(0xeb07000000e3LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 7, 0, "store on condition 64 bit on A not equal B" },
  { "stocgnz", OP48(0xeb07000000e3LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 7, 0, "store on condition 64 bit on not zero / if not zeros" },
  { "locgne", OP48(0xeb07000000e2LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 7, 0, "load on condition 64 bit on A not equal B" },
  { "locgnz", OP48(0xeb07000000e2LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 7, 0, "load on condition 64 bit on not zero / if not zeros" },
  { "stocfhne", OP48(0xeb07000000e1LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 9, 0, "store high on condition on A not equal B" },
  { "stocfhnz", OP48(0xeb07000000e1LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 9, 0, "store high on condition on not zero / if not zeros" },
  { "locfhne", OP48(0xeb07000000e0LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 9, 0, "load high on condition from memory on A not equal B" },
  { "locfhnz", OP48(0xeb07000000e0LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 9, 0, "load high on condition from memory on not zero / if not zeros" },
  { "stoclh", OP48(0xeb06000000f3LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 7, 0, "store on condition 32 bit on low or high" },
  { "loclh", OP48(0xeb06000000f2LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 7, 0, "load on condition 32 bit on low or high" },
  { "stocglh", OP48(0xeb06000000e3LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 7, 0, "store on condition 64 bit on low or high" },
  { "locglh", OP48(0xeb06000000e2LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 7, 0, "load on condition 64 bit on low or high" },
  { "stocfhlh", OP48(0xeb06000000e1LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 9, 0, "store high on condition on low or high" },
  { "locfhlh", OP48(0xeb06000000e0LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 9, 0, "load high on condition from memory on low or high" },
  { "clgtne", OP48(0xeb060000002bLL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 8, 0, "compare logical and trap 64 bit reg-mem on A not equal B" },
  { "clgtlh", OP48(0xeb060000002bLL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 8, 0, "compare logical and trap 64 bit reg-mem on low or high" },
  { "cltne", OP48(0xeb0600000023LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 8, 0, "compare logical and trap 32 bit reg-mem on A not equal B" },
  { "cltlh", OP48(0xeb0600000023LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 8, 0, "compare logical and trap 32 bit reg-mem on low or high" },
  { "stocnhe", OP48(0xeb05000000f3LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 7, 0, "store on condition 32 bit on not high or equal" },
  { "locnhe", OP48(0xeb05000000f2LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 7, 0, "load on condition 32 bit on not high or equal" },
  { "stocgnhe", OP48(0xeb05000000e3LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 7, 0, "store on condition 64 bit on not high or equal" },
  { "locgnhe", OP48(0xeb05000000e2LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 7, 0, "load on condition 64 bit on not high or equal" },
  { "stocfhnhe", OP48(0xeb05000000e1LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 9, 0, "store high on condition on not high or equal" },
  { "locfhnhe", OP48(0xeb05000000e0LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 9, 0, "load high on condition from memory on not high or equal" },
  { "stocl", OP48(0xeb04000000f3LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 7, 0, "store on condition 32 bit on A low" },
  { "stocm", OP48(0xeb04000000f3LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 7, 0, "store on condition 32 bit on minus / if mixed" },
  { "locl", OP48(0xeb04000000f2LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 7, 0, "load on condition 32 bit on A low" },
  { "locm", OP48(0xeb04000000f2LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 7, 0, "load on condition 32 bit on minus / if mixed" },
  { "stocgl", OP48(0xeb04000000e3LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 7, 0, "store on condition 64 bit on A low" },
  { "stocgm", OP48(0xeb04000000e3LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 7, 0, "store on condition 64 bit on minus / if mixed" },
  { "locgl", OP48(0xeb04000000e2LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 7, 0, "load on condition 64 bit on A low" },
  { "locgm", OP48(0xeb04000000e2LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 7, 0, "load on condition 64 bit on minus / if mixed" },
  { "stocfhl", OP48(0xeb04000000e1LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 9, 0, "store high on condition on A low" },
  { "stocfhm", OP48(0xeb04000000e1LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 9, 0, "store high on condition on minus / if mixed" },
  { "locfhl", OP48(0xeb04000000e0LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 9, 0, "load high on condition from memory on A low" },
  { "locfhm", OP48(0xeb04000000e0LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 9, 0, "load high on condition from memory on minus / if mixed" },
  { "clgtl", OP48(0xeb040000002bLL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 8, 0, "compare logical and trap 64 bit reg-mem on A low" },
  { "clgtnhe", OP48(0xeb040000002bLL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 8, 0, "compare logical and trap 64 bit reg-mem on not high or equal" },
  { "cltl", OP48(0xeb0400000023LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 8, 0, "compare logical and trap 32 bit reg-mem on A low" },
  { "cltnhe", OP48(0xeb0400000023LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 8, 0, "compare logical and trap 32 bit reg-mem on not high or equal" },
  { "stocnle", OP48(0xeb03000000f3LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 7, 0, "store on condition 32 bit on not low or equal" },
  { "locnle", OP48(0xeb03000000f2LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 7, 0, "load on condition 32 bit on not low or equal" },
  { "stocgnle", OP48(0xeb03000000e3LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 7, 0, "store on condition 64 bit on not low or equal" },
  { "locgnle", OP48(0xeb03000000e2LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 7, 0, "load on condition 64 bit on not low or equal" },
  { "stocfhnle", OP48(0xeb03000000e1LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 9, 0, "store high on condition on not low or equal" },
  { "locfhnle", OP48(0xeb03000000e0LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 9, 0, "load high on condition from memory on not low or equal" },
  { "stoch", OP48(0xeb02000000f3LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 7, 0, "store on condition 32 bit on A high" },
  { "stocp", OP48(0xeb02000000f3LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 7, 0, "store on condition 32 bit on plus" },
  { "loch", OP48(0xeb02000000f2LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 7, 0, "load on condition 32 bit on A high" },
  { "locp", OP48(0xeb02000000f2LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 7, 0, "load on condition 32 bit on plus" },
  { "stocgh", OP48(0xeb02000000e3LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 7, 0, "store on condition 64 bit on A high" },
  { "stocgp", OP48(0xeb02000000e3LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 7, 0, "store on condition 64 bit on plus" },
  { "locgh", OP48(0xeb02000000e2LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 7, 0, "load on condition 64 bit on A high" },
  { "locgp", OP48(0xeb02000000e2LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 7, 0, "load on condition 64 bit on plus" },
  { "stocfhh", OP48(0xeb02000000e1LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 9, 0, "store high on condition on A high" },
  { "stocfhp", OP48(0xeb02000000e1LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 9, 0, "store high on condition on plus" },
  { "locfhh", OP48(0xeb02000000e0LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 9, 0, "load high on condition from memory on A high" },
  { "locfhp", OP48(0xeb02000000e0LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 9, 0, "load high on condition from memory on plus" },
  { "clgth", OP48(0xeb020000002bLL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 8, 0, "compare logical and trap 64 bit reg-mem on A high" },
  { "clgtnle", OP48(0xeb020000002bLL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 8, 0, "compare logical and trap 64 bit reg-mem on not low or equal" },
  { "clth", OP48(0xeb0200000023LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 8, 0, "compare logical and trap 32 bit reg-mem on A high" },
  { "cltnle", OP48(0xeb0200000023LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 8, 0, "compare logical and trap 32 bit reg-mem on not low or equal" },
  { "stoco", OP48(0xeb01000000f3LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 7, 0, "store on condition 32 bit on overflow / if ones" },
  { "loco", OP48(0xeb01000000f2LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 7, 0, "load on condition 32 bit on overflow / if ones" },
  { "stocgo", OP48(0xeb01000000e3LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 7, 0, "store on condition 64 bit on overflow / if ones" },
  { "locgo", OP48(0xeb01000000e2LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 7, 0, "load on condition 64 bit on overflow / if ones" },
  { "stocfho", OP48(0xeb01000000e1LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 9, 0, "store high on condition on overflow / if ones" },
  { "locfho", OP48(0xeb01000000e0LL), MASK_RSY_R0RD, INSTR_RSY_R0RD, 2, 9, 0, "load high on condition from memory on overflow / if ones" },
  { "laal", OP48(0xeb00000000faLL), MASK_RSY_RRRD, INSTR_RSY_RRRD, 2, 7, 0, "load and add logical 32 bit" },
  { "laa", OP48(0xeb00000000f8LL), MASK_RSY_RRRD, INSTR_RSY_RRRD, 2, 7, 0, "load and add 32 bit" },
  { "lax", OP48(0xeb00000000f7LL), MASK_RSY_RRRD, INSTR_RSY_RRRD, 2, 7, 0, "load and exclusive or 32 bit" },
  { "lao", OP48(0xeb00000000f6LL), MASK_RSY_RRRD, INSTR_RSY_RRRD, 2, 7, 0, "load and or 32 bit" },
  { "lan", OP48(0xeb00000000f4LL), MASK_RSY_RRRD, INSTR_RSY_RRRD, 2, 7, 0, "load and and 32 bit" },
  { "stoc", OP48(0xeb00000000f3LL), MASK_RSY_RURD2, INSTR_RSY_RURD2, 2, 7, 0, "store on condition 32 bit" },
  { "loc", OP48(0xeb00000000f2LL), MASK_RSY_RURD2, INSTR_RSY_RURD2, 2, 7, 0, "load on condition 32 bit" },
  { "laalg", OP48(0xeb00000000eaLL), MASK_RSY_RRRD, INSTR_RSY_RRRD, 2, 7, 0, "load and add logical 64 bit" },
  { "laag", OP48(0xeb00000000e8LL), MASK_RSY_RRRD, INSTR_RSY_RRRD, 2, 7, 0, "load and add 64 bit" },
  { "laxg", OP48(0xeb00000000e7LL), MASK_RSY_RRRD, INSTR_RSY_RRRD, 2, 7, 0, "load and exclusive or 64 bit" },
  { "laog", OP48(0xeb00000000e6LL), MASK_RSY_RRRD, INSTR_RSY_RRRD, 2, 7, 0, "load and or 64 bit" },
  { "lang", OP48(0xeb00000000e4LL), MASK_RSY_RRRD, INSTR_RSY_RRRD, 2, 7, 0, "load and and 64 bit" },
  { "stocg", OP48(0xeb00000000e3LL), MASK_RSY_RURD2, INSTR_RSY_RURD2, 2, 7, 0, "store on condition 64 bit" },
  { "locg", OP48(0xeb00000000e2LL), MASK_RSY_RURD2, INSTR_RSY_RURD2, 2, 7, 0, "load on condition 64 bit" },
  { "stocfh", OP48(0xeb00000000e1LL), MASK_RSY_RURD2, INSTR_RSY_RURD2, 2, 9, 0, "store high on condition" },
  { "locfh", OP48(0xeb00000000e0LL), MASK_RSY_RURD2, INSTR_RSY_RURD2, 2, 9, 0, "load high on condition from memory" },
  { "sllk", OP48(0xeb00000000dfLL), MASK_RSY_RRRD, INSTR_RSY_RRRD, 2, 7, 0, "shift left single logical 3 operands 32 bit" },
  { "srlk", OP48(0xeb00000000deLL), MASK_RSY_RRRD, INSTR_RSY_RRRD, 2, 7, 0, "shift right single logical 3 operands 32 bit" },
  { "slak", OP48(0xeb00000000ddLL), MASK_RSY_RRRD, INSTR_RSY_RRRD, 2, 7, 0, "shift left single 3 operands 32 bit" },
  { "srak", OP48(0xeb00000000dcLL), MASK_RSY_RRRD, INSTR_RSY_RRRD, 2, 7, 0, "shift right single 3 operands 32 bit" },
  { "tp", OP48(0xeb00000000c0LL), MASK_RSL_R0RD, INSTR_RSL_R0RD, 3, 0, 0, "test decimal" },
  { "stamy", OP48(0xeb000000009bLL), MASK_RSY_AARD, INSTR_RSY_AARD, 2, 3, 0, "store access multiple with long offset" },
  { "lamy", OP48(0xeb000000009aLL), MASK_RSY_AARD, INSTR_RSY_AARD, 2, 3, 0, "load access multiple" },
  { "lmy", OP48(0xeb0000000098LL), MASK_RSY_RRRD, INSTR_RSY_RRRD, 2, 3, 0, "load multiple with long offset" },
  { "lmh", OP48(0xeb0000000096LL), MASK_RSY_RRRD, INSTR_RSY_RRRD, 2, 3, 0, "load multiple high" },
  { "lmh", OP48(0xeb0000000096LL), MASK_RSE_RRRD, INSTR_RSE_RRRD, 2, 2, 0, "load multiple high" },
  { "stmy", OP48(0xeb0000000090LL), MASK_RSY_RRRD, INSTR_RSY_RRRD, 2, 3, 0, "store multiple with long offset" },
  { "clclu", OP48(0xeb000000008fLL), MASK_RSY_RRRD, INSTR_RSY_RRRD, 3, 3, 0, "compare logical long unicode with long offset" },
  { "mvclu", OP48(0xeb000000008eLL), MASK_RSY_RERERD, INSTR_RSY_RERERD, 3, 3, 0, "move long unicode" },
  { "mvclu", OP48(0xeb000000008eLL), MASK_RSE_RERERD, INSTR_RSE_RERERD, 3, 0, 0, "move long unicode" },
  { "icmy", OP48(0xeb0000000081LL), MASK_RSY_RURD, INSTR_RSY_RURD, 2, 3, 0, "insert characters with long offset" },
  { "icmh", OP48(0xeb0000000080LL), MASK_RSY_RURD, INSTR_RSY_RURD, 2, 3, 0, "insert characters under mask high with long offset" },
  { "icmh", OP48(0xeb0000000080LL), MASK_RSE_RURD, INSTR_RSE_RURD, 2, 2, 0, "insert characters under mask high" },
  { "algsi", OP48(0xeb000000007eLL), MASK_SIY_IRD, INSTR_SIY_IRD, 2, 6, 0, "add logical with signed immediate (64<8)" },
  { "agsi", OP48(0xeb000000007aLL), MASK_SIY_IRD, INSTR_SIY_IRD, 2, 6, 0, "add immediate (64<8)" },
  { "lpswey", OP48(0xeb0000000071LL), MASK_SIY_RD, INSTR_SIY_RD, 2, 12, 0, "load PSW extended" },
  { "alsi", OP48(0xeb000000006eLL), MASK_SIY_IRD, INSTR_SIY_IRD, 2, 6, 0, "add logical with signed immediate (32<8)" },
  { "asi", OP48(0xeb000000006aLL), MASK_SIY_IRD, INSTR_SIY_IRD, 2, 6, 0, "add immediate (32<8)" },
  { "xiy", OP48(0xeb0000000057LL), MASK_SIY_URD, INSTR_SIY_URD, 2, 3, 0, "exclusive or immediate with long offset" },
  { "oiy", OP48(0xeb0000000056LL), MASK_SIY_URD, INSTR_SIY_URD, 2, 3, 0, "or immediate with long offset" },
  { "cliy", OP48(0xeb0000000055LL), MASK_SIY_URD, INSTR_SIY_URD, 2, 3, 0, "compare logical immediate with long offset" },
  { "niy", OP48(0xeb0000000054LL), MASK_SIY_URD, INSTR_SIY_URD, 2, 3, 0, "and immediate with long offset" },
  { "mviy", OP48(0xeb0000000052LL), MASK_SIY_URD, INSTR_SIY_URD, 2, 3, 0, "move immediate with long offset" },
  { "tmy", OP48(0xeb0000000051LL), MASK_SIY_URD, INSTR_SIY_URD, 2, 3, 0, "test under mask with long offset" },
  { "ecag", OP48(0xeb000000004cLL), MASK_RSY_RRRD, INSTR_RSY_RRRD, 2, 6, 0, "extract cache attribute" },
  { "bxleg", OP48(0xeb0000000045LL), MASK_RSY_RRRD, INSTR_RSY_RRRD, 2, 3, 0, "branch on index low or equal 64" },
  { "bxleg", OP48(0xeb0000000045LL), MASK_RSE_RRRD, INSTR_RSE_RRRD, 2, 2, 0, "branch on index low or equal 64" },
  { "bxhg", OP48(0xeb0000000044LL), MASK_RSY_RRRD, INSTR_RSY_RRRD, 2, 3, 0, "branch on index high 64" },
  { "bxhg", OP48(0xeb0000000044LL), MASK_RSE_RRRD, INSTR_RSE_RRRD, 2, 2, 0, "branch on index high 64" },
  { "cdsg", OP48(0xeb000000003eLL), MASK_RSY_RERERD, INSTR_RSY_RERERD, 2, 3, 0, "compare double and swap with long offset 64" },
  { "cdsg", OP48(0xeb000000003eLL), MASK_RSE_RERERD, INSTR_RSE_RERERD, 2, 2, 0, "compare double and swap 64" },
  { "cdsy", OP48(0xeb0000000031LL), MASK_RSY_RERERD, INSTR_RSY_RERERD, 2, 3, 0, "compare double and swap with long offset" },
  { "csg", OP48(0xeb0000000030LL), MASK_RSY_RRRD, INSTR_RSY_RRRD, 2, 3, 0, "compare and swap with long offset 64" },
  { "csg", OP48(0xeb0000000030LL), MASK_RSE_RRRD, INSTR_RSE_RRRD, 2, 2, 0, "compare and swap 64" },
  { "lctlg", OP48(0xeb000000002fLL), MASK_RSY_CCRD, INSTR_RSY_CCRD, 2, 3, 0, "load control 64" },
  { "lctlg", OP48(0xeb000000002fLL), MASK_RSE_CCRD, INSTR_RSE_CCRD, 2, 2, 0, "load control 64" },
  { "stcmy", OP48(0xeb000000002dLL), MASK_RSY_RURD, INSTR_RSY_RURD, 2, 3, 0, "store characters under mask with long offset" },
  { "stcmh", OP48(0xeb000000002cLL), MASK_RSY_RURD, INSTR_RSY_RURD, 2, 3, 0, "store characters under mask high with long offset" },
  { "stcmh", OP48(0xeb000000002cLL), MASK_RSE_RURD, INSTR_RSE_RURD, 2, 2, 0, "store characters under mask high" },
  { "clgt", OP48(0xeb000000002bLL), MASK_RSY_RURD, INSTR_RSY_RURD, 2, 8, 0, "compare logical and trap 64 bit reg-mem" },
  { "stmh", OP48(0xeb0000000026LL), MASK_RSY_RRRD, INSTR_RSY_RRRD, 2, 3, 0, "store multiple high" },
  { "stmh", OP48(0xeb0000000026LL), MASK_RSE_RRRD, INSTR_RSE_RRRD, 2, 2, 0, "store multiple high" },
  { "stctg", OP48(0xeb0000000025LL), MASK_RSY_CCRD, INSTR_RSY_CCRD, 2, 3, 0, "store control 64" },
  { "stctg", OP48(0xeb0000000025LL), MASK_RSE_CCRD, INSTR_RSE_CCRD, 2, 2, 0, "store control 64" },
  { "stmg", OP48(0xeb0000000024LL), MASK_RSY_RRRD, INSTR_RSY_RRRD, 2, 3, 0, "store multiple with long offset 64" },
  { "stmg", OP48(0xeb0000000024LL), MASK_RSE_RRRD, INSTR_RSE_RRRD, 2, 2, 0, "store multiple 64" },
  { "clt", OP48(0xeb0000000023LL), MASK_RSY_RURD, INSTR_RSY_RURD, 2, 8, 0, "compare logical and trap 32 bit reg-mem" },
  { "clmy", OP48(0xeb0000000021LL), MASK_RSY_RURD, INSTR_RSY_RURD, 2, 3, 0, "compare logical characters under mask with long offset" },
  { "clmh", OP48(0xeb0000000020LL), MASK_RSY_RURD, INSTR_RSY_RURD, 2, 3, 0, "compare logical characters under mask high with long offset" },
  { "clmh", OP48(0xeb0000000020LL), MASK_RSE_RURD, INSTR_RSE_RURD, 2, 2, 0, "compare logical characters under mask high" },
  { "rll", OP48(0xeb000000001dLL), MASK_RSY_RRRD, INSTR_RSY_RRRD, 3, 3, 0, "rotate left single logical 32" },
  { "rll", OP48(0xeb000000001dLL), MASK_RSE_RRRD, INSTR_RSE_RRRD, 3, 2, 0, "rotate left single logical 32" },
  { "rllg", OP48(0xeb000000001cLL), MASK_RSY_RRRD, INSTR_RSY_RRRD, 2, 3, 0, "rotate left single logical 64" },
  { "rllg", OP48(0xeb000000001cLL), MASK_RSE_RRRD, INSTR_RSE_RRRD, 2, 2, 0, "rotate left single logical 64" },
  { "pfcr", OP48(0xeb0000000016LL), MASK_RSY_RRRD, INSTR_RSY_RRRD, 2, 13, 0, "perform functions with concurrent results" },
  { "csy", OP48(0xeb0000000014LL), MASK_RSY_RRRD, INSTR_RSY_RRRD, 2, 3, 0, "compare and swap with long offset" },
  { "tracg", OP48(0xeb000000000fLL), MASK_RSY_RRRD, INSTR_RSY_RRRD, 2, 3, 0, "trace 64" },
  { "tracg", OP48(0xeb000000000fLL), MASK_RSE_RRRD, INSTR_RSE_RRRD, 2, 2, 0, "trace 64" },
  { "sllg", OP48(0xeb000000000dLL), MASK_RSY_RRRD, INSTR_RSY_RRRD, 2, 3, 0, "shift left single logical 64" },
  { "sllg", OP48(0xeb000000000dLL), MASK_RSE_RRRD, INSTR_RSE_RRRD, 2, 2, 0, "shift left single logical 64" },
  { "srlg", OP48(0xeb000000000cLL), MASK_RSY_RRRD, INSTR_RSY_RRRD, 2, 3, 0, "shift right single logical 64" },
  { "srlg", OP48(0xeb000000000cLL), MASK_RSE_RRRD, INSTR_RSE_RRRD, 2, 2, 0, "shift right single logical 64" },
  { "slag", OP48(0xeb000000000bLL), MASK_RSY_RRRD, INSTR_RSY_RRRD, 2, 3, 0, "shift left single 64" },
  { "slag", OP48(0xeb000000000bLL), MASK_RSE_RRRD, INSTR_RSE_RRRD, 2, 2, 0, "shift left single 64" },
  { "srag", OP48(0xeb000000000aLL), MASK_RSY_RRRD, INSTR_RSY_RRRD, 2, 3, 0, "shift right single 64" },
  { "srag", OP48(0xeb000000000aLL), MASK_RSE_RRRD, INSTR_RSE_RRRD, 2, 2, 0, "shift right single 64" },
  { "lmg", OP48(0xeb0000000004LL), MASK_RSY_RRRD, INSTR_RSY_RRRD, 2, 3, 0, "load multiple with long offset 64" },
  { "lmg", OP48(0xeb0000000004LL), MASK_RSE_RRRD, INSTR_RSE_RRRD, 2, 2, 0, "load multiple 64" },
  { "unpka", OP8(0xeaLL), MASK_SS_L0RDRD, INSTR_SS_L0RDRD, 3, 0, 0, "unpack ascii" },
  { "pka", OP8(0xe9LL), MASK_SS_L2RDRD, INSTR_SS_L2RDRD, 3, 0, 0, "pack ascii" },
  { "mvcin", OP8(0xe8LL), MASK_SS_L0RDRD, INSTR_SS_L0RDRD, 3, 0, 0, "move inverse" },
  { "vone", OP48(0xe700ffff0044LL), MASK_VRI_V, INSTR_VRI_V, 2, 9, 8, "vector set to ones" },
  { "wfnmaxb", OP48(0xe7000408009fLL), MASK_VRR_VVVV, INSTR_VRR_VVVV, 2, 10, 0, "scalar vector fp negative multiply and add scalar extended" },
  { "wfnmsxb", OP48(0xe7000408009eLL), MASK_VRR_VVVV, INSTR_VRR_VVVV, 2, 10, 0, "scalar vector fp negative multiply and subtract scalar extended" },
  { "wfmaxb", OP48(0xe7000408008fLL), MASK_VRR_VVVV, INSTR_VRR_VVVV, 2, 10, 0, "scalar vector fp multiply and add scalar extended" },
  { "wfmsxb", OP48(0xe7000408008eLL), MASK_VRR_VVVV, INSTR_VRR_VVVV, 2, 10, 0, "scalar vector fp multiply and subtract scalar extended" },
  { "vsbiq", OP48(0xe700040000bfLL), MASK_VRR_VVV0V, INSTR_VRR_VVV0V, 2, 9, 8, "vector subtract with borrow indication quadword" },
  { "vsbcbiq", OP48(0xe700040000bdLL), MASK_VRR_VVV0V, INSTR_VRR_VVV0V, 2, 9, 8, "vector subtract with borrow compute borrow indication quadword" },
  { "vacq", OP48(0xe700040000bbLL), MASK_VRR_VVV0V, INSTR_VRR_VVV0V, 2, 9, 8, "vector add with carry quadword" },
  { "vacccq", OP48(0xe700040000b9LL), MASK_VRR_VVV0V, INSTR_VRR_VVV0V, 2, 9, 8, "vector add with carry compute carry quadword" },
  { "vmahq", OP48(0xe700040000abLL), MASK_VRR_VVV0V, INSTR_VRR_VVV0V, 2, 13, 0, "vector multiply and add high quadword" },
  { "vmalq", OP48(0xe700040000aaLL), MASK_VRR_VVV0V, INSTR_VRR_VVV0V, 2, 13, 0, "vector multiply and add low quadword" },
  { "vmalhq", OP48(0xe700040000a9LL), MASK_VRR_VVV0V, INSTR_VRR_VVV0V, 2, 13, 0, "vector multiply and add logical high quadword" },
  { "vblendq", OP48(0xe70004000089LL), MASK_VRR_VVV0V, INSTR_VRR_VVV0V, 2, 13, 0, "vector blend quadword" },
  { "wfnmadb", OP48(0xe7000308009fLL), MASK_VRR_VVVV, INSTR_VRR_VVVV, 2, 10, 0, "scalar vector fp negative multiply and add scalar long" },
  { "wfnmsdb", OP48(0xe7000308009eLL), MASK_VRR_VVVV, INSTR_VRR_VVVV, 2, 10, 0, "scalar vector fp negative multiply and subtract scalar long" },
  { "wfmadb", OP48(0xe7000308008fLL), MASK_VRR_VVVV, INSTR_VRR_VVVV, 2, 9, 8, "vector fp multiply and add long" },
  { "wfmsdb", OP48(0xe7000308008eLL), MASK_VRR_VVVV, INSTR_VRR_VVVV, 2, 9, 8, "vector fp multiply and subtract long" },
  { "vgfmag", OP48(0xe700030000bcLL), MASK_VRR_VVV0V, INSTR_VRR_VVV0V, 2, 9, 8, "vector galois field multiply sum and accumulate doubleword" },
  { "vmslg", OP48(0xe700030000b8LL), MASK_VRR_VVVU0VB, INSTR_VRR_VVVU0VB, 2, 10, 0, "vector multiply sum logical double word" },
  { "vmaog", OP48(0xe700030000afLL), MASK_VRR_VVV0V, INSTR_VRR_VVV0V, 2, 13, 0, "vector multiply and add odd doubleword" },
  { "vmaeg", OP48(0xe700030000aeLL), MASK_VRR_VVV0V, INSTR_VRR_VVV0V, 2, 13, 0, "vector multiply and add even doubleword" },
  { "vmalog", OP48(0xe700030000adLL), MASK_VRR_VVV0V, INSTR_VRR_VVV0V, 2, 13, 0, "vector multiply and add logical odd doubleword" },
  { "vmaleg", OP48(0xe700030000acLL), MASK_VRR_VVV0V, INSTR_VRR_VVV0V, 2, 13, 0, "vector multiply and add logical even doubleword" },
  { "vmahg", OP48(0xe700030000abLL), MASK_VRR_VVV0V, INSTR_VRR_VVV0V, 2, 13, 0, "vector multiply and add high doubleword" },
  { "vmalg", OP48(0xe700030000aaLL), MASK_VRR_VVV0V, INSTR_VRR_VVV0V, 2, 13, 0, "vector multiply and add low doubleword" },
  { "vmalhg", OP48(0xe700030000a9LL), MASK_VRR_VVV0V, INSTR_VRR_VVV0V, 2, 13, 0, "vector multiply and add logical high doubleword" },
  { "vfnmadb", OP48(0xe7000300009fLL), MASK_VRR_VVVV, INSTR_VRR_VVVV, 2, 10, 0, "vector fp negative multiply and add long" },
  { "vfnmsdb", OP48(0xe7000300009eLL), MASK_VRR_VVVV, INSTR_VRR_VVVV, 2, 10, 0, "vector fp negative multiply and subtract long" },
  { "vfmadb", OP48(0xe7000300008fLL), MASK_VRR_VVVV, INSTR_VRR_VVVV, 2, 9, 8, "vector fp multiply and add long" },
  { "vfmsdb", OP48(0xe7000300008eLL), MASK_VRR_VVVV, INSTR_VRR_VVVV, 2, 9, 8, "vector fp multiply and subtract long" },
  { "vblendg", OP48(0xe70003000089LL), MASK_VRR_VVV0V, INSTR_VRR_VVV0V, 2, 13, 0, "vector blend doubleword" },
  { "vstrczfs", OP48(0xe7000230008aLL), MASK_VRR_VVVU0VB3, INSTR_VRR_VVVU0VB3, 2, 9, 9, "vector string range compare word" },
  { "vstrszf", OP48(0xe7000220008bLL), MASK_VRR_VVV0V, INSTR_VRR_VVV0V, 2, 11, 0, "vector string search word zero" },
  { "vstrczf", OP48(0xe7000220008aLL), MASK_VRR_VVVU0VB2, INSTR_VRR_VVVU0VB2, 2, 9, 9, "vector string range compare word" },
  { "vstrcfs", OP48(0xe7000210008aLL), MASK_VRR_VVVU0VB1, INSTR_VRR_VVVU0VB1, 2, 9, 9, "vector string range compare word" },
  { "wfnmasb", OP48(0xe7000208009fLL), MASK_VRR_VVVV, INSTR_VRR_VVVV, 2, 10, 0, "scalar vector fp negative multiply and add scalar short" },
  { "wfnmssb", OP48(0xe7000208009eLL), MASK_VRR_VVVV, INSTR_VRR_VVVV, 2, 10, 0, "scalar vector fp negative multiply and subtract scalar short" },
  { "wfmasb", OP48(0xe7000208008fLL), MASK_VRR_VVVV, INSTR_VRR_VVVV, 2, 10, 0, "scalar vector fp multiply and add scalar short" },
  { "wfmssb", OP48(0xe7000208008eLL), MASK_VRR_VVVV, INSTR_VRR_VVVV, 2, 10, 0, "scalar vector fp multiply and subtract scalar short" },
  { "vgfmaf", OP48(0xe700020000bcLL), MASK_VRR_VVV0V, INSTR_VRR_VVV0V, 2, 9, 8, "vector galois field multiply sum and accumulate word" },
  { "vmaof", OP48(0xe700020000afLL), MASK_VRR_VVV0V, INSTR_VRR_VVV0V, 2, 9, 8, "vector multiply and add odd word" },
  { "vmaef", OP48(0xe700020000aeLL), MASK_VRR_VVV0V, INSTR_VRR_VVV0V, 2, 9, 8, "vector multiply and add even word" },
  { "vmalof", OP48(0xe700020000adLL), MASK_VRR_VVV0V, INSTR_VRR_VVV0V, 2, 9, 8, "vector multiply and add logical odd word" },
  { "vmalef", OP48(0xe700020000acLL), MASK_VRR_VVV0V, INSTR_VRR_VVV0V, 2, 9, 8, "vector multiply and add logical even word" },
  { "vmahf", OP48(0xe700020000abLL), MASK_VRR_VVV0V, INSTR_VRR_VVV0V, 2, 9, 8, "vector multiply and add high word" },
  { "vmalf", OP48(0xe700020000aaLL), MASK_VRR_VVV0V, INSTR_VRR_VVV0V, 2, 9, 8, "vector multiply and add low word" },
  { "vmalhf", OP48(0xe700020000a9LL), MASK_VRR_VVV0V, INSTR_VRR_VVV0V, 2, 9, 8, "vector multiply and add logical high word" },
  { "vfnmasb", OP48(0xe7000200009fLL), MASK_VRR_VVVV, INSTR_VRR_VVVV, 2, 10, 0, "vector fp negative multiply and add short" },
  { "vfnmssb", OP48(0xe7000200009eLL), MASK_VRR_VVVV, INSTR_VRR_VVVV, 2, 10, 0, "vector fp negative multiply and subtract short" },
  { "vfmasb", OP48(0xe7000200008fLL), MASK_VRR_VVVV, INSTR_VRR_VVVV, 2, 10, 0, "vector fp multiply and add short" },
  { "vfmssb", OP48(0xe7000200008eLL), MASK_VRR_VVVV, INSTR_VRR_VVVV, 2, 10, 0, "vector fp multiply and subtract short" },
  { "vstrsf", OP48(0xe7000200008bLL), MASK_VRR_VVVU0VB, INSTR_VRR_VVVU0VB, 2, 11, 1, "vector string search word" },
  { "vstrcf", OP48(0xe7000200008aLL), MASK_VRR_VVVU0VB, INSTR_VRR_VVVU0VB, 2, 9, 9, "vector string range compare word" },
  { "vblendf", OP48(0xe70002000089LL), MASK_VRR_VVV0V, INSTR_VRR_VVV0V, 2, 13, 0, "vector blend word" },
  { "vstrczhs", OP48(0xe7000130008aLL), MASK_VRR_VVVU0VB3, INSTR_VRR_VVVU0VB3, 2, 9, 9, "vector string range compare halfword" },
  { "vstrszh", OP48(0xe7000120008bLL), MASK_VRR_VVV0V, INSTR_VRR_VVV0V, 2, 11, 0, "vector string search halfword zero" },
  { "vstrczh", OP48(0xe7000120008aLL), MASK_VRR_VVVU0VB2, INSTR_VRR_VVVU0VB2, 2, 9, 9, "vector string range compare halfword" },
  { "vstrchs", OP48(0xe7000110008aLL), MASK_VRR_VVVU0VB1, INSTR_VRR_VVVU0VB1, 2, 9, 9, "vector string range compare halfword" },
  { "vgfmah", OP48(0xe700010000bcLL), MASK_VRR_VVV0V, INSTR_VRR_VVV0V, 2, 9, 8, "vector galois field multiply sum and accumulate halfword" },
  { "vmaoh", OP48(0xe700010000afLL), MASK_VRR_VVV0V, INSTR_VRR_VVV0V, 2, 9, 8, "vector multiply and add odd halfword" },
  { "vmaeh", OP48(0xe700010000aeLL), MASK_VRR_VVV0V, INSTR_VRR_VVV0V, 2, 9, 8, "vector multiply and add even halfword" },
  { "vmaloh", OP48(0xe700010000adLL), MASK_VRR_VVV0V, INSTR_VRR_VVV0V, 2, 9, 8, "vector multiply and add logical odd halfword" },
  { "vmaleh", OP48(0xe700010000acLL), MASK_VRR_VVV0V, INSTR_VRR_VVV0V, 2, 9, 8, "vector multiply and add logical even halfword" },
  { "vmahh", OP48(0xe700010000abLL), MASK_VRR_VVV0V, INSTR_VRR_VVV0V, 2, 9, 8, "vector multiply and add high halfword" },
  { "vmalhw", OP48(0xe700010000aaLL), MASK_VRR_VVV0V, INSTR_VRR_VVV0V, 2, 9, 8, "vector multiply and add low halfword" },
  { "vmalhh", OP48(0xe700010000a9LL), MASK_VRR_VVV0V, INSTR_VRR_VVV0V, 2, 9, 8, "vector multiply and add logical high halfword" },
  { "vstrsh", OP48(0xe7000100008bLL), MASK_VRR_VVVU0VB, INSTR_VRR_VVVU0VB, 2, 11, 1, "vector string search halfword" },
  { "vstrch", OP48(0xe7000100008aLL), MASK_VRR_VVVU0VB, INSTR_VRR_VVVU0VB, 2, 9, 9, "vector string range compare halfword" },
  { "vblendh", OP48(0xe70001000089LL), MASK_VRR_VVV0V, INSTR_VRR_VVV0V, 2, 13, 0, "vector blend halfword" },
  { "vfaezfs", OP48(0xe70000302082LL), MASK_VRR_VVV0U3, INSTR_VRR_VVV0U3, 2, 9, 9, "vector find any element equal" },
  { "vfenezfs", OP48(0xe70000302081LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector find element not equal word" },
  { "vfeezfs", OP48(0xe70000302080LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector find element equal word" },
  { "vfaezhs", OP48(0xe70000301082LL), MASK_VRR_VVV0U3, INSTR_VRR_VVV0U3, 2, 9, 9, "vector find any element equal" },
  { "vfenezhs", OP48(0xe70000301081LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector find element not equal halfword" },
  { "vfeezhs", OP48(0xe70000301080LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector find element equal halfword" },
  { "vstrczbs", OP48(0xe7000030008aLL), MASK_VRR_VVVU0VB3, INSTR_VRR_VVVU0VB3, 2, 9, 9, "vector string range compare byte" },
  { "vfaezbs", OP48(0xe70000300082LL), MASK_VRR_VVV0U3, INSTR_VRR_VVV0U3, 2, 9, 9, "vector find any element equal" },
  { "vfenezbs", OP48(0xe70000300081LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector find element not equal byte" },
  { "vfeezbs", OP48(0xe70000300080LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector find element equal byte" },
  { "wflpxb", OP48(0xe700002840ccLL), MASK_VRR_VV, INSTR_VRR_VV, 2, 10, 0, "scalar vector fp perform sign operation scalar extended" },
  { "wflpdb", OP48(0xe700002830ccLL), MASK_VRR_VV, INSTR_VRR_VV, 2, 9, 8, "vector fp perform sign operation long" },
  { "wflpsb", OP48(0xe700002820ccLL), MASK_VRR_VV, INSTR_VRR_VV, 2, 10, 0, "scalar vector fp perform sign operation scalar short" },
  { "vflpdb", OP48(0xe700002030ccLL), MASK_VRR_VV, INSTR_VRR_VV, 2, 9, 8, "vector fp perform sign operation long" },
  { "vflpsb", OP48(0xe700002020ccLL), MASK_VRR_VV, INSTR_VRR_VV, 2, 10, 0, "vector fp perform sign operation short" },
  { "vfaezf", OP48(0xe70000202082LL), MASK_VRR_VVV0U2, INSTR_VRR_VVV0U2, 2, 9, 9, "vector find any element equal" },
  { "vfenezf", OP48(0xe70000202081LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector find element not equal word" },
  { "vfeezf", OP48(0xe70000202080LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector find element equal word" },
  { "vfaezh", OP48(0xe70000201082LL), MASK_VRR_VVV0U2, INSTR_VRR_VVV0U2, 2, 9, 9, "vector find any element equal" },
  { "vfenezh", OP48(0xe70000201081LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector find element not equal halfword" },
  { "vfeezh", OP48(0xe70000201080LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector find element equal halfword" },
  { "vstrszb", OP48(0xe7000020008bLL), MASK_VRR_VVV0V, INSTR_VRR_VVV0V, 2, 11, 0, "vector string search byte zero" },
  { "vstrczb", OP48(0xe7000020008aLL), MASK_VRR_VVVU0VB2, INSTR_VRR_VVVU0VB2, 2, 9, 9, "vector string range compare byte" },
  { "vfaezb", OP48(0xe70000200082LL), MASK_VRR_VVV0U2, INSTR_VRR_VVV0U2, 2, 9, 9, "vector find any element equal" },
  { "vfenezb", OP48(0xe70000200081LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector find element not equal byte" },
  { "vfeezb", OP48(0xe70000200080LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector find element equal byte" },
  { "wfkhxbs", OP48(0xe700001c40ebLL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 10, 0, "scalar vector fp compare and signal high scalar extended" },
  { "wfkhexbs", OP48(0xe700001c40eaLL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 10, 0, "scalar vector fp compare and signal high or equal scalar extended" },
  { "wfkexbs", OP48(0xe700001c40e8LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 10, 0, "scalar vector fp compare and signal equal scalar extended" },
  { "wfkhdbs", OP48(0xe700001c30ebLL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 10, 8, "vector fp compare and signal high long" },
  { "wfkhedbs", OP48(0xe700001c30eaLL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 10, 8, "vector fp compare and signal high or equal long" },
  { "wfkedbs", OP48(0xe700001c30e8LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 10, 8, "vector fp compare and signal equal long" },
  { "wfkhsbs", OP48(0xe700001c20ebLL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 10, 0, "scalar vector fp compare and signal high scalar short" },
  { "wfkhesbs", OP48(0xe700001c20eaLL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 10, 0, "scalar vector fp compare and signal high or equal scalar short" },
  { "wfkesbs", OP48(0xe700001c20e8LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 10, 0, "scalar fp compare and signal equal scalar short" },
  { "wfchxbs", OP48(0xe700001840ebLL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 10, 0, "scalar vector fp compare high scalar extended" },
  { "wfchexbs", OP48(0xe700001840eaLL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 10, 0, "scalar vector fp compare high or equal scalar extended" },
  { "wfcexbs", OP48(0xe700001840e8LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 10, 0, "scalar vector fp compare equal scalar extended" },
  { "wflnxb", OP48(0xe700001840ccLL), MASK_VRR_VV, INSTR_VRR_VV, 2, 10, 0, "scalar vector fp perform sign operation scalar extended" },
  { "wfchdbs", OP48(0xe700001830ebLL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector fp compare high long" },
  { "wfchedbs", OP48(0xe700001830eaLL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector fp compare high or equal long" },
  { "wfcedbs", OP48(0xe700001830e8LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector fp compare equal long" },
  { "wflndb", OP48(0xe700001830ccLL), MASK_VRR_VV, INSTR_VRR_VV, 2, 9, 8, "vector fp perform sign operation long" },
  { "wfchsbs", OP48(0xe700001820ebLL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 10, 0, "scalar vector fp compare high scalar short" },
  { "wfchesbs", OP48(0xe700001820eaLL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 10, 0, "scalar vector fp compare high or equal scalar short" },
  { "wfcesbs", OP48(0xe700001820e8LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 10, 0, "scalar fp compare equal scalar short" },
  { "wflnsb", OP48(0xe700001820ccLL), MASK_VRR_VV, INSTR_VRR_VV, 2, 10, 0, "scalar vector fp perform sign operation scalar short" },
  { "vfkhdbs", OP48(0xe700001430ebLL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 10, 8, "vector fp compare and signal high long" },
  { "vfkhedbs", OP48(0xe700001430eaLL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 10, 8, "vector fp compare and signal high or equal long" },
  { "vfkedbs", OP48(0xe700001430e8LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 10, 8, "vector fp compare and signal equal long" },
  { "vfkhsbs", OP48(0xe700001420ebLL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 10, 0, "vector fp compare and signal high short" },
  { "vfkhesbs", OP48(0xe700001420eaLL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 10, 0, "vector fp compare and signal high or equal short" },
  { "vfkesbs", OP48(0xe700001420e8LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 10, 0, "vector fp compare and signal equal short" },
  { "vchqs", OP48(0xe700001040fbLL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 13, 0, "vector compare high quadword" },
  { "vchlqs", OP48(0xe700001040f9LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 13, 0, "vector compare high logical quadword" },
  { "vceqqs", OP48(0xe700001040f8LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 13, 0, "vector compare equal quadword" },
  { "vchgs", OP48(0xe700001030fbLL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector compare high double word" },
  { "vchlgs", OP48(0xe700001030f9LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector compare high logical double word" },
  { "vceqgs", OP48(0xe700001030f8LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector compare equal double word" },
  { "vfchdbs", OP48(0xe700001030ebLL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector fp compare high long" },
  { "vfchedbs", OP48(0xe700001030eaLL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector fp compare high or equal long" },
  { "vfcedbs", OP48(0xe700001030e8LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector fp compare equal long" },
  { "vflndb", OP48(0xe700001030ccLL), MASK_VRR_VV, INSTR_VRR_VV, 2, 9, 8, "vector fp perform sign operation long" },
  { "vpksgs", OP48(0xe70000103097LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector pack saturate double word" },
  { "vpklsgs", OP48(0xe70000103095LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector pack logical saturate double word" },
  { "vchfs", OP48(0xe700001020fbLL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector compare high word" },
  { "vchlfs", OP48(0xe700001020f9LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector compare high logical word" },
  { "vceqfs", OP48(0xe700001020f8LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector compare equal word" },
  { "vfchsbs", OP48(0xe700001020ebLL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 10, 0, "vector fp compare high short" },
  { "vfchesbs", OP48(0xe700001020eaLL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 10, 0, "vector fp compare high or equal short" },
  { "vfcesbs", OP48(0xe700001020e8LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 10, 0, "vector fp compare equal short" },
  { "vflnsb", OP48(0xe700001020ccLL), MASK_VRR_VV, INSTR_VRR_VV, 2, 10, 0, "vector fp perform sign operation short" },
  { "vpksfs", OP48(0xe70000102097LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector pack saturate word" },
  { "vpklsfs", OP48(0xe70000102095LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector pack logical saturate word" },
  { "vfaefs", OP48(0xe70000102082LL), MASK_VRR_VVV0U1, INSTR_VRR_VVV0U1, 2, 9, 9, "vector find any element equal" },
  { "vfenefs", OP48(0xe70000102081LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector find element not equal word" },
  { "vfeefs", OP48(0xe70000102080LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector find element equal word" },
  { "vistrfs", OP48(0xe7000010205cLL), MASK_VRR_VV, INSTR_VRR_VV, 2, 9, 8, "vector isolate string word" },
  { "vchhs", OP48(0xe700001010fbLL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector compare high half word" },
  { "vchlhs", OP48(0xe700001010f9LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector compare high logical half word" },
  { "vceqhs", OP48(0xe700001010f8LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector compare equal half word" },
  { "vpkshs", OP48(0xe70000101097LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector pack saturate halfword" },
  { "vpklshs", OP48(0xe70000101095LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector pack logical saturate halfword" },
  { "vfaehs", OP48(0xe70000101082LL), MASK_VRR_VVV0U1, INSTR_VRR_VVV0U1, 2, 9, 9, "vector find any element equal" },
  { "vfenehs", OP48(0xe70000101081LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector find element not equal halfword" },
  { "vfeehs", OP48(0xe70000101080LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector find element equal halfword" },
  { "vistrhs", OP48(0xe7000010105cLL), MASK_VRR_VV, INSTR_VRR_VV, 2, 9, 8, "vector isolate string halfword" },
  { "vchbs", OP48(0xe700001000fbLL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector compare high byte" },
  { "vchlbs", OP48(0xe700001000f9LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector compare high logical byte" },
  { "vceqbs", OP48(0xe700001000f8LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector compare equal byte" },
  { "vstrcbs", OP48(0xe7000010008aLL), MASK_VRR_VVVU0VB1, INSTR_VRR_VVVU0VB1, 2, 9, 9, "vector string range compare byte" },
  { "vfaebs", OP48(0xe70000100082LL), MASK_VRR_VVV0U1, INSTR_VRR_VVV0U1, 2, 9, 9, "vector find any element equal" },
  { "vfenebs", OP48(0xe70000100081LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector find element not equal byte" },
  { "vfeebs", OP48(0xe70000100080LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector find element equal byte" },
  { "vistrbs", OP48(0xe7000010005cLL), MASK_VRR_VV, INSTR_VRR_VV, 2, 9, 8, "vector isolate string byte" },
  { "wfkhxb", OP48(0xe700000c40ebLL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 10, 0, "scalar vector fp compare and signal high scalar extended" },
  { "wfkhexb", OP48(0xe700000c40eaLL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 10, 0, "scalar vector fp compare and signal high or equal scalar extended" },
  { "wfkexb", OP48(0xe700000c40e8LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 10, 0, "scalar vector fp compare and signal equal scalar extended" },
  { "wfkhdb", OP48(0xe700000c30ebLL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 10, 8, "vector fp compare and signal high long" },
  { "wfkhedb", OP48(0xe700000c30eaLL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 10, 8, "vector fp compare and signal high or equal long" },
  { "wfkedb", OP48(0xe700000c30e8LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 10, 8, "vector fp compare and signal equal long" },
  { "wfkhsb", OP48(0xe700000c20ebLL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 10, 0, "scalar vector fp compare and signal high scalar short" },
  { "wfkhesb", OP48(0xe700000c20eaLL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 10, 0, "scalar vector fp compare and signal high or equal scalar short" },
  { "wfkesb", OP48(0xe700000c20e8LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 10, 0, "scalar vector fp compare and signal equal scalar short" },
  { "wfmaxxb", OP48(0xe700000840efLL), MASK_VRR_VVV0U0, INSTR_VRR_VVV0U0, 2, 10, 0, "scalar fp maximum scalar extended" },
  { "wfminxb", OP48(0xe700000840eeLL), MASK_VRR_VVV0U0, INSTR_VRR_VVV0U0, 2, 10, 0, "scalar fp minimum scalar extended" },
  { "wfchxb", OP48(0xe700000840ebLL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 10, 0, "scalar vector fp compare high scalar extended" },
  { "wfchexb", OP48(0xe700000840eaLL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 10, 0, "scalar vector fp compare high or equal scalar extended" },
  { "wfcexb", OP48(0xe700000840e8LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 10, 0, "scalar vector fp compare equal scalar extended" },
  { "wfmxb", OP48(0xe700000840e7LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 10, 0, "scalar vector fp multiply scalar extended" },
  { "wfdxb", OP48(0xe700000840e5LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 10, 0, "scalar vector fp divide scalar extended" },
  { "wfaxb", OP48(0xe700000840e3LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 10, 0, "scalar vector fp add scalar extended" },
  { "wfsxb", OP48(0xe700000840e2LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 10, 0, "scalar vector fp subtract scalar extended" },
  { "wfsqxb", OP48(0xe700000840ceLL), MASK_VRR_VV, INSTR_VRR_VV, 2, 10, 0, "scalar vector fp square root scalar extended" },
  { "wfpsoxb", OP48(0xe700000840ccLL), MASK_VRR_VV0U2, INSTR_VRR_VV0U2, 2, 10, 0, "scalar vector fp perform sign operation scalar extended" },
  { "wflcxb", OP48(0xe700000840ccLL), MASK_VRR_VV, INSTR_VRR_VV, 2, 10, 0, "scalar vector fp perform sign operation scalar extended" },
  { "wfixb", OP48(0xe700000840c7LL), MASK_VRR_VV0UU8, INSTR_VRR_VV0UU8, 2, 10, 0, "scalar vector load fp integer scalar extended" },
  { "wflrx", OP48(0xe700000840c5LL), MASK_VRR_VV0UU8, INSTR_VRR_VV0UU8, 2, 10, 0, "scalar vector fp load rounded extended" },
  { "wftcixb", OP48(0xe7000008404aLL), MASK_VRI_VVU2, INSTR_VRI_VVU2, 2, 10, 0, "scalar vector fp test data class immediate scalar extended" },
  { "wfmaxdb", OP48(0xe700000830efLL), MASK_VRR_VVV0U0, INSTR_VRR_VVV0U0, 2, 10, 0, "scalar fp maximum scalar long" },
  { "wfmindb", OP48(0xe700000830eeLL), MASK_VRR_VVV0U0, INSTR_VRR_VVV0U0, 2, 10, 0, "scalar fp minimum scalar long" },
  { "wfchdb", OP48(0xe700000830ebLL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector fp compare high long" },
  { "wfchedb", OP48(0xe700000830eaLL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector fp compare high or equal long" },
  { "wfcedb", OP48(0xe700000830e8LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector fp compare equal long" },
  { "wfmdb", OP48(0xe700000830e7LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector fp multiply long" },
  { "wfddb", OP48(0xe700000830e5LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector fp divide long" },
  { "wfadb", OP48(0xe700000830e3LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector fp add long" },
  { "wfsdb", OP48(0xe700000830e2LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector fp subtract long" },
  { "wfsqdb", OP48(0xe700000830ceLL), MASK_VRR_VV, INSTR_VRR_VV, 2, 9, 8, "vector fp square root long" },
  { "wfpsodb", OP48(0xe700000830ccLL), MASK_VRR_VV0U2, INSTR_VRR_VV0U2, 2, 9, 8, "vector fp perform sign operation long" },
  { "wflcdb", OP48(0xe700000830ccLL), MASK_VRR_VV, INSTR_VRR_VV, 2, 9, 8, "vector fp perform sign operation long" },
  { "wfidb", OP48(0xe700000830c7LL), MASK_VRR_VV0UU8, INSTR_VRR_VV0UU8, 2, 9, 8, "vector load fp integer long" },
  { "wflrd", OP48(0xe700000830c5LL), MASK_VRR_VV0UU8, INSTR_VRR_VV0UU8, 2, 10, 0, "scalar vector fp load rounded long" },
  { "wledb", OP48(0xe700000830c5LL), MASK_VRR_VV0UU8, INSTR_VRR_VV0UU8, 2, 9, 8, "vector fp load rounded long to short" },
  { "wflld", OP48(0xe700000830c4LL), MASK_VRR_VV, INSTR_VRR_VV, 2, 10, 0, "scalar vector fp load lengthened long" },
  { "wcdgb", OP48(0xe700000830c3LL), MASK_VRR_VV0UU8, INSTR_VRR_VV0UU8, 2, 9, 8, "vector fp convert from fixed 64 bit" },
  { "wcgdb", OP48(0xe700000830c2LL), MASK_VRR_VV0UU8, INSTR_VRR_VV0UU8, 2, 9, 8, "vector fp convert to fixed 64 bit" },
  { "wcdlgb", OP48(0xe700000830c1LL), MASK_VRR_VV0UU8, INSTR_VRR_VV0UU8, 2, 9, 8, "vector fp convert from logical 64 bit" },
  { "wclgdb", OP48(0xe700000830c0LL), MASK_VRR_VV0UU8, INSTR_VRR_VV0UU8, 2, 9, 8, "vector fp convert to logical 64 bit" },
  { "wftcidb", OP48(0xe7000008304aLL), MASK_VRI_VVU2, INSTR_VRI_VVU2, 2, 9, 8, "vector fp test data class immediate" },
  { "wfmaxsb", OP48(0xe700000820efLL), MASK_VRR_VVV0U0, INSTR_VRR_VVV0U0, 2, 10, 0, "scalar fp maximum scalar short" },
  { "wfminsb", OP48(0xe700000820eeLL), MASK_VRR_VVV0U0, INSTR_VRR_VVV0U0, 2, 10, 0, "scalar fp minimum scalar short" },
  { "wfchsb", OP48(0xe700000820ebLL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 10, 0, "scalar vector fp compare high scalar short" },
  { "wfchesb", OP48(0xe700000820eaLL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 10, 0, "scalar vector fp compare high or equal scalar short" },
  { "wfcesb", OP48(0xe700000820e8LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 10, 0, "scalar vector fp compare equal scalar short" },
  { "wfmsb", OP48(0xe700000820e7LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 10, 0, "scalar vector fp multiply scalar short" },
  { "wfdsb", OP48(0xe700000820e5LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 10, 0, "scalar vector fp divide scalar short" },
  { "wfasb", OP48(0xe700000820e3LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 10, 0, "scalar vector fp add scalar short" },
  { "wfssb", OP48(0xe700000820e2LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 10, 0, "scalar vector fp subtract scalar short" },
  { "wfsqsb", OP48(0xe700000820ceLL), MASK_VRR_VV, INSTR_VRR_VV, 2, 10, 0, "scalar vector fp square root scalar short" },
  { "wfpsosb", OP48(0xe700000820ccLL), MASK_VRR_VV0U2, INSTR_VRR_VV0U2, 2, 10, 0, "scalar vector fp perform sign operation scalar short" },
  { "wflcsb", OP48(0xe700000820ccLL), MASK_VRR_VV, INSTR_VRR_VV, 2, 10, 0, "scalar vector fp perform sign operation scalar short" },
  { "wfisb", OP48(0xe700000820c7LL), MASK_VRR_VV0UU8, INSTR_VRR_VV0UU8, 2, 10, 0, "scalar vector load fp integer scalar short" },
  { "wflls", OP48(0xe700000820c4LL), MASK_VRR_VV, INSTR_VRR_VV, 2, 10, 0, "scalar vector fp load lengthened short" },
  { "wldeb", OP48(0xe700000820c4LL), MASK_VRR_VV, INSTR_VRR_VV, 2, 9, 8, "vector fp load lengthened short to long" },
  { "wcefb", OP48(0xe700000820c3LL), MASK_VRR_VV0UU8, INSTR_VRR_VV0UU8, 2, 11, 0, "vector fp convert from fixed 32 bit" },
  { "wcfeb", OP48(0xe700000820c2LL), MASK_VRR_VV0UU8, INSTR_VRR_VV0UU8, 2, 11, 0, "vector fp convert to fixed 32 bit" },
  { "wcelfb", OP48(0xe700000820c1LL), MASK_VRR_VV0UU8, INSTR_VRR_VV0UU8, 2, 11, 0, "vector fp convert from logical 32 bit" },
  { "wclfeb", OP48(0xe700000820c0LL), MASK_VRR_VV0UU8, INSTR_VRR_VV0UU8, 2, 11, 0, "vector fp convert to logical 32 bit" },
  { "wftcisb", OP48(0xe7000008204aLL), MASK_VRI_VVU2, INSTR_VRI_VVU2, 2, 10, 0, "scalar vector fp test data class immediate scalar short" },
  { "vfkhdb", OP48(0xe700000430ebLL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 10, 8, "vector fp compare and signal high long" },
  { "vfkhedb", OP48(0xe700000430eaLL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 10, 8, "vector fp compare and signal high or equal long" },
  { "vfkedb", OP48(0xe700000430e8LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 10, 8, "vector fp compare and signal equal long" },
  { "vfkhsb", OP48(0xe700000420ebLL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 10, 0, "vector fp compare and signal high short" },
  { "vfkhesb", OP48(0xe700000420eaLL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 10, 0, "vector fp compare and signal high or equal short" },
  { "vfkesb", OP48(0xe700000420e8LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 10, 0, "vector fp compare and signal equal short" },
  { "vllezlf", OP48(0xe70000006004LL), MASK_VRX_VRRD, INSTR_VRX_VRRD, 2, 10, 0, "vector load logical word element and zero - left aligned" },
  { "vmxq", OP48(0xe700000040ffLL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 13, 0, "vector maximum quadword" },
  { "vmnq", OP48(0xe700000040feLL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 13, 0, "vector minimum quadword" },
  { "vmxlq", OP48(0xe700000040fdLL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 13, 0, "vector maximum logical quadword" },
  { "vmnlq", OP48(0xe700000040fcLL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 13, 0, "vector minimum logical quadword" },
  { "vchq", OP48(0xe700000040fbLL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 13, 0, "vector compare high quadword" },
  { "vchlq", OP48(0xe700000040f9LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 13, 0, "vector compare high logical quadword" },
  { "vceqq", OP48(0xe700000040f8LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 13, 0, "vector compare equal quadword" },
  { "vsq", OP48(0xe700000040f7LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector subtract quadword" },
  { "vscbiq", OP48(0xe700000040f5LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector subtract compute borrow indication quadword" },
  { "vaq", OP48(0xe700000040f3LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector add quad word" },
  { "vavgq", OP48(0xe700000040f2LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 13, 0, "vector average quadword" },
  { "vaccq", OP48(0xe700000040f1LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector add compute carry quadword" },
  { "vavglq", OP48(0xe700000040f0LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 13, 0, "vector average logical quadword" },
  { "vlpq", OP48(0xe700000040dfLL), MASK_VRR_VV, INSTR_VRR_VV, 2, 13, 0, "vector load positive quadword" },
  { "vlcq", OP48(0xe700000040deLL), MASK_VRR_VV, INSTR_VRR_VV, 2, 13, 0, "vector load complement quadword" },
  { "vecq", OP48(0xe700000040dbLL), MASK_VRR_VV, INSTR_VRR_VV, 2, 13, 0, "vector element compare quadword" },
  { "veclq", OP48(0xe700000040d9LL), MASK_VRR_VV, INSTR_VRR_VV, 2, 13, 0, "vector element compare logical quadword" },
  { "wfcxb", OP48(0xe700000040cbLL), MASK_VRR_VV, INSTR_VRR_VV, 2, 10, 0, "scalar vector fp compare scalar extended" },
  { "wfkxb", OP48(0xe700000040caLL), MASK_VRR_VV, INSTR_VRR_VV, 2, 10, 0, "scalar vector fp compare and signal scalar extended" },
  { "vrq", OP48(0xe700000040b3LL), MASK_VRR_VVV0U02, INSTR_VRR_VVV0U02, 2, 13, 0, "vector remainder quadword" },
  { "vdq", OP48(0xe700000040b2LL), MASK_VRR_VVV0U02, INSTR_VRR_VVV0U02, 2, 13, 0, "vector divide quadword" },
  { "vrlq", OP48(0xe700000040b1LL), MASK_VRR_VVV0U02, INSTR_VRR_VVV0U02, 2, 13, 0, "vector remainder logical quadword" },
  { "vdlq", OP48(0xe700000040b0LL), MASK_VRR_VVV0U02, INSTR_VRR_VVV0U02, 2, 13, 0, "vector divide logical quadword" },
  { "vmhq", OP48(0xe700000040a3LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 13, 0, "vector multiply high quadword" },
  { "vmlq", OP48(0xe700000040a2LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 13, 0, "vector multiply low quadword" },
  { "vmlhq", OP48(0xe700000040a1LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 13, 0, "vector multiply logical high quadword" },
  { "vgemq", OP48(0xe70000004054LL), MASK_VRR_VV, INSTR_VRR_VV, 2, 13, 0, "vector generate element masks quadword" },
  { "vclzq", OP48(0xe70000004053LL), MASK_VRR_VV, INSTR_VRR_VV, 2, 13, 0, "vector count leading zeros quadword" },
  { "vctzq", OP48(0xe70000004052LL), MASK_VRR_VV, INSTR_VRR_VV, 2, 13, 0, "vector count trailing zeros quadword" },
  { "vmxg", OP48(0xe700000030ffLL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector maximum doubleword" },
  { "vmng", OP48(0xe700000030feLL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector minimum doubleword" },
  { "vmxlg", OP48(0xe700000030fdLL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector maximum logical doubleword" },
  { "vmnlg", OP48(0xe700000030fcLL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector minimum logical doubleword" },
  { "vchg", OP48(0xe700000030fbLL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector compare high double word" },
  { "vchlg", OP48(0xe700000030f9LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector compare high logical double word" },
  { "vceqg", OP48(0xe700000030f8LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector compare equal double word" },
  { "vsg", OP48(0xe700000030f7LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector subtract doubleword" },
  { "vscbig", OP48(0xe700000030f5LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector subtract compute borrow indication doubleword" },
  { "vag", OP48(0xe700000030f3LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector add double word" },
  { "vavgg", OP48(0xe700000030f2LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector average double word" },
  { "vaccg", OP48(0xe700000030f1LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector add compute carry doubleword" },
  { "vavglg", OP48(0xe700000030f0LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector average logical double word" },
  { "vfmaxdb", OP48(0xe700000030efLL), MASK_VRR_VVV0U0, INSTR_VRR_VVV0U0, 2, 10, 0, "vector fp maximum long" },
  { "vfmindb", OP48(0xe700000030eeLL), MASK_VRR_VVV0U0, INSTR_VRR_VVV0U0, 2, 10, 0, "vector fp minimum long" },
  { "vfchdb", OP48(0xe700000030ebLL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector fp compare high long" },
  { "vfchedb", OP48(0xe700000030eaLL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector fp compare high or equal long" },
  { "vfcedb", OP48(0xe700000030e8LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector fp compare equal long" },
  { "vfmdb", OP48(0xe700000030e7LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector fp multiply long" },
  { "vfddb", OP48(0xe700000030e5LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector fp divide long" },
  { "vfadb", OP48(0xe700000030e3LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector fp add long" },
  { "vfsdb", OP48(0xe700000030e2LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector fp subtract long" },
  { "vlpg", OP48(0xe700000030dfLL), MASK_VRR_VV, INSTR_VRR_VV, 2, 9, 8, "vector load positive doubleword" },
  { "vlcg", OP48(0xe700000030deLL), MASK_VRR_VV, INSTR_VRR_VV, 2, 9, 8, "vector load complement doubleword" },
  { "vecg", OP48(0xe700000030dbLL), MASK_VRR_VV, INSTR_VRR_VV, 2, 9, 8, "vector element compare double word" },
  { "veclg", OP48(0xe700000030d9LL), MASK_VRR_VV, INSTR_VRR_VV, 2, 9, 8, "vector element compare logical double word" },
  { "vuphg", OP48(0xe700000030d7LL), MASK_VRR_VV, INSTR_VRR_VV, 2, 13, 0, "vector unpack high doubleword" },
  { "vuplg", OP48(0xe700000030d6LL), MASK_VRR_VV, INSTR_VRR_VV, 2, 13, 0, "vector unpack low doubleword" },
  { "vuplhg", OP48(0xe700000030d5LL), MASK_VRR_VV, INSTR_VRR_VV, 2, 13, 0, "vector unpack logical high doubleword" },
  { "vupllg", OP48(0xe700000030d4LL), MASK_VRR_VV, INSTR_VRR_VV, 2, 13, 0, "vector unpack logical low doubleword" },
  { "vfsqdb", OP48(0xe700000030ceLL), MASK_VRR_VV, INSTR_VRR_VV, 2, 9, 8, "vector fp square root long" },
  { "vfpsodb", OP48(0xe700000030ccLL), MASK_VRR_VV0U2, INSTR_VRR_VV0U2, 2, 9, 8, "vector fp perform sign operation long" },
  { "vflcdb", OP48(0xe700000030ccLL), MASK_VRR_VV, INSTR_VRR_VV, 2, 9, 8, "vector fp perform sign operation long" },
  { "wfcdb", OP48(0xe700000030cbLL), MASK_VRR_VV, INSTR_VRR_VV, 2, 9, 8, "vector fp compare scalar long" },
  { "wfkdb", OP48(0xe700000030caLL), MASK_VRR_VV, INSTR_VRR_VV, 2, 9, 8, "vector fp compare and signal scalar long" },
  { "vfidb", OP48(0xe700000030c7LL), MASK_VRR_VV0UU, INSTR_VRR_VV0UU, 2, 9, 8, "vector load fp integer long" },
  { "vflrd", OP48(0xe700000030c5LL), MASK_VRR_VV0UU, INSTR_VRR_VV0UU, 2, 10, 0, "vector fp load rounded long" },
  { "vledb", OP48(0xe700000030c5LL), MASK_VRR_VV0UU, INSTR_VRR_VV0UU, 2, 9, 8, "vector fp load rounded long to short" },
  { "vcdgb", OP48(0xe700000030c3LL), MASK_VRR_VV0UU, INSTR_VRR_VV0UU, 2, 9, 8, "vector fp convert from fixed 64 bit" },
  { "vcgdb", OP48(0xe700000030c2LL), MASK_VRR_VV0UU, INSTR_VRR_VV0UU, 2, 9, 8, "vector fp convert to fixed 64 bit" },
  { "vcdlgb", OP48(0xe700000030c1LL), MASK_VRR_VV0UU, INSTR_VRR_VV0UU, 2, 9, 8, "vector fp convert from logical 64 bit" },
  { "vclgdb", OP48(0xe700000030c0LL), MASK_VRR_VV0UU, INSTR_VRR_VV0UU, 2, 9, 8, "vector fp convert to logical 64 bit" },
  { "vgfmg", OP48(0xe700000030b4LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector galois field multiply sum doubleword" },
  { "vrg", OP48(0xe700000030b3LL), MASK_VRR_VVV0U02, INSTR_VRR_VVV0U02, 2, 13, 0, "vector remainder doubleword" },
  { "vdg", OP48(0xe700000030b2LL), MASK_VRR_VVV0U02, INSTR_VRR_VVV0U02, 2, 13, 0, "vector divide doubleword" },
  { "vrlg", OP48(0xe700000030b1LL), MASK_VRR_VVV0U02, INSTR_VRR_VVV0U02, 2, 13, 0, "vector remainder logical doubleword" },
  { "vdlg", OP48(0xe700000030b0LL), MASK_VRR_VVV0U02, INSTR_VRR_VVV0U02, 2, 13, 0, "vector divide logical doubleword" },
  { "vmog", OP48(0xe700000030a7LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 13, 0, "vector multiply odd doubleword" },
  { "vmeg", OP48(0xe700000030a6LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 13, 0, "vector multiply even doubleword" },
  { "vmlog", OP48(0xe700000030a5LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 13, 0, "vector multiply logical odd doubleword" },
  { "vmleg", OP48(0xe700000030a4LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 13, 0, "vector multiply logical even doubleword" },
  { "vmhg", OP48(0xe700000030a3LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 13, 0, "vector multiply high doubleword" },
  { "vmlg", OP48(0xe700000030a2LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 13, 0, "vector multiply low doubleword" },
  { "vmlhg", OP48(0xe700000030a1LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 13, 0, "vector multiply logical high doubleword" },
  { "vpksg", OP48(0xe70000003097LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector pack saturate double word" },
  { "vpklsg", OP48(0xe70000003095LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector pack logical saturate double word" },
  { "vpkg", OP48(0xe70000003094LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector pack double word" },
  { "vesravg", OP48(0xe7000000307aLL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector element shift right arithmetic reg doubleword" },
  { "vesrlvg", OP48(0xe70000003078LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector element shift right logical reg doubleword" },
  { "verllvg", OP48(0xe70000003073LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector element rotate left logical reg doubleword" },
  { "verimg", OP48(0xe70000003072LL), MASK_VRI_VVV0U, INSTR_VRI_VVV0U, 2, 9, 8, "vector element rotate and insert under mask doubleword" },
  { "veslvg", OP48(0xe70000003070LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector element shift left reg doubleword" },
  { "vsumqg", OP48(0xe70000003067LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector sum across quadword - doubleword elements" },
  { "vmrhg", OP48(0xe70000003061LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector merge high double word" },
  { "vmrlg", OP48(0xe70000003060LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector merge low double word" },
  { "vgemg", OP48(0xe70000003054LL), MASK_VRR_VV, INSTR_VRR_VV, 2, 13, 0, "vector generate element masks doubleword" },
  { "vclzg", OP48(0xe70000003053LL), MASK_VRR_VV, INSTR_VRR_VV, 2, 9, 8, "vector count leading zeros doubleword" },
  { "vctzg", OP48(0xe70000003052LL), MASK_VRR_VV, INSTR_VRR_VV, 2, 9, 8, "vector count trailing zeros doubleword" },
  { "vpopctg", OP48(0xe70000003050LL), MASK_VRR_VV, INSTR_VRR_VV, 2, 10, 0, "vector population count double word" },
  { "vrepg", OP48(0xe7000000304dLL), MASK_VRI_VVU, INSTR_VRI_VVU, 2, 9, 8, "vector replicate double word" },
  { "vftcidb", OP48(0xe7000000304aLL), MASK_VRI_VVU2, INSTR_VRI_VVU2, 2, 9, 8, "vector fp test data class immediate" },
  { "vgmg", OP48(0xe70000003046LL), MASK_VRI_V0UU, INSTR_VRI_V0UU, 2, 9, 8, "vector generate mask double word" },
  { "vrepig", OP48(0xe70000003045LL), MASK_VRI_V0I, INSTR_VRI_V0I, 2, 9, 8, "vector replicate immediate double word" },
  { "vesrag", OP48(0xe7000000303aLL), MASK_VRS_VVRD, INSTR_VRS_VVRD, 2, 9, 8, "vector element shift right arithmetic mem doubleword" },
  { "vesrlg", OP48(0xe70000003038LL), MASK_VRS_VVRD, INSTR_VRS_VVRD, 2, 9, 8, "vector element shift right logical mem doubleword" },
  { "verllg", OP48(0xe70000003033LL), MASK_VRS_VVRD, INSTR_VRS_VVRD, 2, 9, 8, "vector element rotate left logical mem doubleword" },
  { "veslg", OP48(0xe70000003030LL), MASK_VRS_VVRD, INSTR_VRS_VVRD, 2, 9, 8, "vector element shift left mem doubleword" },
  { "vlvgg", OP48(0xe70000003022LL), MASK_VRS_VRRD, INSTR_VRS_VRRD, 2, 9, 8, "vector load VR double word element from GR" },
  { "vlgvg", OP48(0xe70000003021LL), MASK_VRS_RVRD, INSTR_VRS_RVRD, 2, 9, 8, "vector load GR from VR double word element" },
  { "vlrepg", OP48(0xe70000003005LL), MASK_VRX_VRRD, INSTR_VRX_VRRD, 2, 9, 8, "vector load and replicate double word elements" },
  { "vllezg", OP48(0xe70000003004LL), MASK_VRX_VRRD, INSTR_VRX_VRRD, 2, 9, 8, "vector load logical double word element and zero" },
  { "vmxf", OP48(0xe700000020ffLL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector maximum word" },
  { "vmnf", OP48(0xe700000020feLL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector minimum word" },
  { "vmxlf", OP48(0xe700000020fdLL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector maximum logical word" },
  { "vmnlf", OP48(0xe700000020fcLL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector minimum logical word" },
  { "vchf", OP48(0xe700000020fbLL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector compare high word" },
  { "vchlf", OP48(0xe700000020f9LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector compare high logical word" },
  { "vceqf", OP48(0xe700000020f8LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector compare equal word" },
  { "vsf", OP48(0xe700000020f7LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector subtract word" },
  { "vscbif", OP48(0xe700000020f5LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector subtract compute borrow indication word" },
  { "vaf", OP48(0xe700000020f3LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector add word" },
  { "vavgf", OP48(0xe700000020f2LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector average word" },
  { "vaccf", OP48(0xe700000020f1LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector add compute carry word" },
  { "vavglf", OP48(0xe700000020f0LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector average logical word" },
  { "vfmaxsb", OP48(0xe700000020efLL), MASK_VRR_VVV0U0, INSTR_VRR_VVV0U0, 2, 10, 0, "vector fp maximum short" },
  { "vfminsb", OP48(0xe700000020eeLL), MASK_VRR_VVV0U0, INSTR_VRR_VVV0U0, 2, 10, 0, "vector fp minimum short" },
  { "vfchsb", OP48(0xe700000020ebLL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 10, 0, "vector fp compare high short" },
  { "vfchesb", OP48(0xe700000020eaLL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 10, 0, "vector fp compare high or equal short" },
  { "vfcesb", OP48(0xe700000020e8LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 10, 0, "vector fp compare equal short" },
  { "vfmsb", OP48(0xe700000020e7LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 10, 0, "vector fp multiply short" },
  { "vfdsb", OP48(0xe700000020e5LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 10, 0, "vector fp divide short" },
  { "vfasb", OP48(0xe700000020e3LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 10, 0, "vector fp add short" },
  { "vfssb", OP48(0xe700000020e2LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 10, 0, "vector fp subtract short" },
  { "vlpf", OP48(0xe700000020dfLL), MASK_VRR_VV, INSTR_VRR_VV, 2, 9, 8, "vector load positive word" },
  { "vlcf", OP48(0xe700000020deLL), MASK_VRR_VV, INSTR_VRR_VV, 2, 9, 8, "vector load complement word" },
  { "vecf", OP48(0xe700000020dbLL), MASK_VRR_VV, INSTR_VRR_VV, 2, 9, 8, "vector element compare word" },
  { "veclf", OP48(0xe700000020d9LL), MASK_VRR_VV, INSTR_VRR_VV, 2, 9, 8, "vector element compare logical word" },
  { "vuphf", OP48(0xe700000020d7LL), MASK_VRR_VV, INSTR_VRR_VV, 2, 9, 8, "vector unpack high word" },
  { "vuplf", OP48(0xe700000020d6LL), MASK_VRR_VV, INSTR_VRR_VV, 2, 9, 8, "vector unpack low word" },
  { "vuplhf", OP48(0xe700000020d5LL), MASK_VRR_VV, INSTR_VRR_VV, 2, 9, 8, "vector unpack logical high word" },
  { "vupllf", OP48(0xe700000020d4LL), MASK_VRR_VV, INSTR_VRR_VV, 2, 9, 8, "vector unpack logical low word" },
  { "vfsqsb", OP48(0xe700000020ceLL), MASK_VRR_VV, INSTR_VRR_VV, 2, 10, 0, "vector fp square root short" },
  { "vfpsosb", OP48(0xe700000020ccLL), MASK_VRR_VV0U2, INSTR_VRR_VV0U2, 2, 10, 0, "vector fp perform sign operation short" },
  { "vflcsb", OP48(0xe700000020ccLL), MASK_VRR_VV, INSTR_VRR_VV, 2, 10, 0, "vector fp perform sign operation short" },
  { "wfcsb", OP48(0xe700000020cbLL), MASK_VRR_VV, INSTR_VRR_VV, 2, 10, 0, "scalar vector fp compare scalar short" },
  { "wfksb", OP48(0xe700000020caLL), MASK_VRR_VV, INSTR_VRR_VV, 2, 10, 0, "scalar vector fp compare and signal scalar short" },
  { "vfisb", OP48(0xe700000020c7LL), MASK_VRR_VV0UU, INSTR_VRR_VV0UU, 2, 10, 0, "vector load fp integer short" },
  { "vflls", OP48(0xe700000020c4LL), MASK_VRR_VV, INSTR_VRR_VV, 2, 10, 0, "vector fp load lengthened" },
  { "vldeb", OP48(0xe700000020c4LL), MASK_VRR_VV, INSTR_VRR_VV, 2, 9, 8, "vector fp load lengthened short to long" },
  { "vcefb", OP48(0xe700000020c3LL), MASK_VRR_VV0UU, INSTR_VRR_VV0UU, 2, 11, 0, "vector fp convert from fixed 32 bit" },
  { "vcfeb", OP48(0xe700000020c2LL), MASK_VRR_VV0UU, INSTR_VRR_VV0UU, 2, 11, 0, "vector fp convert to fixed 32 bit" },
  { "vcelfb", OP48(0xe700000020c1LL), MASK_VRR_VV0UU, INSTR_VRR_VV0UU, 2, 11, 0, "vector fp convert from logical 32 bit" },
  { "vclfeb", OP48(0xe700000020c0LL), MASK_VRR_VV0UU, INSTR_VRR_VV0UU, 2, 11, 0, "vector fp convert to logical 32 bit" },
  { "vgfmf", OP48(0xe700000020b4LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector galois field multiply sum word" },
  { "vrf", OP48(0xe700000020b3LL), MASK_VRR_VVV0U02, INSTR_VRR_VVV0U02, 2, 13, 0, "vector remainder word" },
  { "vdf", OP48(0xe700000020b2LL), MASK_VRR_VVV0U02, INSTR_VRR_VVV0U02, 2, 13, 0, "vector divide word" },
  { "vrlf", OP48(0xe700000020b1LL), MASK_VRR_VVV0U02, INSTR_VRR_VVV0U02, 2, 13, 0, "vector remainder logical word" },
  { "vdlf", OP48(0xe700000020b0LL), MASK_VRR_VVV0U02, INSTR_VRR_VVV0U02, 2, 13, 0, "vector divide logical word" },
  { "vmof", OP48(0xe700000020a7LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector multiply odd word" },
  { "vmef", OP48(0xe700000020a6LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector multiply even word" },
  { "vmlof", OP48(0xe700000020a5LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector multiply logical odd word" },
  { "vmlef", OP48(0xe700000020a4LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector multiply logical even word" },
  { "vmhf", OP48(0xe700000020a3LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector multiply high word" },
  { "vmlf", OP48(0xe700000020a2LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector multiply low word" },
  { "vmlhf", OP48(0xe700000020a1LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector multiply logical high word" },
  { "vpksf", OP48(0xe70000002097LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector pack saturate word" },
  { "vpklsf", OP48(0xe70000002095LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector pack logical saturate word" },
  { "vpkf", OP48(0xe70000002094LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector pack word" },
  { "vfaef", OP48(0xe70000002082LL), MASK_VRR_VVV0U0, INSTR_VRR_VVV0U0, 2, 9, 9, "vector find any element equal word" },
  { "vfenef", OP48(0xe70000002081LL), MASK_VRR_VVV0U0, INSTR_VRR_VVV0U0, 2, 9, 9, "vector find element not equal word" },
  { "vfeef", OP48(0xe70000002080LL), MASK_VRR_VVV0U0, INSTR_VRR_VVV0U0, 2, 9, 9, "vector find element equal word" },
  { "vesravf", OP48(0xe7000000207aLL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector element shift right arithmetic reg word" },
  { "vesrlvf", OP48(0xe70000002078LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector element shift right logical reg word" },
  { "verllvf", OP48(0xe70000002073LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector element rotate left logical reg word" },
  { "verimf", OP48(0xe70000002072LL), MASK_VRI_VVV0U, INSTR_VRI_VVV0U, 2, 9, 8, "vector element rotate and insert under mask word" },
  { "veslvf", OP48(0xe70000002070LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector element shift left reg word" },
  { "vsumqf", OP48(0xe70000002067LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector sum across quadword - word elements" },
  { "vsumgf", OP48(0xe70000002065LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector sum across doubleword - word" },
  { "vmrhf", OP48(0xe70000002061LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector merge high word" },
  { "vmrlf", OP48(0xe70000002060LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector merge low word" },
  { "vsegf", OP48(0xe7000000205fLL), MASK_VRR_VV, INSTR_VRR_VV, 2, 9, 8, "vector sign extend word to double word" },
  { "vistrf", OP48(0xe7000000205cLL), MASK_VRR_VV0U2, INSTR_VRR_VV0U2, 2, 9, 9, "vector isolate string word" },
  { "vgemf", OP48(0xe70000002054LL), MASK_VRR_VV, INSTR_VRR_VV, 2, 13, 0, "vector generate element masks word" },
  { "vclzf", OP48(0xe70000002053LL), MASK_VRR_VV, INSTR_VRR_VV, 2, 9, 8, "vector count leading zeros word" },
  { "vctzf", OP48(0xe70000002052LL), MASK_VRR_VV, INSTR_VRR_VV, 2, 9, 8, "vector count trailing zeros word" },
  { "vpopctf", OP48(0xe70000002050LL), MASK_VRR_VV, INSTR_VRR_VV, 2, 10, 0, "vector population count word" },
  { "vrepf", OP48(0xe7000000204dLL), MASK_VRI_VVU, INSTR_VRI_VVU, 2, 9, 8, "vector replicate word" },
  { "vftcisb", OP48(0xe7000000204aLL), MASK_VRI_VVU2, INSTR_VRI_VVU2, 2, 10, 0, "vector fp test data class immediate short" },
  { "vgmf", OP48(0xe70000002046LL), MASK_VRI_V0UU, INSTR_VRI_V0UU, 2, 9, 8, "vector generate mask word" },
  { "vrepif", OP48(0xe70000002045LL), MASK_VRI_V0I, INSTR_VRI_V0I, 2, 9, 8, "vector replicate immediate word" },
  { "vesraf", OP48(0xe7000000203aLL), MASK_VRS_VVRD, INSTR_VRS_VVRD, 2, 9, 8, "vector element shift right arithmetic mem word" },
  { "vesrlf", OP48(0xe70000002038LL), MASK_VRS_VVRD, INSTR_VRS_VVRD, 2, 9, 8, "vector element shift right logical mem word" },
  { "verllf", OP48(0xe70000002033LL), MASK_VRS_VVRD, INSTR_VRS_VVRD, 2, 9, 8, "vector element rotate left logical mem word" },
  { "veslf", OP48(0xe70000002030LL), MASK_VRS_VVRD, INSTR_VRS_VVRD, 2, 9, 8, "vector element shift left mem word" },
  { "vlvgf", OP48(0xe70000002022LL), MASK_VRS_VRRD, INSTR_VRS_VRRD, 2, 9, 8, "vector load VR word element from GR" },
  { "vlgvf", OP48(0xe70000002021LL), MASK_VRS_RVRD, INSTR_VRS_RVRD, 2, 9, 8, "vector load GR from VR word element" },
  { "vlrepf", OP48(0xe70000002005LL), MASK_VRX_VRRD, INSTR_VRX_VRRD, 2, 9, 8, "vector load and replicate word elements" },
  { "vllezf", OP48(0xe70000002004LL), MASK_VRX_VRRD, INSTR_VRX_VRRD, 2, 9, 8, "vector load logical word element and zero" },
  { "vmxh", OP48(0xe700000010ffLL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector maximum halfword" },
  { "vmnh", OP48(0xe700000010feLL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector minimum halfword" },
  { "vmxlh", OP48(0xe700000010fdLL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector maximum logical halfword" },
  { "vmnlh", OP48(0xe700000010fcLL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector minimum logical halfword" },
  { "vchh", OP48(0xe700000010fbLL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector compare high half word" },
  { "vchlh", OP48(0xe700000010f9LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector compare high logical half word" },
  { "vceqh", OP48(0xe700000010f8LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector compare equal half word" },
  { "vsh", OP48(0xe700000010f7LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector subtract halfword" },
  { "vscbih", OP48(0xe700000010f5LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector subtract compute borrow indication halfword" },
  { "vah", OP48(0xe700000010f3LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector add halfword" },
  { "vavgh", OP48(0xe700000010f2LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector average half word" },
  { "vacch", OP48(0xe700000010f1LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector add compute carry halfword" },
  { "vavglh", OP48(0xe700000010f0LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector average logical half word" },
  { "vlph", OP48(0xe700000010dfLL), MASK_VRR_VV, INSTR_VRR_VV, 2, 9, 8, "vector load positive halfword" },
  { "vlch", OP48(0xe700000010deLL), MASK_VRR_VV, INSTR_VRR_VV, 2, 9, 8, "vector load complement halfword" },
  { "vech", OP48(0xe700000010dbLL), MASK_VRR_VV, INSTR_VRR_VV, 2, 9, 8, "vector element compare half word" },
  { "veclh", OP48(0xe700000010d9LL), MASK_VRR_VV, INSTR_VRR_VV, 2, 9, 8, "vector element compare logical half word" },
  { "vuphh", OP48(0xe700000010d7LL), MASK_VRR_VV, INSTR_VRR_VV, 2, 9, 8, "vector unpack high halfword" },
  { "vuplhw", OP48(0xe700000010d6LL), MASK_VRR_VV, INSTR_VRR_VV, 2, 9, 8, "vector unpack low halfword" },
  { "vuplhh", OP48(0xe700000010d5LL), MASK_VRR_VV, INSTR_VRR_VV, 2, 9, 8, "vector unpack logical high halfword" },
  { "vupllh", OP48(0xe700000010d4LL), MASK_VRR_VV, INSTR_VRR_VV, 2, 9, 8, "vector unpack logical low halfword" },
  { "vgfmh", OP48(0xe700000010b4LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector galois field multiply sum halfword" },
  { "vmoh", OP48(0xe700000010a7LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector multiply odd halfword" },
  { "vmeh", OP48(0xe700000010a6LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector multiply even halfword" },
  { "vmloh", OP48(0xe700000010a5LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector multiply logical odd halfword" },
  { "vmleh", OP48(0xe700000010a4LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector multiply logical even halfword" },
  { "vmhh", OP48(0xe700000010a3LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector multiply high halfword" },
  { "vmlhw", OP48(0xe700000010a2LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector multiply low halfword" },
  { "vmlhh", OP48(0xe700000010a1LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector multiply logical high halfword" },
  { "vpksh", OP48(0xe70000001097LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector pack saturate halfword" },
  { "vpklsh", OP48(0xe70000001095LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector pack logical saturate halfword" },
  { "vpkh", OP48(0xe70000001094LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector pack halfword" },
  { "vfaeh", OP48(0xe70000001082LL), MASK_VRR_VVV0U0, INSTR_VRR_VVV0U0, 2, 9, 9, "vector find any element equal halfword" },
  { "vfeneh", OP48(0xe70000001081LL), MASK_VRR_VVV0U0, INSTR_VRR_VVV0U0, 2, 9, 9, "vector find element not equal halfword" },
  { "vfeeh", OP48(0xe70000001080LL), MASK_VRR_VVV0U0, INSTR_VRR_VVV0U0, 2, 9, 9, "vector find element equal halfword" },
  { "vesravh", OP48(0xe7000000107aLL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector element shift right arithmetic reg halfword" },
  { "vesrlvh", OP48(0xe70000001078LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector element shift right logical reg halfword" },
  { "verllvh", OP48(0xe70000001073LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector element rotate left logical reg halfword" },
  { "verimh", OP48(0xe70000001072LL), MASK_VRI_VVV0U, INSTR_VRI_VVV0U, 2, 9, 8, "vector element rotate and insert under mask halfword" },
  { "veslvh", OP48(0xe70000001070LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector element shift left reg halfword" },
  { "vsumgh", OP48(0xe70000001065LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector sum across doubleword - halfword" },
  { "vsumh", OP48(0xe70000001064LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector sum across word - halfword elements" },
  { "vmrhh", OP48(0xe70000001061LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector merge high halfword" },
  { "vmrlh", OP48(0xe70000001060LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector merge low halfword" },
  { "vsegh", OP48(0xe7000000105fLL), MASK_VRR_VV, INSTR_VRR_VV, 2, 9, 8, "vector sign extend halfword to double word" },
  { "vistrh", OP48(0xe7000000105cLL), MASK_VRR_VV0U2, INSTR_VRR_VV0U2, 2, 9, 9, "vector isolate string halfword" },
  { "vgemh", OP48(0xe70000001054LL), MASK_VRR_VV, INSTR_VRR_VV, 2, 13, 0, "vector generate element masks halfword" },
  { "vclzh", OP48(0xe70000001053LL), MASK_VRR_VV, INSTR_VRR_VV, 2, 9, 8, "vector count leading zeros halfword" },
  { "vctzh", OP48(0xe70000001052LL), MASK_VRR_VV, INSTR_VRR_VV, 2, 9, 8, "vector count trailing zeros halfword" },
  { "vpopcth", OP48(0xe70000001050LL), MASK_VRR_VV, INSTR_VRR_VV, 2, 10, 0, "vector population count halfword" },
  { "vreph", OP48(0xe7000000104dLL), MASK_VRI_VVU, INSTR_VRI_VVU, 2, 9, 8, "vector replicate halfword" },
  { "vgmh", OP48(0xe70000001046LL), MASK_VRI_V0UU, INSTR_VRI_V0UU, 2, 9, 8, "vector generate mask halfword" },
  { "vrepih", OP48(0xe70000001045LL), MASK_VRI_V0I, INSTR_VRI_V0I, 2, 9, 8, "vector replicate immediate halfword" },
  { "vesrah", OP48(0xe7000000103aLL), MASK_VRS_VVRD, INSTR_VRS_VVRD, 2, 9, 8, "vector element shift right arithmetic mem halfword" },
  { "vesrlh", OP48(0xe70000001038LL), MASK_VRS_VVRD, INSTR_VRS_VVRD, 2, 9, 8, "vector element shift right logical mem halfword" },
  { "verllh", OP48(0xe70000001033LL), MASK_VRS_VVRD, INSTR_VRS_VVRD, 2, 9, 8, "vector element rotate left logical mem halfword" },
  { "veslh", OP48(0xe70000001030LL), MASK_VRS_VVRD, INSTR_VRS_VVRD, 2, 9, 8, "vector element shift left mem halfword" },
  { "vlvgh", OP48(0xe70000001022LL), MASK_VRS_VRRD, INSTR_VRS_VRRD, 2, 9, 8, "vector load VR halfword element from GR" },
  { "vlgvh", OP48(0xe70000001021LL), MASK_VRS_RVRD, INSTR_VRS_RVRD, 2, 9, 8, "vector load GR from VR halfword element" },
  { "vlreph", OP48(0xe70000001005LL), MASK_VRX_VRRD, INSTR_VRX_VRRD, 2, 9, 8, "vector load and replicate halfword elements" },
  { "vllezh", OP48(0xe70000001004LL), MASK_VRX_VRRD, INSTR_VRX_VRRD, 2, 9, 8, "vector load logical halfword element and zero" },
  { "vmx", OP48(0xe700000000ffLL), MASK_VRR_VVV0U, INSTR_VRR_VVV0U, 2, 9, 8, "vector maximum" },
  { "vmxb", OP48(0xe700000000ffLL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector maximum byte" },
  { "vmn", OP48(0xe700000000feLL), MASK_VRR_VVV0U, INSTR_VRR_VVV0U, 2, 9, 8, "vector minimum" },
  { "vmnb", OP48(0xe700000000feLL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector minimum byte" },
  { "vmxl", OP48(0xe700000000fdLL), MASK_VRR_VVV0U, INSTR_VRR_VVV0U, 2, 9, 8, "vector maximum logical" },
  { "vmxlb", OP48(0xe700000000fdLL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector maximum logical byte" },
  { "vmnl", OP48(0xe700000000fcLL), MASK_VRR_VVV0U, INSTR_VRR_VVV0U, 2, 9, 8, "vector minimum logical" },
  { "vmnlb", OP48(0xe700000000fcLL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector minimum logical byte" },
  { "vch", OP48(0xe700000000fbLL), MASK_VRR_VVV0U0U, INSTR_VRR_VVV0U0U, 2, 9, 8, "vector compare high" },
  { "vchb", OP48(0xe700000000fbLL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector compare high byte" },
  { "vchl", OP48(0xe700000000f9LL), MASK_VRR_VVV0U0U, INSTR_VRR_VVV0U0U, 2, 9, 8, "vector compare high logical" },
  { "vchlb", OP48(0xe700000000f9LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector compare high logical byte" },
  { "vceq", OP48(0xe700000000f8LL), MASK_VRR_VVV0U0U, INSTR_VRR_VVV0U0U, 2, 9, 8, "vector compare equal" },
  { "vceqb", OP48(0xe700000000f8LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector compare equal byte" },
  { "vs", OP48(0xe700000000f7LL), MASK_VRR_VVV0U, INSTR_VRR_VVV0U, 2, 9, 8, "vector subtract" },
  { "vsb", OP48(0xe700000000f7LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector subtract byte" },
  { "vscbi", OP48(0xe700000000f5LL), MASK_VRR_VVV0U, INSTR_VRR_VVV0U, 2, 9, 8, "vector subtract compute borrow indication" },
  { "vscbib", OP48(0xe700000000f5LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector subtract compute borrow indication byte" },
  { "va", OP48(0xe700000000f3LL), MASK_VRR_VVV0U, INSTR_VRR_VVV0U, 2, 9, 8, "vector add" },
  { "vab", OP48(0xe700000000f3LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector add byte" },
  { "vavg", OP48(0xe700000000f2LL), MASK_VRR_VVV0U, INSTR_VRR_VVV0U, 2, 9, 8, "vector average" },
  { "vavgb", OP48(0xe700000000f2LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector average byte" },
  { "vacc", OP48(0xe700000000f1LL), MASK_VRR_VVV0U, INSTR_VRR_VVV0U, 2, 9, 8, "vector add compute carry" },
  { "vaccb", OP48(0xe700000000f1LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector add compute carry byte" },
  { "vavgl", OP48(0xe700000000f0LL), MASK_VRR_VVV0U, INSTR_VRR_VVV0U, 2, 9, 8, "vector average logical" },
  { "vavglb", OP48(0xe700000000f0LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector average logical byte" },
  { "vfmax", OP48(0xe700000000efLL), MASK_VRR_VVV0UUU, INSTR_VRR_VVV0UUU, 2, 10, 0, "vector fp maximum" },
  { "vfmin", OP48(0xe700000000eeLL), MASK_VRR_VVV0UUU, INSTR_VRR_VVV0UUU, 2, 10, 0, "vector fp minimum" },
  { "vfch", OP48(0xe700000000ebLL), MASK_VRR_VVV0UUU, INSTR_VRR_VVV0UUU, 2, 9, 8, "vector fp compare high" },
  { "vfche", OP48(0xe700000000eaLL), MASK_VRR_VVV0UUU, INSTR_VRR_VVV0UUU, 2, 9, 8, "vector fp compare high or equal" },
  { "vfce", OP48(0xe700000000e8LL), MASK_VRR_VVV0UUU, INSTR_VRR_VVV0UUU, 2, 9, 8, "vector fp compare equal" },
  { "vfm", OP48(0xe700000000e7LL), MASK_VRR_VVV0UU, INSTR_VRR_VVV0UU, 2, 9, 8, "vector fp multiply" },
  { "vfd", OP48(0xe700000000e5LL), MASK_VRR_VVV0UU, INSTR_VRR_VVV0UU, 2, 9, 8, "vector fp divide" },
  { "vfa", OP48(0xe700000000e3LL), MASK_VRR_VVV0UU, INSTR_VRR_VVV0UU, 2, 9, 8, "vector fp add" },
  { "vfs", OP48(0xe700000000e2LL), MASK_VRR_VVV0UU, INSTR_VRR_VVV0UU, 2, 9, 8, "vector fp subtract" },
  { "vlp", OP48(0xe700000000dfLL), MASK_VRR_VV0U, INSTR_VRR_VV0U, 2, 9, 8, "vector load positive" },
  { "vlpb", OP48(0xe700000000dfLL), MASK_VRR_VV, INSTR_VRR_VV, 2, 9, 8, "vector load positive byte" },
  { "vlc", OP48(0xe700000000deLL), MASK_VRR_VV0U, INSTR_VRR_VV0U, 2, 9, 8, "vector load complement" },
  { "vlcb", OP48(0xe700000000deLL), MASK_VRR_VV, INSTR_VRR_VV, 2, 9, 8, "vector load complement byte" },
  { "vec", OP48(0xe700000000dbLL), MASK_VRR_VV0U, INSTR_VRR_VV0U, 2, 9, 8, "vector element compare" },
  { "vecb", OP48(0xe700000000dbLL), MASK_VRR_VV, INSTR_VRR_VV, 2, 9, 8, "vector element compare byte" },
  { "vecl", OP48(0xe700000000d9LL), MASK_VRR_VV0U, INSTR_VRR_VV0U, 2, 9, 8, "vector element compare logical" },
  { "veclb", OP48(0xe700000000d9LL), MASK_VRR_VV, INSTR_VRR_VV, 2, 9, 8, "vector element compare logical byte" },
  { "vtm", OP48(0xe700000000d8LL), MASK_VRR_VV, INSTR_VRR_VV, 2, 9, 8, "vector test under mask" },
  { "vuph", OP48(0xe700000000d7LL), MASK_VRR_VV0U, INSTR_VRR_VV0U, 2, 9, 8, "vector unpack high" },
  { "vuphb", OP48(0xe700000000d7LL), MASK_VRR_VV, INSTR_VRR_VV, 2, 9, 8, "vector unpack high byte" },
  { "vupl", OP48(0xe700000000d6LL), MASK_VRR_VV0U, INSTR_VRR_VV0U, 2, 9, 8, "vector unpack low" },
  { "vuplb", OP48(0xe700000000d6LL), MASK_VRR_VV, INSTR_VRR_VV, 2, 9, 8, "vector unpack low byte" },
  { "vuplh", OP48(0xe700000000d5LL), MASK_VRR_VV0U, INSTR_VRR_VV0U, 2, 9, 8, "vector unpack logical high" },
  { "vuplhb", OP48(0xe700000000d5LL), MASK_VRR_VV, INSTR_VRR_VV, 2, 9, 8, "vector unpack logical high byte" },
  { "vupll", OP48(0xe700000000d4LL), MASK_VRR_VV0U, INSTR_VRR_VV0U, 2, 9, 8, "vector unpack logical low" },
  { "vupllb", OP48(0xe700000000d4LL), MASK_VRR_VV, INSTR_VRR_VV, 2, 9, 8, "vector unpack logical low byte" },
  { "vfsq", OP48(0xe700000000ceLL), MASK_VRR_VV0UU2, INSTR_VRR_VV0UU2, 2, 9, 8, "vector fp square root" },
  { "vfpso", OP48(0xe700000000ccLL), MASK_VRR_VV0UUU, INSTR_VRR_VV0UUU, 2, 9, 8, "vector fp perform sign operation" },
  { "wfc", OP48(0xe700000000cbLL), MASK_VRR_VV0UU2, INSTR_VRR_VV0UU2, 2, 9, 8, "vector fp compare scalar" },
  { "wfk", OP48(0xe700000000caLL), MASK_VRR_VV0UU2, INSTR_VRR_VV0UU2, 2, 9, 8, "vector fp compare and signal scalar" },
  { "vfi", OP48(0xe700000000c7LL), MASK_VRR_VV0UUU, INSTR_VRR_VV0UUU, 2, 9, 8, "vector load fp integer" },
  { "vflr", OP48(0xe700000000c5LL), MASK_VRR_VV0UUU, INSTR_VRR_VV0UUU, 2, 10, 0, "vector fp load rounded" },
  { "vled", OP48(0xe700000000c5LL), MASK_VRR_VV0UUU, INSTR_VRR_VV0UUU, 2, 9, 8, "vector fp load rounded" },
  { "vfll", OP48(0xe700000000c4LL), MASK_VRR_VV0UU2, INSTR_VRR_VV0UU2, 2, 10, 0, "vector fp load lengthened" },
  { "vlde", OP48(0xe700000000c4LL), MASK_VRR_VV0UU2, INSTR_VRR_VV0UU2, 2, 9, 8, "vector fp load lengthened" },
  { "vcfps", OP48(0xe700000000c3LL), MASK_VRR_VV0UUU, INSTR_VRR_VV0UUU, 2, 11, 0, "vector fp convert from fixed" },
  { "vcdg", OP48(0xe700000000c3LL), MASK_VRR_VV0UUU, INSTR_VRR_VV0UUU, 2, 9, 8, "vector fp convert from fixed 64 bit" },
  { "vcsfp", OP48(0xe700000000c2LL), MASK_VRR_VV0UUU, INSTR_VRR_VV0UUU, 2, 11, 0, "vector fp convert to fixed" },
  { "vcgd", OP48(0xe700000000c2LL), MASK_VRR_VV0UUU, INSTR_VRR_VV0UUU, 2, 9, 8, "vector fp convert to fixed 64 bit" },
  { "vcfpl", OP48(0xe700000000c1LL), MASK_VRR_VV0UUU, INSTR_VRR_VV0UUU, 2, 11, 0, "vector fp convert from logical" },
  { "vcdlg", OP48(0xe700000000c1LL), MASK_VRR_VV0UUU, INSTR_VRR_VV0UUU, 2, 9, 8, "vector fp convert from logical 64 bit" },
  { "vclfp", OP48(0xe700000000c0LL), MASK_VRR_VV0UUU, INSTR_VRR_VV0UUU, 2, 11, 0, "vector fp convert to logical" },
  { "vclgd", OP48(0xe700000000c0LL), MASK_VRR_VV0UUU, INSTR_VRR_VV0UUU, 2, 9, 8, "vector fp convert to logical 64 bit" },
  { "vsbi", OP48(0xe700000000bfLL), MASK_VRR_VVVU0V, INSTR_VRR_VVVU0V, 2, 9, 8, "vector subtract with borrow indication" },
  { "vsbcbi", OP48(0xe700000000bdLL), MASK_VRR_VVVU0V, INSTR_VRR_VVVU0V, 2, 9, 8, "vector subtract with borrow compute borrow indication" },
  { "vgfma", OP48(0xe700000000bcLL), MASK_VRR_VVVU0V, INSTR_VRR_VVVU0V, 2, 9, 8, "vector galois field multiply sum and accumulate" },
  { "vgfmab", OP48(0xe700000000bcLL), MASK_VRR_VVV0V, INSTR_VRR_VVV0V, 2, 9, 8, "vector galois field multiply sum and accumulate byte" },
  { "vac", OP48(0xe700000000bbLL), MASK_VRR_VVVU0V, INSTR_VRR_VVVU0V, 2, 9, 8, "vector add with carry" },
  { "vaccc", OP48(0xe700000000b9LL), MASK_VRR_VVVU0V, INSTR_VRR_VVVU0V, 2, 9, 8, "vector add with carry compute carry" },
  { "vmsl", OP48(0xe700000000b8LL), MASK_VRR_VVVUU0V, INSTR_VRR_VVVUU0V, 2, 10, 0, "vector multiply sum logical" },
  { "vgfm", OP48(0xe700000000b4LL), MASK_VRR_VVV0U, INSTR_VRR_VVV0U, 2, 9, 8, "vector galois field multiply sum" },
  { "vgfmb", OP48(0xe700000000b4LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector galois field multiply sum byte" },
  { "vr", OP48(0xe700000000b3LL), MASK_VRR_VVV0UU, INSTR_VRR_VVV0UU, 2, 13, 0, "vector remainder" },
  { "vd", OP48(0xe700000000b2LL), MASK_VRR_VVV0UU, INSTR_VRR_VVV0UU, 2, 13, 0, "vector divide" },
  { "vrl", OP48(0xe700000000b1LL), MASK_VRR_VVV0UU, INSTR_VRR_VVV0UU, 2, 13, 0, "vector remainder logical" },
  { "vdl", OP48(0xe700000000b0LL), MASK_VRR_VVV0UU, INSTR_VRR_VVV0UU, 2, 13, 0, "vector divide logical" },
  { "vmao", OP48(0xe700000000afLL), MASK_VRR_VVVU0V, INSTR_VRR_VVVU0V, 2, 9, 8, "vector multiply and add odd" },
  { "vmaob", OP48(0xe700000000afLL), MASK_VRR_VVV0V, INSTR_VRR_VVV0V, 2, 9, 8, "vector multiply and add odd byte" },
  { "vmae", OP48(0xe700000000aeLL), MASK_VRR_VVVU0V, INSTR_VRR_VVVU0V, 2, 9, 8, "vector multiply and add even" },
  { "vmaeb", OP48(0xe700000000aeLL), MASK_VRR_VVV0V, INSTR_VRR_VVV0V, 2, 9, 8, "vector multiply and add even byte" },
  { "vmalo", OP48(0xe700000000adLL), MASK_VRR_VVVU0V, INSTR_VRR_VVVU0V, 2, 9, 8, "vector multiply and add logical odd" },
  { "vmalob", OP48(0xe700000000adLL), MASK_VRR_VVV0V, INSTR_VRR_VVV0V, 2, 9, 8, "vector multiply and add logical odd byte" },
  { "vmale", OP48(0xe700000000acLL), MASK_VRR_VVVU0V, INSTR_VRR_VVVU0V, 2, 9, 8, "vector multiply and add logical even" },
  { "vmaleb", OP48(0xe700000000acLL), MASK_VRR_VVV0V, INSTR_VRR_VVV0V, 2, 9, 8, "vector multiply and add logical even byte" },
  { "vmah", OP48(0xe700000000abLL), MASK_VRR_VVVU0V, INSTR_VRR_VVVU0V, 2, 9, 8, "vector multiply and add high" },
  { "vmahb", OP48(0xe700000000abLL), MASK_VRR_VVV0V, INSTR_VRR_VVV0V, 2, 9, 8, "vector multiply and add high byte" },
  { "vmal", OP48(0xe700000000aaLL), MASK_VRR_VVVU0V, INSTR_VRR_VVVU0V, 2, 9, 8, "vector multiply and add low" },
  { "vmalb", OP48(0xe700000000aaLL), MASK_VRR_VVV0V, INSTR_VRR_VVV0V, 2, 9, 8, "vector multiply and add low byte" },
  { "vmalh", OP48(0xe700000000a9LL), MASK_VRR_VVVU0V, INSTR_VRR_VVVU0V, 2, 9, 8, "vector multiply and add logical high" },
  { "vmalhb", OP48(0xe700000000a9LL), MASK_VRR_VVV0V, INSTR_VRR_VVV0V, 2, 9, 8, "vector multiply and add logical high byte" },
  { "vmo", OP48(0xe700000000a7LL), MASK_VRR_VVV0U, INSTR_VRR_VVV0U, 2, 9, 8, "vector multiply odd" },
  { "vmob", OP48(0xe700000000a7LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector multiply odd byte" },
  { "vme", OP48(0xe700000000a6LL), MASK_VRR_VVV0U, INSTR_VRR_VVV0U, 2, 9, 8, "vector multiply even" },
  { "vmeb", OP48(0xe700000000a6LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector multiply even byte" },
  { "vmlo", OP48(0xe700000000a5LL), MASK_VRR_VVV0U, INSTR_VRR_VVV0U, 2, 9, 8, "vector multiply logical odd" },
  { "vmlob", OP48(0xe700000000a5LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector multiply logical odd byte" },
  { "vmle", OP48(0xe700000000a4LL), MASK_VRR_VVV0U, INSTR_VRR_VVV0U, 2, 9, 8, "vector multiply logical even" },
  { "vmleb", OP48(0xe700000000a4LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector multiply logical even byte" },
  { "vmh", OP48(0xe700000000a3LL), MASK_VRR_VVV0U, INSTR_VRR_VVV0U, 2, 9, 8, "vector multiply high" },
  { "vmhb", OP48(0xe700000000a3LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector multiply high byte" },
  { "vml", OP48(0xe700000000a2LL), MASK_VRR_VVV0U, INSTR_VRR_VVV0U, 2, 9, 8, "vector multiply low" },
  { "vmlb", OP48(0xe700000000a2LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector multiply low byte" },
  { "vmlh", OP48(0xe700000000a1LL), MASK_VRR_VVV0U, INSTR_VRR_VVV0U, 2, 9, 8, "vector multiply logical high" },
  { "vmlhb", OP48(0xe700000000a1LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector multiply logical high byte" },
  { "vfnma", OP48(0xe7000000009fLL), MASK_VRR_VVVU0UV, INSTR_VRR_VVVU0UV, 2, 10, 0, "vector fp negative multiply and add" },
  { "vfnms", OP48(0xe7000000009eLL), MASK_VRR_VVVU0UV, INSTR_VRR_VVVU0UV, 2, 10, 0, "vector fp negative multiply and subtract" },
  { "vpks", OP48(0xe70000000097LL), MASK_VRR_VVV0U0U, INSTR_VRR_VVV0U0U, 2, 9, 8, "vector pack saturate" },
  { "vpkls", OP48(0xe70000000095LL), MASK_VRR_VVV0U0U, INSTR_VRR_VVV0U0U, 2, 9, 8, "vector pack logical saturate" },
  { "vpk", OP48(0xe70000000094LL), MASK_VRR_VVV0U, INSTR_VRR_VVV0U, 2, 9, 8, "vector pack" },
  { "vfma", OP48(0xe7000000008fLL), MASK_VRR_VVVU0UV, INSTR_VRR_VVVU0UV, 2, 9, 8, "vector fp multiply and add" },
  { "vfms", OP48(0xe7000000008eLL), MASK_VRR_VVVU0UV, INSTR_VRR_VVVU0UV, 2, 9, 8, "vector fp multiply and subtract" },
  { "vsel", OP48(0xe7000000008dLL), MASK_VRR_VVV0V, INSTR_VRR_VVV0V, 2, 9, 8, "vector select" },
  { "vperm", OP48(0xe7000000008cLL), MASK_VRR_VVV0V, INSTR_VRR_VVV0V, 2, 9, 8, "vector permute" },
  { "vstrs", OP48(0xe7000000008bLL), MASK_VRR_VVVUU0V, INSTR_VRR_VVVUU0V, 2, 11, 1, "vector string search" },
  { "vstrsb", OP48(0xe7000000008bLL), MASK_VRR_VVVU0VB, INSTR_VRR_VVVU0VB, 2, 11, 1, "vector string search byte" },
  { "vstrc", OP48(0xe7000000008aLL), MASK_VRR_VVVUU0V, INSTR_VRR_VVVUU0V, 2, 9, 9, "vector string range compare" },
  { "vstrcb", OP48(0xe7000000008aLL), MASK_VRR_VVVU0VB, INSTR_VRR_VVVU0VB, 2, 9, 9, "vector string range compare byte" },
  { "vblend", OP48(0xe70000000089LL), MASK_VRR_VVVU0V, INSTR_VRR_VVVU0V, 2, 13, 0, "vector blend" },
  { "vblendb", OP48(0xe70000000089LL), MASK_VRR_VVV0V, INSTR_VRR_VVV0V, 2, 13, 0, "vector blend byte" },
  { "veval", OP48(0xe70000000088LL), MASK_VRI_VVV0UV, INSTR_VRI_VVV0UV, 2, 13, 0, "vector evaluate" },
  { "vsrd", OP48(0xe70000000087LL), MASK_VRI_VVV0U, INSTR_VRI_VVV0U, 2, 11, 0, "vector shift right double by bit" },
  { "vsld", OP48(0xe70000000086LL), MASK_VRI_VVV0U, INSTR_VRI_VVV0U, 2, 11, 0, "vector shift left double by bit" },
  { "vbperm", OP48(0xe70000000085LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 10, 0, "vector bit permute" },
  { "vpdi", OP48(0xe70000000084LL), MASK_VRR_VVV0U, INSTR_VRR_VVV0U, 2, 9, 8, "vector permute double word immediate" },
  { "vfae", OP48(0xe70000000082LL), MASK_VRR_VVV0U0U, INSTR_VRR_VVV0U0U, 2, 9, 9, "vector find any element equal" },
  { "vfaeb", OP48(0xe70000000082LL), MASK_VRR_VVV0U0, INSTR_VRR_VVV0U0, 2, 9, 9, "vector find any element equal byte" },
  { "vfene", OP48(0xe70000000081LL), MASK_VRR_VVV0U0U, INSTR_VRR_VVV0U0U, 2, 9, 9, "vector find element not equal" },
  { "vfeneb", OP48(0xe70000000081LL), MASK_VRR_VVV0U0, INSTR_VRR_VVV0U0, 2, 9, 9, "vector find element not equal byte" },
  { "vfee", OP48(0xe70000000080LL), MASK_VRR_VVV0U0U, INSTR_VRR_VVV0U0U, 2, 9, 9, "vector find element equal" },
  { "vfeeb", OP48(0xe70000000080LL), MASK_VRR_VVV0U0, INSTR_VRR_VVV0U0, 2, 9, 9, "vector find element equal byte" },
  { "vsrab", OP48(0xe7000000007fLL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector shift right arithmetic by byte" },
  { "vsra", OP48(0xe7000000007eLL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector shift right arithmetic" },
  { "vsrlb", OP48(0xe7000000007dLL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector shift right logical by byte" },
  { "vsrl", OP48(0xe7000000007cLL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector shift right logical" },
  { "vesrav", OP48(0xe7000000007aLL), MASK_VRR_VVV0U, INSTR_VRR_VVV0U, 2, 9, 8, "vector element shift right arithmetic reg" },
  { "vesravb", OP48(0xe7000000007aLL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector element shift right arithmetic reg byte" },
  { "vesrlv", OP48(0xe70000000078LL), MASK_VRR_VVV0U, INSTR_VRR_VVV0U, 2, 9, 8, "vector element shift right logical reg" },
  { "vesrlvb", OP48(0xe70000000078LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector element shift right logical reg byte" },
  { "vsldb", OP48(0xe70000000077LL), MASK_VRI_VVV0U, INSTR_VRI_VVV0U, 2, 9, 8, "vector shift left double by byte" },
  { "vslb", OP48(0xe70000000075LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector shift left by byte" },
  { "vsl", OP48(0xe70000000074LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector shift left" },
  { "verllv", OP48(0xe70000000073LL), MASK_VRR_VVV0U, INSTR_VRR_VVV0U, 2, 9, 8, "vector element rotate left logical reg" },
  { "verllvb", OP48(0xe70000000073LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector element rotate left logical reg byte" },
  { "verim", OP48(0xe70000000072LL), MASK_VRI_VVV0UU, INSTR_VRI_VVV0UU, 2, 9, 8, "vector element rotate and insert under mask" },
  { "verimb", OP48(0xe70000000072LL), MASK_VRI_VVV0U, INSTR_VRI_VVV0U, 2, 9, 8, "vector element rotate and insert under mask byte" },
  { "veslv", OP48(0xe70000000070LL), MASK_VRR_VVV0U, INSTR_VRR_VVV0U, 2, 9, 8, "vector element shift left reg" },
  { "veslvb", OP48(0xe70000000070LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector element shift left reg byte" },
  { "voc", OP48(0xe7000000006fLL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 10, 0, "vector or with complement" },
  { "vnn", OP48(0xe7000000006eLL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 10, 0, "vector nand" },
  { "vx", OP48(0xe7000000006dLL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector exclusive or" },
  { "vnx", OP48(0xe7000000006cLL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 10, 0, "vector not exclusive or" },
  { "vno", OP48(0xe7000000006bLL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector nor" },
  { "vnot", OP48(0xe7000000006bLL), MASK_VRR_VVV2, INSTR_VRR_VVV2, 2, 9, 8, "vector not" },
  { "vo", OP48(0xe7000000006aLL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector or" },
  { "vnc", OP48(0xe70000000069LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector and with complement" },
  { "vn", OP48(0xe70000000068LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector and" },
  { "vsumq", OP48(0xe70000000067LL), MASK_VRR_VVV0U, INSTR_VRR_VVV0U, 2, 9, 8, "vector sum across quadword" },
  { "vcksm", OP48(0xe70000000066LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector checksum" },
  { "vsumg", OP48(0xe70000000065LL), MASK_VRR_VVV0U, INSTR_VRR_VVV0U, 2, 9, 8, "vector sum across doubleword" },
  { "vsum", OP48(0xe70000000064LL), MASK_VRR_VVV0U, INSTR_VRR_VVV0U, 2, 9, 8, "vector sum across word" },
  { "vsumb", OP48(0xe70000000064LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector sum across word - byte elements" },
  { "vlvgp", OP48(0xe70000000062LL), MASK_VRR_VRR, INSTR_VRR_VRR, 2, 9, 8, "vector load VR from GRs disjoint" },
  { "vmrh", OP48(0xe70000000061LL), MASK_VRR_VVV0U, INSTR_VRR_VVV0U, 2, 9, 8, "vector merge high" },
  { "vmrhb", OP48(0xe70000000061LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector merge high byte" },
  { "vmrl", OP48(0xe70000000060LL), MASK_VRR_VVV0U, INSTR_VRR_VVV0U, 2, 9, 8, "vector merge low" },
  { "vmrlb", OP48(0xe70000000060LL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 9, 8, "vector merge low byte" },
  { "vseg", OP48(0xe7000000005fLL), MASK_VRR_VV0U, INSTR_VRR_VV0U, 2, 9, 8, "vector sign extend to double word" },
  { "vsegb", OP48(0xe7000000005fLL), MASK_VRR_VV, INSTR_VRR_VV, 2, 9, 8, "vector sign extend byte to double word" },
  { "vistr", OP48(0xe7000000005cLL), MASK_VRR_VV0U0U, INSTR_VRR_VV0U0U, 2, 9, 9, "vector isolate string" },
  { "vistrb", OP48(0xe7000000005cLL), MASK_VRR_VV0U2, INSTR_VRR_VV0U2, 2, 9, 9, "vector isolate string byte" },
  { "vlr", OP48(0xe70000000056LL), MASK_VRX_VV, INSTR_VRX_VV, 2, 9, 8, "vector register load" },
  { "vgem", OP48(0xe70000000054LL), MASK_VRR_VV0U, INSTR_VRR_VV0U, 2, 13, 0, "vector generate element masks" },
  { "vgemb", OP48(0xe70000000054LL), MASK_VRR_VV, INSTR_VRR_VV, 2, 13, 0, "vector generate element masks byte" },
  { "vclz", OP48(0xe70000000053LL), MASK_VRR_VV0U, INSTR_VRR_VV0U, 2, 9, 8, "vector count leading zeros" },
  { "vclzb", OP48(0xe70000000053LL), MASK_VRR_VV, INSTR_VRR_VV, 2, 9, 8, "vector count leading zeros byte" },
  { "vctz", OP48(0xe70000000052LL), MASK_VRR_VV0U, INSTR_VRR_VV0U, 2, 9, 8, "vector count trailing zeros" },
  { "vctzb", OP48(0xe70000000052LL), MASK_VRR_VV, INSTR_VRR_VV, 2, 9, 8, "vector count trailing zeros byte" },
  { "vpopctb", OP48(0xe70000000050LL), MASK_VRR_VV, INSTR_VRR_VV, 2, 10, 0, "vector population count byte" },
  { "vpopct", OP48(0xe70000000050LL), MASK_VRR_VV0U, INSTR_VRR_VV0U, 2, 9, 8, "vector population count" },
  { "vrep", OP48(0xe7000000004dLL), MASK_VRI_VVUU, INSTR_VRI_VVUU, 2, 9, 8, "vector replicate" },
  { "vrepb", OP48(0xe7000000004dLL), MASK_VRI_VVU, INSTR_VRI_VVU, 2, 9, 8, "vector replicate byte" },
  { "vftci", OP48(0xe7000000004aLL), MASK_VRI_VVUUU, INSTR_VRI_VVUUU, 2, 9, 8, "vector fp test data class immediate" },
  { "vgm", OP48(0xe70000000046LL), MASK_VRI_V0UUU, INSTR_VRI_V0UUU, 2, 9, 8, "vector generate mask" },
  { "vgmb", OP48(0xe70000000046LL), MASK_VRI_V0UU, INSTR_VRI_V0UU, 2, 9, 8, "vector generate mask byte" },
  { "vrepi", OP48(0xe70000000045LL), MASK_VRI_V0IU, INSTR_VRI_V0IU, 2, 9, 8, "vector replicate immediate" },
  { "vrepib", OP48(0xe70000000045LL), MASK_VRI_V0I, INSTR_VRI_V0I, 2, 9, 8, "vector replicate immediate byte" },
  { "vgbm", OP48(0xe70000000044LL), MASK_VRI_V0U, INSTR_VRI_V0U, 2, 9, 8, "vector generate byte mask" },
  { "vzero", OP48(0xe70000000044LL), MASK_VRI_V, INSTR_VRI_V, 2, 9, 8, "vector set to zero" },
  { "vleif", OP48(0xe70000000043LL), MASK_VRI_V0IU, INSTR_VRI_V0IU, 2, 9, 8, "vector load word element immediate" },
  { "vleig", OP48(0xe70000000042LL), MASK_VRI_V0IU, INSTR_VRI_V0IU, 2, 9, 8, "vector load double word element immediate" },
  { "vleih", OP48(0xe70000000041LL), MASK_VRI_V0IU, INSTR_VRI_V0IU, 2, 9, 8, "vector load halfword element immediate" },
  { "vleib", OP48(0xe70000000040LL), MASK_VRI_V0IU, INSTR_VRI_V0IU, 2, 9, 8, "vector load byte element immediate" },
  { "vstl", OP48(0xe7000000003fLL), MASK_VRS_VRRD, INSTR_VRS_VRRD, 2, 9, 8, "vector store with length" },
  { "vstm", OP48(0xe7000000003eLL), MASK_VRS_VVRDU, INSTR_VRS_VVRDU, 2, 9, 9, "vector store multiple" },
  { "vesra", OP48(0xe7000000003aLL), MASK_VRS_VVRDU, INSTR_VRS_VVRDU, 2, 9, 8, "vector element shift right arithmetic mem" },
  { "vesrab", OP48(0xe7000000003aLL), MASK_VRS_VVRD, INSTR_VRS_VVRD, 2, 9, 8, "vector element shift right arithmetic mem byte" },
  { "vesrl", OP48(0xe70000000038LL), MASK_VRS_VVRDU, INSTR_VRS_VVRDU, 2, 9, 8, "vector element shift right logical mem" },
  { "vesrlb", OP48(0xe70000000038LL), MASK_VRS_VVRD, INSTR_VRS_VVRD, 2, 9, 8, "vector element shift right logical mem byte" },
  { "vll", OP48(0xe70000000037LL), MASK_VRS_VRRD, INSTR_VRS_VRRD, 2, 9, 8, "vector load with length" },
  { "vlm", OP48(0xe70000000036LL), MASK_VRS_VVRDU, INSTR_VRS_VVRDU, 2, 9, 9, "vector load multiple" },
  { "verll", OP48(0xe70000000033LL), MASK_VRS_VVRDU, INSTR_VRS_VVRDU, 2, 9, 8, "vector element rotate left logical mem" },
  { "verllb", OP48(0xe70000000033LL), MASK_VRS_VVRD, INSTR_VRS_VVRD, 2, 9, 8, "vector element rotate left logical mem byte" },
  { "vesl", OP48(0xe70000000030LL), MASK_VRS_VVRDU, INSTR_VRS_VVRDU, 2, 9, 8, "vector element shift left mem" },
  { "veslb", OP48(0xe70000000030LL), MASK_VRS_VVRD, INSTR_VRS_VVRD, 2, 9, 8, "vector element shift left mem byte" },
  { "lcbb", OP48(0xe70000000027LL), MASK_RXE_RRRDU, INSTR_RXE_RRRDU, 2, 9, 8, "load count to block boundary" },
  { "vlvg", OP48(0xe70000000022LL), MASK_VRS_VRRDU, INSTR_VRS_VRRDU, 2, 9, 8, "vector load VR element from GR" },
  { "vlvgb", OP48(0xe70000000022LL), MASK_VRS_VRRD, INSTR_VRS_VRRD, 2, 9, 8, "vector load VR byte element from GR" },
  { "vlgv", OP48(0xe70000000021LL), MASK_VRS_RVRDU, INSTR_VRS_RVRDU, 2, 9, 8, "vector load GR from VR element" },
  { "vlgvb", OP48(0xe70000000021LL), MASK_VRS_RVRD, INSTR_VRS_RVRD, 2, 9, 8, "vector load GR from VR byte element" },
  { "vscef", OP48(0xe7000000001bLL), MASK_VRV_VVXRDU, INSTR_VRV_VVXRDU, 2, 9, 8, "vector scatter element 4 byte" },
  { "vsceg", OP48(0xe7000000001aLL), MASK_VRV_VVXRDU, INSTR_VRV_VVXRDU, 2, 9, 8, "vector scatter element 8 byte" },
  { "vgef", OP48(0xe70000000013LL), MASK_VRV_VVXRDU, INSTR_VRV_VVXRDU, 2, 9, 8, "vector gather element 4 byte elements" },
  { "vgeg", OP48(0xe70000000012LL), MASK_VRV_VVXRDU, INSTR_VRV_VVXRDU, 2, 9, 8, "vector gather element 8 byte elements" },
  { "vst", OP48(0xe7000000000eLL), MASK_VRX_VRRDU, INSTR_VRX_VRRDU, 2, 9, 9, "vector store" },
  { "vstef", OP48(0xe7000000000bLL), MASK_VRX_VRRDU, INSTR_VRX_VRRDU, 2, 9, 8, "vector store word element" },
  { "vsteg", OP48(0xe7000000000aLL), MASK_VRX_VRRDU, INSTR_VRX_VRRDU, 2, 9, 8, "vector store double word element" },
  { "vsteh", OP48(0xe70000000009LL), MASK_VRX_VRRDU, INSTR_VRX_VRRDU, 2, 9, 8, "vector store halfword element" },
  { "vsteb", OP48(0xe70000000008LL), MASK_VRX_VRRDU, INSTR_VRX_VRRDU, 2, 9, 8, "vector store byte element" },
  { "vlbb", OP48(0xe70000000007LL), MASK_VRX_VRRDU, INSTR_VRX_VRRDU, 2, 9, 8, "vector load to block boundary" },
  { "vl", OP48(0xe70000000006LL), MASK_VRX_VRRDU, INSTR_VRX_VRRDU, 2, 9, 9, "vector memory load" },
  { "vlrep", OP48(0xe70000000005LL), MASK_VRX_VRRDU, INSTR_VRX_VRRDU, 2, 9, 8, "vector load and replicate" },
  { "vlrepb", OP48(0xe70000000005LL), MASK_VRX_VRRD, INSTR_VRX_VRRD, 2, 9, 8, "vector load and replicate byte elements" },
  { "vllez", OP48(0xe70000000004LL), MASK_VRX_VRRDU, INSTR_VRX_VRRDU, 2, 9, 8, "vector load logical element and zero" },
  { "vllezb", OP48(0xe70000000004LL), MASK_VRX_VRRD, INSTR_VRX_VRRD, 2, 9, 8, "vector load logical byte element and zero" },
  { "vlef", OP48(0xe70000000003LL), MASK_VRX_VRRDU, INSTR_VRX_VRRDU, 2, 9, 8, "vector load word element" },
  { "vleg", OP48(0xe70000000002LL), MASK_VRX_VRRDU, INSTR_VRX_VRRDU, 2, 9, 8, "vector load double word element" },
  { "vleh", OP48(0xe70000000001LL), MASK_VRX_VRRDU, INSTR_VRX_VRRDU, 2, 9, 8, "vector load halfword element" },
  { "vleb", OP48(0xe70000000000LL), MASK_VRX_VRRDU, INSTR_VRX_VRRDU, 2, 9, 8, "vector load byte element" },
  { "lerv", OP48(0xe60000006004LL), MASK_VRX_VRRD, INSTR_VRX_VRRD, 2, 11, 0, "load byte reversed word" },
  { "vllebrze", OP48(0xe60000006004LL), MASK_VRX_VRRD, INSTR_VRX_VRRD, 2, 11, 0, "vector load byte reversed word element left-aligned and zero" },
  { "vschxp", OP48(0xe60000004074LL), MASK_VRR_VVV0U0, INSTR_VRR_VVV0U0, 2, 12, 0, "decimal scale and convert to extended hfp" },
  { "vstbrq", OP48(0xe6000000400eLL), MASK_VRX_VRRD, INSTR_VRX_VRRD, 2, 11, 0, "vector store byte reversed quadword elements" },
  { "vlbrq", OP48(0xe60000004006LL), MASK_VRX_VRRD, INSTR_VRX_VRRD, 2, 11, 0, "vector load byte reversed quadword elements" },
  { "vschdp", OP48(0xe60000003074LL), MASK_VRR_VVV0U0, INSTR_VRR_VVV0U0, 2, 12, 0, "decimal scale and convert to long hfp" },
  { "vsterg", OP48(0xe6000000300fLL), MASK_VRX_VRRD, INSTR_VRX_VRRD, 2, 11, 0, "vector store doubleword elements reversed" },
  { "vstbrg", OP48(0xe6000000300eLL), MASK_VRX_VRRD, INSTR_VRX_VRRD, 2, 11, 0, "vector store byte reversed doubleword elements" },
  { "vlerg", OP48(0xe60000003007LL), MASK_VRX_VRRD, INSTR_VRX_VRRD, 2, 11, 0, "vector load doubleword elements reversed" },
  { "vlbrg", OP48(0xe60000003006LL), MASK_VRX_VRRD, INSTR_VRX_VRRD, 2, 11, 0, "vector load byte reversed doubleword elements" },
  { "vlbrrepg", OP48(0xe60000003005LL), MASK_VRX_VRRD, INSTR_VRX_VRRD, 2, 11, 0, "vector load byte reversed doubleword element and replicate" },
  { "ldrv", OP48(0xe60000003004LL), MASK_VRX_VRRD, INSTR_VRX_VRRD, 2, 11, 0, "load byte reversed doubleword" },
  { "vllebrzg", OP48(0xe60000003004LL), MASK_VRX_VRRD, INSTR_VRX_VRRD, 2, 11, 0, "vector load byte reversed doubleword element and zero" },
  { "vschsp", OP48(0xe60000002074LL), MASK_VRR_VVV0U0, INSTR_VRR_VVV0U0, 2, 12, 0, "decimal scale and convert to short hfp" },
  { "vsterf", OP48(0xe6000000200fLL), MASK_VRX_VRRD, INSTR_VRX_VRRD, 2, 11, 0, "vector store word elements reversed" },
  { "vstbrf", OP48(0xe6000000200eLL), MASK_VRX_VRRD, INSTR_VRX_VRRD, 2, 11, 0, "vector store byte reversed word elements" },
  { "vlerf", OP48(0xe60000002007LL), MASK_VRX_VRRD, INSTR_VRX_VRRD, 2, 11, 0, "vector load word elements reversed" },
  { "vlbrf", OP48(0xe60000002006LL), MASK_VRX_VRRD, INSTR_VRX_VRRD, 2, 11, 0, "vector load byte reversed word elements" },
  { "vlbrrepf", OP48(0xe60000002005LL), MASK_VRX_VRRD, INSTR_VRX_VRRD, 2, 11, 0, "vector load byte reversed word element and replicate" },
  { "vllebrzf", OP48(0xe60000002004LL), MASK_VRX_VRRD, INSTR_VRX_VRRD, 2, 11, 0, "vector load byte reversed word element and zero" },
  { "vsterh", OP48(0xe6000000100fLL), MASK_VRX_VRRD, INSTR_VRX_VRRD, 2, 11, 0, "vector store halfword elements reversed" },
  { "vstbrh", OP48(0xe6000000100eLL), MASK_VRX_VRRD, INSTR_VRX_VRRD, 2, 11, 0, "vector store byte reversed halfword elements" },
  { "vlerh", OP48(0xe60000001007LL), MASK_VRX_VRRD, INSTR_VRX_VRRD, 2, 11, 0, "vector load halfword elements reversed" },
  { "vlbrh", OP48(0xe60000001006LL), MASK_VRX_VRRD, INSTR_VRX_VRRD, 2, 11, 0, "vector load byte reversed halfword elements" },
  { "vlbrreph", OP48(0xe60000001005LL), MASK_VRX_VRRD, INSTR_VRX_VRRD, 2, 11, 0, "vector load byte reversed halfword element and replicate" },
  { "vllebrzh", OP48(0xe60000001004LL), MASK_VRX_VRRD, INSTR_VRX_VRRD, 2, 11, 0, "vector load byte reversed halfword element and zero" },
  { "vtz", OP48(0xe6000000007fLL), MASK_VRR_0VVU, INSTR_VRR_0VVU, 2, 13, 0, "vector test zoned" },
  { "vsdp", OP48(0xe6000000007eLL), MASK_VRI_VVV0UU2, INSTR_VRI_VVV0UU2, 2, 10, 0, "vector shift and divide decimal" },
  { "vcsph", OP48(0xe6000000007dLL), MASK_VRR_VVV0U0, INSTR_VRR_VVV0U0, 2, 12, 0, "vector convert hfp to scaled decimal" },
  { "vscshp", OP48(0xe6000000007cLL), MASK_VRR_VVV, INSTR_VRR_VVV, 2, 12, 0, "decimal scale and convert and split to hfp" },
  { "vrp", OP48(0xe6000000007bLL), MASK_VRI_VVV0UU2, INSTR_VRI_VVV0UU2, 2, 10, 0, "vector remainder decimal" },
  { "vdp", OP48(0xe6000000007aLL), MASK_VRI_VVV0UU2, INSTR_VRI_VVV0UU2, 2, 10, 0, "vector divide decimal" },
  { "vmsp", OP48(0xe60000000079LL), MASK_VRI_VVV0UU2, INSTR_VRI_VVV0UU2, 2, 10, 0, "vector multiply and shift decimal" },
  { "vmp", OP48(0xe60000000078LL), MASK_VRI_VVV0UU2, INSTR_VRI_VVV0UU2, 2, 10, 0, "vector multiply decimal" },
  { "vcp", OP48(0xe60000000077LL), MASK_VRR_0VV0U, INSTR_VRR_0VV0U, 2, 10, 0, "vector compare decimal" },
  { "vcrnf", OP48(0xe60000000075LL), MASK_VRR_VVV0UU, INSTR_VRR_VVV0UU, 2, 12, 0, "vector fp convert and round to nnp" },
  { "vschp", OP48(0xe60000000074LL), MASK_VRR_VVV0U0U, INSTR_VRR_VVV0U0U, 2, 12, 0, "decimal scale and convert to hfp" },
  { "vsp", OP48(0xe60000000073LL), MASK_VRI_VVV0UU2, INSTR_VRI_VVV0UU2, 2, 10, 0, "vector subtract decimal" },
  { "vsrpr", OP48(0xe60000000072LL), MASK_VRI_VVV0UU2, INSTR_VRI_VVV0UU2, 2, 12, 0, "vector shift and round decimal register" },
  { "vap", OP48(0xe60000000071LL), MASK_VRI_VVV0UU2, INSTR_VRI_VVV0UU2, 2, 10, 0, "vector add decimal" },
  { "vpkzr", OP48(0xe60000000070LL), MASK_VRI_VVV0UU2, INSTR_VRI_VVV0UU2, 2, 12, 0, "vector pack zoned register" },
  { "vtp", OP48(0xe6000000005fLL), MASK_VRR_0V0U, INSTR_VRR_0V0U, 2, 13, 1, "vector test decimal" },
  { "vtp", OP48(0xe6000000005fLL), MASK_VRR_0V, INSTR_VRR_0V, 2, 10, 0, "vector test decimal" },
  { "vclfnl", OP48(0xe6000000005eLL), MASK_VRR_VV0UU2, INSTR_VRR_VV0UU2, 2, 12, 0, "vector fp convert and lengthen from nnp low" },
  { "vcfn", OP48(0xe6000000005dLL), MASK_VRR_VV0UU2, INSTR_VRR_VV0UU2, 2, 12, 0, "vector fp convert from nnp" },
  { "vupkzl", OP48(0xe6000000005cLL), MASK_VRR_VV0U2, INSTR_VRR_VV0U2, 2, 12, 0, "vector unpack zoned low" },
  { "vpsop", OP48(0xe6000000005bLL), MASK_VRI_VVUUU2, INSTR_VRI_VVUUU2, 2, 10, 0, "vector perform sign operation decimal" },
  { "vcvdg", OP48(0xe6000000005aLL), MASK_VRI_VR0UU, INSTR_VRI_VR0UU, 2, 10, 0, "vector convert to decimal 64 bit" },
  { "vsrp", OP48(0xe60000000059LL), MASK_VRI_VVUUU2, INSTR_VRI_VVUUU2, 2, 10, 0, "vector shift and round decimal" },
  { "vcvd", OP48(0xe60000000058LL), MASK_VRI_VR0UU, INSTR_VRI_VR0UU, 2, 10, 0, "vector convert to decimal 32 bit" },
  { "vclfnh", OP48(0xe60000000056LL), MASK_VRR_VV0UU2, INSTR_VRR_VV0UU2, 2, 12, 0, "vector fp convert and lengthen from nnp high" },
  { "vcnf", OP48(0xe60000000055LL), MASK_VRR_VV0UU2, INSTR_VRR_VV0UU2, 2, 12, 0, "vector fp convert to nnp" },
  { "vupkzh", OP48(0xe60000000054LL), MASK_VRR_VV0U2, INSTR_VRR_VV0U2, 2, 12, 0, "vector unpack zoned high" },
  { "vcvbg", OP48(0xe60000000052LL), MASK_VRR_RV0UU, INSTR_VRR_RV0UU, 2, 11, 1, "vector convert to binary 64 bit" },
  { "vcvbg", OP48(0xe60000000052LL), MASK_VRR_RV0U, INSTR_VRR_RV0U, 2, 10, 0, "vector convert to binary 64 bit" },
  { "vclzdp", OP48(0xe60000000051LL), MASK_VRR_VV0U2, INSTR_VRR_VV0U2, 2, 12, 0, "vector count leading zero digits" },
  { "vcvb", OP48(0xe60000000050LL), MASK_VRR_RV0UU, INSTR_VRR_RV0UU, 2, 11, 1, "vector convert to binary 32 bit" },
  { "vcvb", OP48(0xe60000000050LL), MASK_VRR_RV0U, INSTR_VRR_RV0U, 2, 10, 0, "vector convert to binary 32 bit" },
  { "vcvbq", OP48(0xe6000000004eLL), MASK_VRR_VV0U2, INSTR_VRR_VV0U2, 2, 13, 0, "vector convert to binary 128 bit" },
  { "vcvdq", OP48(0xe6000000004aLL), MASK_VRI_VV0UU, INSTR_VRI_VV0UU, 2, 13, 0, "vector convert to decimal 128 bit" },
  { "vlip", OP48(0xe60000000049LL), MASK_VRI_V0UU2, INSTR_VRI_V0UU2, 2, 10, 0, "vector load immediate decimal" },
  { "vstrlr", OP48(0xe6000000003fLL), MASK_VRS_RRDV, INSTR_VRS_RRDV, 2, 10, 0, "vector store rightmost with length" },
  { "vstrl", OP48(0xe6000000003dLL), MASK_VSI_URDV, INSTR_VSI_URDV, 2, 10, 0, "vector store rightmost with immediate length" },
  { "vupkz", OP48(0xe6000000003cLL), MASK_VSI_URDV, INSTR_VSI_URDV, 2, 10, 0, "vector unpack zoned" },
  { "vlrlr", OP48(0xe60000000037LL), MASK_VRS_RRDV, INSTR_VRS_RRDV, 2, 10, 0, "vector load rightmost with length" },
  { "vlrl", OP48(0xe60000000035LL), MASK_VSI_URDV, INSTR_VSI_URDV, 2, 10, 0, "vector load rightmost with immediate length" },
  { "vpkz", OP48(0xe60000000034LL), MASK_VSI_URDV, INSTR_VSI_URDV, 2, 10, 0, "vector pack zoned" },
  { "vster", OP48(0xe6000000000fLL), MASK_VRX_VRRDU, INSTR_VRX_VRRDU, 2, 11, 0, "vector store elements reversed" },
  { "vstbr", OP48(0xe6000000000eLL), MASK_VRX_VRRDU, INSTR_VRX_VRRDU, 2, 11, 0, "vector store byte reversed elements" },
  { "vstebrf", OP48(0xe6000000000bLL), MASK_VRX_VRRDU, INSTR_VRX_VRRDU, 2, 11, 0, "vector store byte reversed word element" },
  { "sterv", OP48(0xe6000000000bLL), MASK_VRX_VRRD, INSTR_VRX_VRRD, 2, 11, 0, "store byte reversed word" },
  { "vstebrg", OP48(0xe6000000000aLL), MASK_VRX_VRRDU, INSTR_VRX_VRRDU, 2, 11, 0, "vector store byte reversed doubleword element" },
  { "stdrv", OP48(0xe6000000000aLL), MASK_VRX_VRRD, INSTR_VRX_VRRD, 2, 11, 0, "store byte reversed doubleword" },
  { "vstebrh", OP48(0xe60000000009LL), MASK_VRX_VRRDU, INSTR_VRX_VRRDU, 2, 11, 0, "vector store byte reversed halfword element" },
  { "vler", OP48(0xe60000000007LL), MASK_VRX_VRRDU, INSTR_VRX_VRRDU, 2, 11, 0, "vector load elements reversed" },
  { "vlbr", OP48(0xe60000000006LL), MASK_VRX_VRRDU, INSTR_VRX_VRRDU, 2, 11, 0, "vector load byte reversed elements" },
  { "vlbrrep", OP48(0xe60000000005LL), MASK_VRX_VRRDU, INSTR_VRX_VRRDU, 2, 11, 0, "vector load byte reversed element and replicate" },
  { "vllebrz", OP48(0xe60000000004LL), MASK_VRX_VRRDU, INSTR_VRX_VRRDU, 2, 11, 0, "vector load byte reversed element and zero" },
  { "vlebrf", OP48(0xe60000000003LL), MASK_VRX_VRRDU, INSTR_VRX_VRRDU, 2, 11, 0, "vector load byte reversed word element" },
  { "vlebrg", OP48(0xe60000000002LL), MASK_VRX_VRRDU, INSTR_VRX_VRRDU, 2, 11, 0, "vector load byte reversed doubleword element" },
  { "vlebrh", OP48(0xe60000000001LL), MASK_VRX_VRRDU, INSTR_VRX_VRRDU, 2, 11, 0, "vector load byte reversed halfword element" },
  { "tbeginc", OP16(0xe561LL), MASK_SIL_RDU, INSTR_SIL_RDU, 2, 8, 4, "constrained transaction begin" },
  { "tbegin", OP16(0xe560LL), MASK_SIL_RDU, INSTR_SIL_RDU, 2, 8, 4, "transaction begin" },
  { "clfhsi", OP16(0xe55dLL), MASK_SIL_RDU, INSTR_SIL_RDU, 2, 6, 0, "compare logical immediate (32<16)" },
  { "chsi", OP16(0xe55cLL), MASK_SIL_RDI, INSTR_SIL_RDI, 2, 6, 0, "compare halfword immediate (32<16)" },
  { "clghsi", OP16(0xe559LL), MASK_SIL_RDU, INSTR_SIL_RDU, 2, 6, 0, "compare logical immediate (64<16)" },
  { "cghsi", OP16(0xe558LL), MASK_SIL_RDI, INSTR_SIL_RDI, 2, 6, 0, "compare halfword immediate (64<16)" },
  { "clhhsi", OP16(0xe555LL), MASK_SIL_RDU, INSTR_SIL_RDU, 2, 6, 0, "compare logical immediate (16<16)" },
  { "chhsi", OP16(0xe554LL), MASK_SIL_RDI, INSTR_SIL_RDI, 2, 6, 0, "compare halfword immediate (16<16)" },
  { "mvhi", OP16(0xe54cLL), MASK_SIL_RDI, INSTR_SIL_RDI, 2, 6, 0, "move (32<16)" },
  { "mvghi", OP16(0xe548LL), MASK_SIL_RDI, INSTR_SIL_RDI, 2, 6, 0, "move (64<16)" },
  { "mvhhi", OP16(0xe544LL), MASK_SIL_RDI, INSTR_SIL_RDI, 2, 6, 0, "move (16<16)" },
  { "mvcdk", OP16(0xe50fLL), MASK_SSE_RDRD, INSTR_SSE_RDRD, 3, 0, 0, "move with destination key" },
  { "mvcsk", OP16(0xe50eLL), MASK_SSE_RDRD, INSTR_SSE_RDRD, 3, 0, 0, "move with source key" },
  { "mvcrl", OP16(0xe50aLL), MASK_SSE_RDRD, INSTR_SSE_RDRD, 2, 11, 0, "move right to left" },
  { "strag", OP16(0xe502LL), MASK_SSE_RDRD, INSTR_SSE_RDRD, 2, 2, 0, "store read address" },
  { "tprot", OP16(0xe501LL), MASK_SSE_RDRD, INSTR_SSE_RDRD, 3, 0, 0, "test protection" },
  { "lasp", OP16(0xe500LL), MASK_SSE_RDRD, INSTR_SSE_RDRD, 3, 0, 0, "load address space parameters" },
  { "bi", OP48(0xe3f000000047LL), MASK_RXY_0RRD, INSTR_RXY_0RRD, 2, 10, 0, "unconditional indirect branch" },
  { "bino", OP48(0xe3e000000047LL), MASK_RXY_0RRD, INSTR_RXY_0RRD, 2, 10, 0, "branch indirect on condition on not overflow / if not ones" },
  { "binh", OP48(0xe3d000000047LL), MASK_RXY_0RRD, INSTR_RXY_0RRD, 2, 10, 0, "branch indirect on condition on A not high" },
  { "binp", OP48(0xe3d000000047LL), MASK_RXY_0RRD, INSTR_RXY_0RRD, 2, 10, 0, "branch indirect on condition on not plus" },
  { "bile", OP48(0xe3c000000047LL), MASK_RXY_0RRD, INSTR_RXY_0RRD, 2, 10, 0, "branch indirect on condition on low or equal" },
  { "binl", OP48(0xe3b000000047LL), MASK_RXY_0RRD, INSTR_RXY_0RRD, 2, 10, 0, "branch indirect on condition on A not low" },
  { "binm", OP48(0xe3b000000047LL), MASK_RXY_0RRD, INSTR_RXY_0RRD, 2, 10, 0, "branch indirect on condition on not minus / if not mixed" },
  { "bihe", OP48(0xe3a000000047LL), MASK_RXY_0RRD, INSTR_RXY_0RRD, 2, 10, 0, "branch indirect on condition on high or equal" },
  { "binlh", OP48(0xe39000000047LL), MASK_RXY_0RRD, INSTR_RXY_0RRD, 2, 10, 0, "branch indirect on condition on not low or high" },
  { "bie", OP48(0xe38000000047LL), MASK_RXY_0RRD, INSTR_RXY_0RRD, 2, 10, 0, "branch indirect on condition on A equal B" },
  { "biz", OP48(0xe38000000047LL), MASK_RXY_0RRD, INSTR_RXY_0RRD, 2, 10, 0, "branch indirect on condition on zero / if zeros" },
  { "bine", OP48(0xe37000000047LL), MASK_RXY_0RRD, INSTR_RXY_0RRD, 2, 10, 0, "branch indirect on condition on A not equal B" },
  { "binz", OP48(0xe37000000047LL), MASK_RXY_0RRD, INSTR_RXY_0RRD, 2, 10, 0, "branch indirect on condition on not zero / if not zeros" },
  { "bilh", OP48(0xe36000000047LL), MASK_RXY_0RRD, INSTR_RXY_0RRD, 2, 10, 0, "branch indirect on condition on low or high" },
  { "binhe", OP48(0xe35000000047LL), MASK_RXY_0RRD, INSTR_RXY_0RRD, 2, 10, 0, "branch indirect on condition on not high or equal" },
  { "bil", OP48(0xe34000000047LL), MASK_RXY_0RRD, INSTR_RXY_0RRD, 2, 10, 0, "branch indirect on condition on A low" },
  { "bim", OP48(0xe34000000047LL), MASK_RXY_0RRD, INSTR_RXY_0RRD, 2, 10, 0, "branch indirect on condition on minus / if mixed" },
  { "binle", OP48(0xe33000000047LL), MASK_RXY_0RRD, INSTR_RXY_0RRD, 2, 10, 0, "branch indirect on condition on not low or equal" },
  { "bih", OP48(0xe32000000047LL), MASK_RXY_0RRD, INSTR_RXY_0RRD, 2, 10, 0, "branch indirect on condition on A high" },
  { "bip", OP48(0xe32000000047LL), MASK_RXY_0RRD, INSTR_RXY_0RRD, 2, 10, 0, "branch indirect on condition on plus" },
  { "bio", OP48(0xe31000000047LL), MASK_RXY_0RRD, INSTR_RXY_0RRD, 2, 10, 0, "branch indirect on condition on overflow / if ones" },
  { "clhf", OP48(0xe300000000cfLL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 7, 0, "compare logical high" },
  { "chf", OP48(0xe300000000cdLL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 7, 0, "compare high" },
  { "stfh", OP48(0xe300000000cbLL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 7, 0, "store high" },
  { "lfh", OP48(0xe300000000caLL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 7, 0, "load high" },
  { "lfhat", OP48(0xe300000000c8LL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 8, 0, "load high and trap" },
  { "sthh", OP48(0xe300000000c7LL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 7, 0, "store halfword high" },
  { "llhh", OP48(0xe300000000c6LL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 7, 0, "load logical halfword high" },
  { "lhh", OP48(0xe300000000c4LL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 7, 0, "load halfword high" },
  { "stch", OP48(0xe300000000c3LL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 7, 0, "store character high" },
  { "llch", OP48(0xe300000000c2LL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 7, 0, "load logical character high" },
  { "lbh", OP48(0xe300000000c0LL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 7, 0, "load byte high" },
  { "lat", OP48(0xe3000000009fLL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 8, 0, "load and trap 32 bit" },
  { "llgfat", OP48(0xe3000000009dLL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 8, 0, "load logical and trap 32>64" },
  { "llgtat", OP48(0xe3000000009cLL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 8, 0, "load logical thirty one bits and trap 31>64" },
  { "slb", OP48(0xe30000000099LL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 3, 3, 0, "subtract logical with borrow 32" },
  { "slb", OP48(0xe30000000099LL), MASK_RXE_RRRD, INSTR_RXE_RRRD, 3, 2, 0, "subtract logical with borrow 32" },
  { "alc", OP48(0xe30000000098LL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 3, 3, 0, "add logical with carry 32" },
  { "alc", OP48(0xe30000000098LL), MASK_RXE_RRRD, INSTR_RXE_RRRD, 3, 2, 0, "add logical with carry 32" },
  { "dl", OP48(0xe30000000097LL), MASK_RXY_RERRD, INSTR_RXY_RERRD, 3, 3, 0, "divide logical 32" },
  { "dl", OP48(0xe30000000097LL), MASK_RXE_RERRD, INSTR_RXE_RERRD, 3, 2, 0, "divide logical 32" },
  { "ml", OP48(0xe30000000096LL), MASK_RXY_RERRD, INSTR_RXY_RERRD, 3, 3, 0, "multiply logical 32" },
  { "ml", OP48(0xe30000000096LL), MASK_RXE_RERRD, INSTR_RXE_RERRD, 3, 2, 0, "multiply logical 32" },
  { "llh", OP48(0xe30000000095LL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 4, 0, "load logical halfword 32" },
  { "llc", OP48(0xe30000000094LL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 4, 0, "load logical character 32" },
  { "llgh", OP48(0xe30000000091LL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 3, 0, "load logical halfword" },
  { "llgh", OP48(0xe30000000091LL), MASK_RXE_RRRD, INSTR_RXE_RRRD, 2, 2, 0, "load logical halfword" },
  { "llgc", OP48(0xe30000000090LL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 3, 0, "load logical character" },
  { "llgc", OP48(0xe30000000090LL), MASK_RXE_RRRD, INSTR_RXE_RRRD, 2, 2, 0, "load logical character" },
  { "lpq", OP48(0xe3000000008fLL), MASK_RXY_RERRD, INSTR_RXY_RERRD, 2, 3, 0, "load pair from quadword" },
  { "lpq", OP48(0xe3000000008fLL), MASK_RXE_RERRD, INSTR_RXE_RERRD, 2, 2, 0, "load pair from quadword" },
  { "stpq", OP48(0xe3000000008eLL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 3, 0, "store pair to quadword" },
  { "stpq", OP48(0xe3000000008eLL), MASK_RXE_RRRD, INSTR_RXE_RRRD, 2, 2, 0, "store pair to quadword" },
  { "slbg", OP48(0xe30000000089LL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 3, 0, "subtract logical with borrow 64" },
  { "slbg", OP48(0xe30000000089LL), MASK_RXE_RRRD, INSTR_RXE_RRRD, 2, 2, 0, "subtract logical with borrow 64" },
  { "alcg", OP48(0xe30000000088LL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 3, 0, "add logical with carry 64" },
  { "alcg", OP48(0xe30000000088LL), MASK_RXE_RRRD, INSTR_RXE_RRRD, 2, 2, 0, "add logical with carry 64" },
  { "dlg", OP48(0xe30000000087LL), MASK_RXY_RERRD, INSTR_RXY_RERRD, 2, 3, 0, "divide logical 64" },
  { "dlg", OP48(0xe30000000087LL), MASK_RXE_RERRD, INSTR_RXE_RERRD, 2, 2, 0, "divide logical 64" },
  { "mlg", OP48(0xe30000000086LL), MASK_RXY_RERRD, INSTR_RXY_RERRD, 2, 3, 0, "multiply logical 64" },
  { "mlg", OP48(0xe30000000086LL), MASK_RXE_RERRD, INSTR_RXE_RERRD, 2, 2, 0, "multiply logical 64" },
  { "lgat", OP48(0xe30000000085LL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 8, 0, "load and trap 64 bit" },
  { "mg", OP48(0xe30000000084LL), MASK_RXY_RERRD, INSTR_RXY_RERRD, 2, 10, 0, "multiply 64x64mem -> 128" },
  { "msgc", OP48(0xe30000000083LL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 10, 0, "multiply single 64x64mem -> 64" },
  { "xg", OP48(0xe30000000082LL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 3, 0, "exclusive or with long offset 64" },
  { "xg", OP48(0xe30000000082LL), MASK_RXE_RRRD, INSTR_RXE_RRRD, 2, 2, 0, "exclusive or 64" },
  { "og", OP48(0xe30000000081LL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 3, 0, "or with long offset 64" },
  { "og", OP48(0xe30000000081LL), MASK_RXE_RRRD, INSTR_RXE_RRRD, 2, 2, 0, "or 64" },
  { "ng", OP48(0xe30000000080LL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 3, 0, "and with long offset 64" },
  { "ng", OP48(0xe30000000080LL), MASK_RXE_RRRD, INSTR_RXE_RRRD, 2, 2, 0, "and 64" },
  { "mhy", OP48(0xe3000000007cLL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 6, 0, "multiply halfword" },
  { "shy", OP48(0xe3000000007bLL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 3, 0, "subtract halfword with long offset" },
  { "ahy", OP48(0xe3000000007aLL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 3, 0, "add halfword with long offset" },
  { "chy", OP48(0xe30000000079LL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 3, 0, "compare halfword with long offset" },
  { "lhy", OP48(0xe30000000078LL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 3, 0, "load halfword with long offset" },
  { "lgb", OP48(0xe30000000077LL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 3, 0, "load byte with long offset 64" },
  { "lb", OP48(0xe30000000076LL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 3, 0, "load byte with long offset" },
  { "laey", OP48(0xe30000000075LL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 6, 0, "load address extended" },
  { "icy", OP48(0xe30000000073LL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 3, 0, "insert character with long offset" },
  { "stcy", OP48(0xe30000000072LL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 3, 0, "store character with long offset" },
  { "lay", OP48(0xe30000000071LL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 3, 0, "load address with long offset" },
  { "sthy", OP48(0xe30000000070LL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 3, 0, "store halfword with long offset" },
  { "llxaq", OP48(0xe30000000069LL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 13, 0, "load logical indexed address (shift left 4)" },
  { "lxaq", OP48(0xe30000000068LL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 13, 0, "load indexed address (shift left 4)" },
  { "llxag", OP48(0xe30000000067LL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 13, 0, "load logical indexed address (shift left 3)" },
  { "lxag", OP48(0xe30000000066LL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 13, 0, "load indexed address (shift left 3)" },
  { "llxaf", OP48(0xe30000000065LL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 13, 0, "load logical indexed address (shift left 2)" },
  { "lxaf", OP48(0xe30000000064LL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 13, 0, "load indexed address (shift left 2)" },
  { "llxah", OP48(0xe30000000063LL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 13, 0, "load logical indexed address (shift left 1)" },
  { "lxah", OP48(0xe30000000062LL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 13, 0, "load indexed address (shift left 1)" },
  { "llxab", OP48(0xe30000000061LL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 13, 0, "load logical indexed address (shift left 0)" },
  { "lxab", OP48(0xe30000000060LL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 13, 0, "load indexed address (shift left 0)" },
  { "sly", OP48(0xe3000000005fLL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 3, 0, "subtract logical with long offset" },
  { "aly", OP48(0xe3000000005eLL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 3, 0, "add logical with long offset" },
  { "mfy", OP48(0xe3000000005cLL), MASK_RXY_RERRD, INSTR_RXY_RERRD, 2, 6, 0, "multiply" },
  { "sy", OP48(0xe3000000005bLL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 3, 0, "subtract with long offset" },
  { "ay", OP48(0xe3000000005aLL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 3, 0, "add with long offset" },
  { "cy", OP48(0xe30000000059LL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 3, 0, "compare with long offset" },
  { "ly", OP48(0xe30000000058LL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 3, 0, "load with long offset" },
  { "xy", OP48(0xe30000000057LL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 3, 0, "exclusive or with long offset" },
  { "oy", OP48(0xe30000000056LL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 3, 0, "or with long offset" },
  { "cly", OP48(0xe30000000055LL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 3, 0, "compare logical with long offset" },
  { "ny", OP48(0xe30000000054LL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 3, 0, "and with long offset" },
  { "msc", OP48(0xe30000000053LL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 10, 0, "multiply single 32x32mem -> 32" },
  { "msy", OP48(0xe30000000051LL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 3, 0, "multiply single with long offset" },
  { "sty", OP48(0xe30000000050LL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 3, 0, "store with long offset" },
  { "lgsc", OP48(0xe3000000004dLL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 10, 0, "load guarded storage controls" },
  { "lgg", OP48(0xe3000000004cLL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 10, 0, "load guarded 64 bit" },
  { "stgsc", OP48(0xe30000000049LL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 10, 0, "store guarded storage controls" },
  { "llgfsg", OP48(0xe30000000048LL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 10, 0, "load logical and shift guarded 64 bit" },
  { "bic", OP48(0xe30000000047LL), MASK_RXY_URRD, INSTR_RXY_URRD, 2, 10, 0, "branch indirect on condition" },
  { "bctg", OP48(0xe30000000046LL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 3, 0, "branch on count 64" },
  { "bctg", OP48(0xe30000000046LL), MASK_RXE_RRRD, INSTR_RXE_RRRD, 2, 2, 0, "branch on count 64" },
  { "strvh", OP48(0xe3000000003fLL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 3, 0, "store reversed 64" },
  { "strvh", OP48(0xe3000000003fLL), MASK_RXE_RRRD, INSTR_RXE_RRRD, 3, 2, 0, "store reversed 64" },
  { "strv", OP48(0xe3000000003eLL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 3, 3, 0, "store reversed 32" },
  { "strv", OP48(0xe3000000003eLL), MASK_RXE_RRRD, INSTR_RXE_RRRD, 3, 2, 0, "store reversed 32" },
  { "mgh", OP48(0xe3000000003cLL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 10, 0, "multiply halfword 64x16mem -> 64" },
  { "lzrf", OP48(0xe3000000003bLL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 9, 0, "load and zero rightmost byte 32->32" },
  { "llzrgf", OP48(0xe3000000003aLL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 9, 0, "load logical and zero rightmost bytes 32->64" },
  { "sgh", OP48(0xe30000000039LL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 10, 0, "subtract halfword from 64 bit value" },
  { "agh", OP48(0xe30000000038LL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 10, 0, "add halfword to 64 bit value" },
  { "pfd", OP48(0xe30000000036LL), MASK_RXY_URRD, INSTR_RXY_URRD, 2, 6, 0, "prefetch data" },
  { "cgh", OP48(0xe30000000034LL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 6, 0, "compare halfword (64<16)" },
  { "ltgf", OP48(0xe30000000032LL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 6, 0, "load and test (64<32)" },
  { "clgf", OP48(0xe30000000031LL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 3, 0, "compare logical with long offset 64<32" },
  { "clgf", OP48(0xe30000000031LL), MASK_RXE_RRRD, INSTR_RXE_RRRD, 2, 2, 0, "compare logical 64<32" },
  { "cgf", OP48(0xe30000000030LL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 3, 0, "compare with long offset 64<32" },
  { "cgf", OP48(0xe30000000030LL), MASK_RXE_RRRD, INSTR_RXE_RRRD, 2, 2, 0, "compare 64<32" },
  { "strvg", OP48(0xe3000000002fLL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 3, 0, "store reversed 64" },
  { "strvg", OP48(0xe3000000002fLL), MASK_RXE_RRRD, INSTR_RXE_RRRD, 2, 2, 0, "store reversed 64" },
  { "cvdg", OP48(0xe3000000002eLL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 3, 0, "convert to decimal with long offset 64" },
  { "cvdg", OP48(0xe3000000002eLL), MASK_RXE_RRRD, INSTR_RXE_RRRD, 2, 2, 0, "convert to decimal 64" },
  { "lzrg", OP48(0xe3000000002aLL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 9, 0, "load and zero rightmost byte 64->64" },
  { "cvdy", OP48(0xe30000000026LL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 3, 0, "convert to decimal with long offset" },
  { "ntstg", OP48(0xe30000000025LL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 8, 4, "nontransactional store" },
  { "stg", OP48(0xe30000000024LL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 3, 0, "store with long offset 64" },
  { "stg", OP48(0xe30000000024LL), MASK_RXE_RRRD, INSTR_RXE_RRRD, 2, 2, 0, "store 64" },
  { "clg", OP48(0xe30000000021LL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 3, 0, "compare logical with long offset 64" },
  { "clg", OP48(0xe30000000021LL), MASK_RXE_RRRD, INSTR_RXE_RRRD, 2, 2, 0, "compare logical 64" },
  { "cg", OP48(0xe30000000020LL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 3, 0, "compare with long offset 64" },
  { "cg", OP48(0xe30000000020LL), MASK_RXE_RRRD, INSTR_RXE_RRRD, 2, 2, 0, "compare 64" },
  { "lrvh", OP48(0xe3000000001fLL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 3, 3, 0, "load reversed 16" },
  { "lrvh", OP48(0xe3000000001fLL), MASK_RXE_RRRD, INSTR_RXE_RRRD, 3, 2, 0, "load reversed 16" },
  { "lrv", OP48(0xe3000000001eLL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 3, 3, 0, "load reversed 32" },
  { "lrv", OP48(0xe3000000001eLL), MASK_RXE_RRRD, INSTR_RXE_RRRD, 3, 2, 0, "load reversed 32" },
  { "dsgf", OP48(0xe3000000001dLL), MASK_RXY_RERRD, INSTR_RXY_RERRD, 2, 3, 0, "divide single 64<32" },
  { "dsgf", OP48(0xe3000000001dLL), MASK_RXE_RERRD, INSTR_RXE_RERRD, 2, 2, 0, "divide single 64<32" },
  { "msgf", OP48(0xe3000000001cLL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 3, 0, "multiply single with long offset 64<32" },
  { "msgf", OP48(0xe3000000001cLL), MASK_RXE_RRRD, INSTR_RXE_RRRD, 2, 2, 0, "multiply single 64<32" },
  { "slgf", OP48(0xe3000000001bLL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 3, 0, "subtract logical with long offset 64<32" },
  { "slgf", OP48(0xe3000000001bLL), MASK_RXE_RRRD, INSTR_RXE_RRRD, 2, 2, 0, "subtract logical 64<32" },
  { "algf", OP48(0xe3000000001aLL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 3, 0, "add logical with long offset 64<32" },
  { "algf", OP48(0xe3000000001aLL), MASK_RXE_RRRD, INSTR_RXE_RRRD, 2, 2, 0, "add logical 64<32" },
  { "sgf", OP48(0xe30000000019LL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 3, 0, "subtract with long offset 64<32" },
  { "sgf", OP48(0xe30000000019LL), MASK_RXE_RRRD, INSTR_RXE_RRRD, 2, 2, 0, "subtract 64<32" },
  { "agf", OP48(0xe30000000018LL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 3, 0, "add with long offset 64<32" },
  { "agf", OP48(0xe30000000018LL), MASK_RXE_RRRD, INSTR_RXE_RRRD, 2, 2, 0, "add 64<32" },
  { "llgt", OP48(0xe30000000017LL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 3, 0, "load logical thirty one bits" },
  { "llgt", OP48(0xe30000000017LL), MASK_RXE_RRRD, INSTR_RXE_RRRD, 2, 2, 0, "load logical thirty one bits" },
  { "llgf", OP48(0xe30000000016LL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 3, 0, "load logical 64<32" },
  { "llgf", OP48(0xe30000000016LL), MASK_RXE_RRRD, INSTR_RXE_RRRD, 2, 2, 0, "load logical 64<32" },
  { "lgh", OP48(0xe30000000015LL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 3, 0, "load halfword 64" },
  { "lgh", OP48(0xe30000000015LL), MASK_RXE_RRRD, INSTR_RXE_RRRD, 2, 2, 0, "load halfword 64" },
  { "lgf", OP48(0xe30000000014LL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 3, 0, "load 64<32" },
  { "lgf", OP48(0xe30000000014LL), MASK_RXE_RRRD, INSTR_RXE_RRRD, 2, 2, 0, "load 64<32" },
  { "lray", OP48(0xe30000000013LL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 3, 0, "load real address with long offset" },
  { "lt", OP48(0xe30000000012LL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 4, 0, "load and test 32" },
  { "lrvg", OP48(0xe3000000000fLL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 3, 0, "load reversed 64" },
  { "lrvg", OP48(0xe3000000000fLL), MASK_RXE_RRRD, INSTR_RXE_RRRD, 2, 2, 0, "load reversed 64" },
  { "cvbg", OP48(0xe3000000000eLL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 3, 0, "convert to binary with long offset 64" },
  { "cvbg", OP48(0xe3000000000eLL), MASK_RXE_RRRD, INSTR_RXE_RRRD, 2, 2, 0, "convert to binary 64" },
  { "dsg", OP48(0xe3000000000dLL), MASK_RXY_RERRD, INSTR_RXY_RERRD, 2, 3, 0, "divide single 64" },
  { "dsg", OP48(0xe3000000000dLL), MASK_RXE_RERRD, INSTR_RXE_RERRD, 2, 2, 0, "divide single 64" },
  { "msg", OP48(0xe3000000000cLL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 3, 0, "multiply single with long offset 64" },
  { "msg", OP48(0xe3000000000cLL), MASK_RXE_RRRD, INSTR_RXE_RRRD, 2, 2, 0, "multiply single 64" },
  { "slg", OP48(0xe3000000000bLL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 3, 0, "subtract logical with long offset 64" },
  { "slg", OP48(0xe3000000000bLL), MASK_RXE_RRRD, INSTR_RXE_RRRD, 2, 2, 0, "subtract logical 64" },
  { "alg", OP48(0xe3000000000aLL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 3, 0, "add logical with long offset 64" },
  { "alg", OP48(0xe3000000000aLL), MASK_RXE_RRRD, INSTR_RXE_RRRD, 2, 2, 0, "add logical 64" },
  { "sg", OP48(0xe30000000009LL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 3, 0, "subtract with long offset 64" },
  { "sg", OP48(0xe30000000009LL), MASK_RXE_RRRD, INSTR_RXE_RRRD, 2, 2, 0, "subtract 64" },
  { "ag", OP48(0xe30000000008LL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 3, 0, "add with long offset 64" },
  { "ag", OP48(0xe30000000008LL), MASK_RXE_RRRD, INSTR_RXE_RRRD, 2, 2, 0, "add 64" },
  { "cvby", OP48(0xe30000000006LL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 3, 0, "convert to binary with long offset" },
  { "lg", OP48(0xe30000000004LL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 3, 0, "load 64" },
  { "lg", OP48(0xe30000000004LL), MASK_RXE_RRRD, INSTR_RXE_RRRD, 2, 2, 0, "load 64" },
  { "lrag", OP48(0xe30000000003LL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 3, 0, "load real address with long offset 64" },
  { "lrag", OP48(0xe30000000003LL), MASK_RXE_RRRD, INSTR_RXE_RRRD, 2, 2, 0, "load real address 64" },
  { "ltg", OP48(0xe30000000002LL), MASK_RXY_RRRD, INSTR_RXY_RRRD, 2, 4, 0, "load and test 64" },
  { "unpku", OP8(0xe2LL), MASK_SS_L0RDRD, INSTR_SS_L0RDRD, 3, 0, 0, "unpack unicode" },
  { "pku", OP8(0xe1LL), MASK_SS_L2RDRD, INSTR_SS_L2RDRD, 3, 0, 0, "pack unicode" },
  { "edmk", OP8(0xdfLL), MASK_SS_L0RDRD, INSTR_SS_L0RDRD, 3, 0, 0, "edit and mark" },
  { "ed", OP8(0xdeLL), MASK_SS_L0RDRD, INSTR_SS_L0RDRD, 3, 0, 0, "edit" },
  { "trt", OP8(0xddLL), MASK_SS_L0RDRD, INSTR_SS_L0RDRD, 3, 0, 0, "translate and test" },
  { "tr", OP8(0xdcLL), MASK_SS_L0RDRD, INSTR_SS_L0RDRD, 3, 0, 0, "translate" },
  { "mvcs", OP8(0xdbLL), MASK_SS_RRRDRD, INSTR_SS_RRRDRD, 3, 0, 0, "move to secondary" },
  { "mvcp", OP8(0xdaLL), MASK_SS_RRRDRD, INSTR_SS_RRRDRD, 3, 0, 0, "move to primary" },
  { "mvck", OP8(0xd9LL), MASK_SS_RRRDRD, INSTR_SS_RRRDRD, 3, 0, 0, "move with key" },
  { "xc", OP8(0xd7LL), MASK_SS_L0RDRD, INSTR_SS_L0RDRD, 3, 0, 0, "exclusive or" },
  { "oc", OP8(0xd6LL), MASK_SS_L0RDRD, INSTR_SS_L0RDRD, 3, 0, 0, "or" },
  { "clc", OP8(0xd5LL), MASK_SS_L0RDRD, INSTR_SS_L0RDRD, 3, 0, 0, "compare logical" },
  { "nc", OP8(0xd4LL), MASK_SS_L0RDRD, INSTR_SS_L0RDRD, 3, 0, 0, "and" },
  { "mvz", OP8(0xd3LL), MASK_SS_L0RDRD, INSTR_SS_L0RDRD, 3, 0, 0, "move zones" },
  { "mvc", OP8(0xd2LL), MASK_SS_L0RDRD, INSTR_SS_L0RDRD, 3, 0, 0, "move" },
  { "mvn", OP8(0xd1LL), MASK_SS_L0RDRD, INSTR_SS_L0RDRD, 3, 0, 0, "move numerics" },
  { "trtr", OP8(0xd0LL), MASK_SS_L0RDRD, INSTR_SS_L0RDRD, 2, 4, 0, "tranlate and test reverse" },
  { "clih", OP16(0xcc0fLL), MASK_RIL_RU, INSTR_RIL_RU, 2, 7, 0, "compare logical immediate" },
  { "cih", OP16(0xcc0dLL), MASK_RIL_RI, INSTR_RIL_RI, 2, 7, 0, "compare immediate high" },
  { "alsihn", OP16(0xcc0bLL), MASK_RIL_RI, INSTR_RIL_RI, 2, 7, 0, "add logical with signed immediate high no cc" },
  { "alsih", OP16(0xcc0aLL), MASK_RIL_RI, INSTR_RIL_RI, 2, 7, 0, "add logical with signed immediate high with cc" },
  { "aih", OP16(0xcc08LL), MASK_RIL_RI, INSTR_RIL_RI, 2, 7, 0, "add immediate high" },
  { "brcth", OP16(0xcc06LL), MASK_RIL_RP, INSTR_RIL_RP, 2, 7, 112, "branch relative on count high" },
  { "jcth", OP16(0xcc06LL), MASK_RIL_RP, INSTR_RIL_RP, 2, 7, 112, "jump on count high" },
  { "calgf", OP16(0xc80fLL), MASK_SSF_RRDRD2, INSTR_SSF_RRDRD2, 2, 13, 0, "compare and load 64<32" },
  { "calg", OP16(0xc807LL), MASK_SSF_RRDRD2, INSTR_SSF_RRDRD2, 2, 13, 0, "compare and load 64" },
  { "cal", OP16(0xc806LL), MASK_SSF_RRDRD2, INSTR_SSF_RRDRD2, 2, 13, 0, "compare and load 32" },
  { "lpdg", OP16(0xc805LL), MASK_SSF_RERDRD2, INSTR_SSF_RERDRD2, 2, 7, 0, "load pair disjoint 64 bit" },
  { "lpd", OP16(0xc804LL), MASK_SSF_RERDRD2, INSTR_SSF_RERDRD2, 2, 7, 0, "load pair disjoint 32 bit" },
  { "csst", OP16(0xc802LL), MASK_SSF_RRDRD, INSTR_SSF_RRDRD, 2, 5, 0, "compare and swap and store" },
  { "ectg", OP16(0xc801LL), MASK_SSF_RRDRD, INSTR_SSF_RRDRD, 2, 5, 0, "extract cpu time" },
  { "mvcos", OP16(0xc800LL), MASK_SSF_RRDRD, INSTR_SSF_RRDRD, 2, 4, 0, "move with optional specifications" },
  { "bpp", OP8(0xc7LL), MASK_SMI_U0RDP, INSTR_SMI_U0RDP, 2, 8, 0, "branch prediction preload" },
  { "clrl", OP16(0xc60fLL), MASK_RIL_RP, INSTR_RIL_RP, 2, 6, 0, "compare logical relative long (32)" },
  { "clgfrl", OP16(0xc60eLL), MASK_RIL_RP, INSTR_RIL_RP, 2, 6, 0, "compare logical relative long (64<32)" },
  { "crl", OP16(0xc60dLL), MASK_RIL_RP, INSTR_RIL_RP, 2, 6, 0, "compare relative long (32)" },
  { "cgfrl", OP16(0xc60cLL), MASK_RIL_RP, INSTR_RIL_RP, 2, 6, 0, "compare relative long (64<32)" },
  { "clgrl", OP16(0xc60aLL), MASK_RIL_RP, INSTR_RIL_RP, 2, 6, 0, "compare logical relative long (64)" },
  { "cgrl", OP16(0xc608LL), MASK_RIL_RP, INSTR_RIL_RP, 2, 6, 0, "compare relative long (64)" },
  { "clhrl", OP16(0xc607LL), MASK_RIL_RP, INSTR_RIL_RP, 2, 6, 0, "compare logical relative long (32<16)" },
  { "clghrl", OP16(0xc606LL), MASK_RIL_RP, INSTR_RIL_RP, 2, 6, 0, "compare logical relative long (64<16)" },
  { "chrl", OP16(0xc605LL), MASK_RIL_RP, INSTR_RIL_RP, 2, 6, 0, "compare halfword relative long (32<8)" },
  { "cghrl", OP16(0xc604LL), MASK_RIL_RP, INSTR_RIL_RP, 2, 6, 0, "compare halfword relative long (64<8)" },
  { "pfdrl", OP16(0xc602LL), MASK_RIL_UP, INSTR_RIL_UP, 2, 6, 0, "prefetch data relative long" },
  { "exrl", OP16(0xc600LL), MASK_RIL_RP, INSTR_RIL_RP, 2, 6, 0, "execute relative long" },
  { "bprp", OP8(0xc5LL), MASK_MII_UPP, INSTR_MII_UPP, 2, 8, 0, "branch prediction relative preload" },
  { "strl", OP16(0xc40fLL), MASK_RIL_RP, INSTR_RIL_RP, 2, 6, 0, "store relative long (32)" },
  { "llgfrl", OP16(0xc40eLL), MASK_RIL_RP, INSTR_RIL_RP, 2, 6, 0, "load logical relative long (64<32)" },
  { "lrl", OP16(0xc40dLL), MASK_RIL_RP, INSTR_RIL_RP, 2, 6, 0, "load relative long (32)" },
  { "lgfrl", OP16(0xc40cLL), MASK_RIL_RP, INSTR_RIL_RP, 2, 6, 0, "load relative long (64<32)" },
  { "stgrl", OP16(0xc40bLL), MASK_RIL_RP, INSTR_RIL_RP, 2, 6, 0, "store relative long (64)" },
  { "lgrl", OP16(0xc408LL), MASK_RIL_RP, INSTR_RIL_RP, 2, 6, 0, "load relative long (64)" },
  { "sthrl", OP16(0xc407LL), MASK_RIL_RP, INSTR_RIL_RP, 2, 6, 0, "store halfword relative long" },
  { "llghrl", OP16(0xc406LL), MASK_RIL_RP, INSTR_RIL_RP, 2, 6, 0, "load logical halfword relative long (64<16)" },
  { "lhrl", OP16(0xc405LL), MASK_RIL_RP, INSTR_RIL_RP, 2, 6, 0, "load halfword relative long (32<16)" },
  { "lghrl", OP16(0xc404LL), MASK_RIL_RP, INSTR_RIL_RP, 2, 6, 0, "load halfword relative long (64<16)" },
  { "llhrl", OP16(0xc402LL), MASK_RIL_RP, INSTR_RIL_RP, 2, 6, 0, "load logical halfword relative long (32<16)" },
  { "clfi", OP16(0xc20fLL), MASK_RIL_RU, INSTR_RIL_RU, 2, 4, 0, "compare logical immediate 32" },
  { "clgfi", OP16(0xc20eLL), MASK_RIL_RU, INSTR_RIL_RU, 2, 4, 0, "compare logical immediate 64<32" },
  { "cfi", OP16(0xc20dLL), MASK_RIL_RI, INSTR_RIL_RI, 2, 4, 0, "compare immediate 32" },
  { "cgfi", OP16(0xc20cLL), MASK_RIL_RI, INSTR_RIL_RI, 2, 4, 0, "compare immediate 64<32" },
  { "alfi", OP16(0xc20bLL), MASK_RIL_RU, INSTR_RIL_RU, 2, 4, 0, "add logical immediate 32" },
  { "algfi", OP16(0xc20aLL), MASK_RIL_RU, INSTR_RIL_RU, 2, 4, 0, "add logical immediate 64<32" },
  { "afi", OP16(0xc209LL), MASK_RIL_RI, INSTR_RIL_RI, 2, 4, 0, "add immediate 32" },
  { "agfi", OP16(0xc208LL), MASK_RIL_RI, INSTR_RIL_RI, 2, 4, 0, "add immediate 64<32" },
  { "slfi", OP16(0xc205LL), MASK_RIL_RU, INSTR_RIL_RU, 2, 4, 0, "subtract logical immediate 32" },
  { "slgfi", OP16(0xc204LL), MASK_RIL_RU, INSTR_RIL_RU, 2, 4, 0, "subtract logical immediate 64<32" },
  { "msfi", OP16(0xc201LL), MASK_RIL_RI, INSTR_RIL_RI, 2, 6, 0, "multiply single immediate (32)" },
  { "msgfi", OP16(0xc200LL), MASK_RIL_RI, INSTR_RIL_RI, 2, 6, 0, "multiply single immediate (64)" },
  { "jg", OP16(0xc0f4LL), MASK_RIL_0P, INSTR_RIL_0P, 3, 2, 48, "unconditional jump long" },
  { "brul", OP16(0xc0f4LL), MASK_RIL_0P, INSTR_RIL_0P, 3, 2, 48, "unconditional jump long" },
  { "jgno", OP16(0xc0e4LL), MASK_RIL_0P, INSTR_RIL_0P, 3, 2, 112, "conditional jump long on not overflow / if not ones" },
  { "brnol", OP16(0xc0e4LL), MASK_RIL_0P, INSTR_RIL_0P, 3, 2, 112, "conditional jump long on not overflow / if not ones" },
  { "jgnh", OP16(0xc0d4LL), MASK_RIL_0P, INSTR_RIL_0P, 3, 2, 112, "conditional jump long on A not high" },
  { "jgnp", OP16(0xc0d4LL), MASK_RIL_0P, INSTR_RIL_0P, 3, 2, 112, "conditional jump long on not plus" },
  { "brnhl", OP16(0xc0d4LL), MASK_RIL_0P, INSTR_RIL_0P, 3, 2, 112, "conditional jump long on A not high" },
  { "brnpl", OP16(0xc0d4LL), MASK_RIL_0P, INSTR_RIL_0P, 3, 2, 112, "conditional jump long on not plus" },
  { "jgle", OP16(0xc0c4LL), MASK_RIL_0P, INSTR_RIL_0P, 3, 2, 112, "conditional jump long on low or equal" },
  { "brlel", OP16(0xc0c4LL), MASK_RIL_0P, INSTR_RIL_0P, 3, 2, 112, "conditional jump long on low or equal" },
  { "jgnl", OP16(0xc0b4LL), MASK_RIL_0P, INSTR_RIL_0P, 3, 2, 112, "conditional jump long on A not low" },
  { "jgnm", OP16(0xc0b4LL), MASK_RIL_0P, INSTR_RIL_0P, 3, 2, 112, "conditional jump long on not minus / if not mixed" },
  { "brnll", OP16(0xc0b4LL), MASK_RIL_0P, INSTR_RIL_0P, 3, 2, 112, "conditional jump long on A not low" },
  { "brnml", OP16(0xc0b4LL), MASK_RIL_0P, INSTR_RIL_0P, 3, 2, 112, "conditional jump long on not minus / if not mixed" },
  { "jghe", OP16(0xc0a4LL), MASK_RIL_0P, INSTR_RIL_0P, 3, 2, 112, "conditional jump long on high or equal" },
  { "brhel", OP16(0xc0a4LL), MASK_RIL_0P, INSTR_RIL_0P, 3, 2, 112, "conditional jump long on high or equal" },
  { "jgnlh", OP16(0xc094LL), MASK_RIL_0P, INSTR_RIL_0P, 3, 2, 112, "conditional jump long on not low or high" },
  { "brnlhl", OP16(0xc094LL), MASK_RIL_0P, INSTR_RIL_0P, 3, 2, 112, "conditional jump long on not low or high" },
  { "jge", OP16(0xc084LL), MASK_RIL_0P, INSTR_RIL_0P, 3, 2, 112, "conditional jump long on A equal B" },
  { "jgz", OP16(0xc084LL), MASK_RIL_0P, INSTR_RIL_0P, 3, 2, 112, "conditional jump long on zero / if zeros" },
  { "brel", OP16(0xc084LL), MASK_RIL_0P, INSTR_RIL_0P, 3, 2, 112, "conditional jump long on A equal B" },
  { "brzl", OP16(0xc084LL), MASK_RIL_0P, INSTR_RIL_0P, 3, 2, 112, "conditional jump long on zero / if zeros" },
  { "jgne", OP16(0xc074LL), MASK_RIL_0P, INSTR_RIL_0P, 3, 2, 112, "conditional jump long on A not equal B" },
  { "jgnz", OP16(0xc074LL), MASK_RIL_0P, INSTR_RIL_0P, 3, 2, 112, "conditional jump long on not zero / if not zeros" },
  { "brnel", OP16(0xc074LL), MASK_RIL_0P, INSTR_RIL_0P, 3, 2, 112, "conditional jump long on A not equal B" },
  { "brnzl", OP16(0xc074LL), MASK_RIL_0P, INSTR_RIL_0P, 3, 2, 112, "conditional jump long on not zero / if not zeros" },
  { "jglh", OP16(0xc064LL), MASK_RIL_0P, INSTR_RIL_0P, 3, 2, 112, "conditional jump long on low or high" },
  { "brlhl", OP16(0xc064LL), MASK_RIL_0P, INSTR_RIL_0P, 3, 2, 112, "conditional jump long on low or high" },
  { "jgnhe", OP16(0xc054LL), MASK_RIL_0P, INSTR_RIL_0P, 3, 2, 112, "conditional jump long on not high or equal" },
  { "brnhel", OP16(0xc054LL), MASK_RIL_0P, INSTR_RIL_0P, 3, 2, 112, "conditional jump long on not high or equal" },
  { "jgl", OP16(0xc044LL), MASK_RIL_0P, INSTR_RIL_0P, 3, 2, 112, "conditional jump long on A low" },
  { "jgm", OP16(0xc044LL), MASK_RIL_0P, INSTR_RIL_0P, 3, 2, 112, "conditional jump long on minus / if mixed" },
  { "brll", OP16(0xc044LL), MASK_RIL_0P, INSTR_RIL_0P, 3, 2, 112, "conditional jump long on A low" },
  { "brml", OP16(0xc044LL), MASK_RIL_0P, INSTR_RIL_0P, 3, 2, 112, "conditional jump long on minus / if mixed" },
  { "jgnle", OP16(0xc034LL), MASK_RIL_0P, INSTR_RIL_0P, 3, 2, 112, "conditional jump long on not low or equal" },
  { "brnlel", OP16(0xc034LL), MASK_RIL_0P, INSTR_RIL_0P, 3, 2, 112, "conditional jump long on not low or equal" },
  { "jgh", OP16(0xc024LL), MASK_RIL_0P, INSTR_RIL_0P, 3, 2, 112, "conditional jump long on A high" },
  { "jgp", OP16(0xc024LL), MASK_RIL_0P, INSTR_RIL_0P, 3, 2, 112, "conditional jump long on plus" },
  { "brhl", OP16(0xc024LL), MASK_RIL_0P, INSTR_RIL_0P, 3, 2, 112, "conditional jump long on A high" },
  { "brpl", OP16(0xc024LL), MASK_RIL_0P, INSTR_RIL_0P, 3, 2, 112, "conditional jump long on plus" },
  { "jgo", OP16(0xc014LL), MASK_RIL_0P, INSTR_RIL_0P, 3, 2, 112, "conditional jump long on overflow / if ones" },
  { "brol", OP16(0xc014LL), MASK_RIL_0P, INSTR_RIL_0P, 3, 2, 112, "conditional jump long on overflow / if ones" },
  { "llilf", OP16(0xc00fLL), MASK_RIL_RU, INSTR_RIL_RU, 2, 4, 0, "load logical immediate low" },
  { "llgfi", OP16(0xc00fLL), MASK_RIL_RU, INSTR_RIL_RU, 2, 4, 0, "load logical immediate" },
  { "llihf", OP16(0xc00eLL), MASK_RIL_RU, INSTR_RIL_RU, 2, 4, 0, "load logical immediate high" },
  { "oilf", OP16(0xc00dLL), MASK_RIL_RU, INSTR_RIL_RU, 2, 4, 0, "or immediate low" },
  { "oihf", OP16(0xc00cLL), MASK_RIL_RU, INSTR_RIL_RU, 2, 4, 0, "or immediate high" },
  { "nilf", OP16(0xc00bLL), MASK_RIL_RU, INSTR_RIL_RU, 2, 4, 0, "and immediate low" },
  { "nihf", OP16(0xc00aLL), MASK_RIL_RU, INSTR_RIL_RU, 2, 4, 0, "and immediate high" },
  { "iilf", OP16(0xc009LL), MASK_RIL_RU, INSTR_RIL_RU, 2, 4, 0, "insert immediate low" },
  { "lfi", OP16(0xc009LL), MASK_RIL_RU, INSTR_RIL_RU, 2, 4, 0, "insert immediate 32" },
  { "iihf", OP16(0xc008LL), MASK_RIL_RU, INSTR_RIL_RU, 2, 4, 0, "insert immediate high" },
  { "xilf", OP16(0xc007LL), MASK_RIL_RU, INSTR_RIL_RU, 2, 4, 0, "exclusive or immediate low" },
  { "xihf", OP16(0xc006LL), MASK_RIL_RU, INSTR_RIL_RU, 2, 4, 0, "exclusive or immediate high" },
  { "brasl", OP16(0xc005LL), MASK_RIL_RP, INSTR_RIL_RP, 3, 2, 176, "branch relative and save long" },
  { "jasl", OP16(0xc005LL), MASK_RIL_RP, INSTR_RIL_RP, 3, 2, 176, "branch relative and save long" },
  { "brcl", OP16(0xc004LL), MASK_RIL_UP, INSTR_RIL_UP, 3, 2, 112, "branch relative on condition long" },
  { "jgnop", OP16(0xc004LL), MASK_RIL_0P, INSTR_RIL_0P, 3, 2, 0, "nop jump long" },
  { "lgfi", OP16(0xc001LL), MASK_RIL_RI, INSTR_RIL_RI, 2, 4, 0, "load immediate 64<32" },
  { "larl", OP16(0xc000LL), MASK_RIL_RP, INSTR_RIL_RP, 3, 2, 0, "load address relative long" },
  { "icm", OP8(0xbfLL), MASK_RS_RURD, INSTR_RS_RURD, 3, 0, 0, "insert characters under mask" },
  { "stcm", OP8(0xbeLL), MASK_RS_RURD, INSTR_RS_RURD, 3, 0, 0, "store characters under mask" },
  { "clm", OP8(0xbdLL), MASK_RS_RURD, INSTR_RS_RURD, 3, 0, 0, "compare logical characters under mask" },
  { "cds", OP8(0xbbLL), MASK_RS_RERERD, INSTR_RS_RERERD, 3, 0, 0, "compare double and swap" },
  { "cs", OP8(0xbaLL), MASK_RS_RRRD, INSTR_RS_RRRD, 3, 0, 0, "compare and swap" },
  { "msrkc", OP16(0xb9fdLL), MASK_RRF_R0RR2, INSTR_RRF_R0RR2, 2, 10, 0, "multiply single 32x32 -> 32" },
  { "slrk", OP16(0xb9fbLL), MASK_RRF_R0RR2, INSTR_RRF_R0RR2, 2, 7, 0, "subtract logical 3 operands 32 bit" },
  { "alrk", OP16(0xb9faLL), MASK_RRF_R0RR2, INSTR_RRF_R0RR2, 2, 7, 0, "add logical 3 operands 32 bit" },
  { "srk", OP16(0xb9f9LL), MASK_RRF_R0RR2, INSTR_RRF_R0RR2, 2, 7, 0, "subtract 3 operands 32 bit" },
  { "ark", OP16(0xb9f8LL), MASK_RRF_R0RR2, INSTR_RRF_R0RR2, 2, 7, 0, "add 3 operands 32 bit" },
  { "xrk", OP16(0xb9f7LL), MASK_RRF_R0RR2, INSTR_RRF_R0RR2, 2, 7, 0, "xor 3 operands 32 bit" },
  { "ork", OP16(0xb9f6LL), MASK_RRF_R0RR2, INSTR_RRF_R0RR2, 2, 7, 0, "or 3 operands 32 bit" },
  { "ncrk", OP16(0xb9f5LL), MASK_RRF_R0RR2, INSTR_RRF_R0RR2, 2, 11, 0, "and with complement 32 bit" },
  { "nrk", OP16(0xb9f4LL), MASK_RRF_R0RR2, INSTR_RRF_R0RR2, 2, 7, 0, "and 3 operands 32 bit" },
  { "locrno", OP32(0xb9f2e000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 7, 0, "load on condition 32 bit on not overflow / if not ones" },
  { "locrnh", OP32(0xb9f2d000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 7, 0, "load on condition 32 bit on A not high" },
  { "locrnp", OP32(0xb9f2d000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 7, 0, "load on condition 32 bit on not plus" },
  { "locrle", OP32(0xb9f2c000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 7, 0, "load on condition 32 bit on low or equal" },
  { "locrnl", OP32(0xb9f2b000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 7, 0, "load on condition 32 bit on A not low" },
  { "locrnm", OP32(0xb9f2b000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 7, 0, "load on condition 32 bit on not minus / if not mixed" },
  { "locrhe", OP32(0xb9f2a000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 7, 0, "load on condition 32 bit on high or equal" },
  { "locrnlh", OP32(0xb9f29000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 7, 0, "load on condition 32 bit on not low or high" },
  { "locre", OP32(0xb9f28000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 7, 0, "load on condition 32 bit on A equal B" },
  { "locrz", OP32(0xb9f28000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 7, 0, "load on condition 32 bit on zero / if zeros" },
  { "locrne", OP32(0xb9f27000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 7, 0, "load on condition 32 bit on A not equal B" },
  { "locrnz", OP32(0xb9f27000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 7, 0, "load on condition 32 bit on not zero / if not zeros" },
  { "locrlh", OP32(0xb9f26000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 7, 0, "load on condition 32 bit on low or high" },
  { "locrnhe", OP32(0xb9f25000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 7, 0, "load on condition 32 bit on not high or equal" },
  { "locrl", OP32(0xb9f24000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 7, 0, "load on condition 32 bit on A low" },
  { "locrm", OP32(0xb9f24000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 7, 0, "load on condition 32 bit on minus / if mixed" },
  { "locrnle", OP32(0xb9f23000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 7, 0, "load on condition 32 bit on not low or equal" },
  { "locrh", OP32(0xb9f22000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 7, 0, "load on condition 32 bit on A high" },
  { "locrp", OP32(0xb9f22000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 7, 0, "load on condition 32 bit on plus" },
  { "locro", OP32(0xb9f21000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 7, 0, "load on condition 32 bit on overflow / if ones" },
  { "locr", OP16(0xb9f2LL), MASK_RRF_U0RR, INSTR_RRF_U0RR, 2, 7, 0, "load on condition 32 bit" },
  { "selrno", OP32(0xb9f00e00LL), MASK_RRF_R0RR3, INSTR_RRF_R0RR3, 2, 11, 0, "select 32 bit on not overflow / if not ones" },
  { "selrnh", OP32(0xb9f00d00LL), MASK_RRF_R0RR3, INSTR_RRF_R0RR3, 2, 11, 0, "select 32 bit on A not high" },
  { "selrnp", OP32(0xb9f00d00LL), MASK_RRF_R0RR3, INSTR_RRF_R0RR3, 2, 11, 0, "select 32 bit on not plus" },
  { "selrle", OP32(0xb9f00c00LL), MASK_RRF_R0RR3, INSTR_RRF_R0RR3, 2, 11, 0, "select 32 bit on low or equal" },
  { "selrnl", OP32(0xb9f00b00LL), MASK_RRF_R0RR3, INSTR_RRF_R0RR3, 2, 11, 0, "select 32 bit on A not low" },
  { "selrnm", OP32(0xb9f00b00LL), MASK_RRF_R0RR3, INSTR_RRF_R0RR3, 2, 11, 0, "select 32 bit on not minus / if not mixed" },
  { "selrhe", OP32(0xb9f00a00LL), MASK_RRF_R0RR3, INSTR_RRF_R0RR3, 2, 11, 0, "select 32 bit on high or equal" },
  { "selrnlh", OP32(0xb9f00900LL), MASK_RRF_R0RR3, INSTR_RRF_R0RR3, 2, 11, 0, "select 32 bit on not low or high" },
  { "selre", OP32(0xb9f00800LL), MASK_RRF_R0RR3, INSTR_RRF_R0RR3, 2, 11, 0, "select 32 bit on A equal B" },
  { "selrz", OP32(0xb9f00800LL), MASK_RRF_R0RR3, INSTR_RRF_R0RR3, 2, 11, 0, "select 32 bit on zero / if zeros" },
  { "selrne", OP32(0xb9f00700LL), MASK_RRF_R0RR3, INSTR_RRF_R0RR3, 2, 11, 0, "select 32 bit on A not equal B" },
  { "selrnz", OP32(0xb9f00700LL), MASK_RRF_R0RR3, INSTR_RRF_R0RR3, 2, 11, 0, "select 32 bit on not zero / if not zeros" },
  { "selrlh", OP32(0xb9f00600LL), MASK_RRF_R0RR3, INSTR_RRF_R0RR3, 2, 11, 0, "select 32 bit on low or high" },
  { "selrnhe", OP32(0xb9f00500LL), MASK_RRF_R0RR3, INSTR_RRF_R0RR3, 2, 11, 0, "select 32 bit on not high or equal" },
  { "selrl", OP32(0xb9f00400LL), MASK_RRF_R0RR3, INSTR_RRF_R0RR3, 2, 11, 0, "select 32 bit on A low" },
  { "selrm", OP32(0xb9f00400LL), MASK_RRF_R0RR3, INSTR_RRF_R0RR3, 2, 11, 0, "select 32 bit on minus / if mixed" },
  { "selrnle", OP32(0xb9f00300LL), MASK_RRF_R0RR3, INSTR_RRF_R0RR3, 2, 11, 0, "select 32 bit on not low or equal" },
  { "selrh", OP32(0xb9f00200LL), MASK_RRF_R0RR3, INSTR_RRF_R0RR3, 2, 11, 0, "select 32 bit on A high" },
  { "selrp", OP32(0xb9f00200LL), MASK_RRF_R0RR3, INSTR_RRF_R0RR3, 2, 11, 0, "select 32 bit on plus" },
  { "selro", OP32(0xb9f00100LL), MASK_RRF_R0RR3, INSTR_RRF_R0RR3, 2, 11, 0, "select 32 bit on overflow / if ones" },
  { "selr", OP16(0xb9f0LL), MASK_RRF_RURR, INSTR_RRF_RURR, 2, 11, 0, "select 32 bit" },
  { "msgrkc", OP16(0xb9edLL), MASK_RRF_R0RR2, INSTR_RRF_R0RR2, 2, 10, 0, "multiply single 64x64 -> 64" },
  { "mgrk", OP16(0xb9ecLL), MASK_RRF_R0RER, INSTR_RRF_R0RER, 2, 10, 0, "multiply 64x64reg -> 128" },
  { "slgrk", OP16(0xb9ebLL), MASK_RRF_R0RR2, INSTR_RRF_R0RR2, 2, 7, 0, "subtract logical 3 operands 64 bit" },
  { "algrk", OP16(0xb9eaLL), MASK_RRF_R0RR2, INSTR_RRF_R0RR2, 2, 7, 0, "add logical 3 operands 64 bit" },
  { "sgrk", OP16(0xb9e9LL), MASK_RRF_R0RR2, INSTR_RRF_R0RR2, 2, 7, 0, "subtract 3 operands 64 bit" },
  { "agrk", OP16(0xb9e8LL), MASK_RRF_R0RR2, INSTR_RRF_R0RR2, 2, 7, 0, "add 3 operands 64 bit" },
  { "xgrk", OP16(0xb9e7LL), MASK_RRF_R0RR2, INSTR_RRF_R0RR2, 2, 7, 0, "xor 3 operands 64 bit" },
  { "ogrk", OP16(0xb9e6LL), MASK_RRF_R0RR2, INSTR_RRF_R0RR2, 2, 7, 0, "or 3 operands 64 bit" },
  { "ncgrk", OP16(0xb9e5LL), MASK_RRF_R0RR2, INSTR_RRF_R0RR2, 2, 11, 0, "and with complement 64 bit" },
  { "ngrk", OP16(0xb9e4LL), MASK_RRF_R0RR2, INSTR_RRF_R0RR2, 2, 7, 0, "and 3 operands 64 bit" },
  { "selgrno", OP32(0xb9e30e00LL), MASK_RRF_R0RR3, INSTR_RRF_R0RR3, 2, 11, 0, "select 64 bit on not overflow / if not ones" },
  { "selgrnh", OP32(0xb9e30d00LL), MASK_RRF_R0RR3, INSTR_RRF_R0RR3, 2, 11, 0, "select 64 bit on A not high" },
  { "selgrnp", OP32(0xb9e30d00LL), MASK_RRF_R0RR3, INSTR_RRF_R0RR3, 2, 11, 0, "select 64 bit on not plus" },
  { "selgrle", OP32(0xb9e30c00LL), MASK_RRF_R0RR3, INSTR_RRF_R0RR3, 2, 11, 0, "select 64 bit on low or equal" },
  { "selgrnl", OP32(0xb9e30b00LL), MASK_RRF_R0RR3, INSTR_RRF_R0RR3, 2, 11, 0, "select 64 bit on A not low" },
  { "selgrnm", OP32(0xb9e30b00LL), MASK_RRF_R0RR3, INSTR_RRF_R0RR3, 2, 11, 0, "select 64 bit on not minus / if not mixed" },
  { "selgrhe", OP32(0xb9e30a00LL), MASK_RRF_R0RR3, INSTR_RRF_R0RR3, 2, 11, 0, "select 64 bit on high or equal" },
  { "selgrnlh", OP32(0xb9e30900LL), MASK_RRF_R0RR3, INSTR_RRF_R0RR3, 2, 11, 0, "select 64 bit on not low or high" },
  { "selgre", OP32(0xb9e30800LL), MASK_RRF_R0RR3, INSTR_RRF_R0RR3, 2, 11, 0, "select 64 bit on A equal B" },
  { "selgrz", OP32(0xb9e30800LL), MASK_RRF_R0RR3, INSTR_RRF_R0RR3, 2, 11, 0, "select 64 bit on zero / if zeros" },
  { "selgrne", OP32(0xb9e30700LL), MASK_RRF_R0RR3, INSTR_RRF_R0RR3, 2, 11, 0, "select 64 bit on A not equal B" },
  { "selgrnz", OP32(0xb9e30700LL), MASK_RRF_R0RR3, INSTR_RRF_R0RR3, 2, 11, 0, "select 64 bit on not zero / if not zeros" },
  { "selgrlh", OP32(0xb9e30600LL), MASK_RRF_R0RR3, INSTR_RRF_R0RR3, 2, 11, 0, "select 64 bit on low or high" },
  { "selgrnhe", OP32(0xb9e30500LL), MASK_RRF_R0RR3, INSTR_RRF_R0RR3, 2, 11, 0, "select 64 bit on not high or equal" },
  { "selgrl", OP32(0xb9e30400LL), MASK_RRF_R0RR3, INSTR_RRF_R0RR3, 2, 11, 0, "select 64 bit on A low" },
  { "selgrm", OP32(0xb9e30400LL), MASK_RRF_R0RR3, INSTR_RRF_R0RR3, 2, 11, 0, "select 64 bit on minus / if mixed" },
  { "selgrnle", OP32(0xb9e30300LL), MASK_RRF_R0RR3, INSTR_RRF_R0RR3, 2, 11, 0, "select 64 bit on not low or equal" },
  { "selgrh", OP32(0xb9e30200LL), MASK_RRF_R0RR3, INSTR_RRF_R0RR3, 2, 11, 0, "select 64 bit on A high" },
  { "selgrp", OP32(0xb9e30200LL), MASK_RRF_R0RR3, INSTR_RRF_R0RR3, 2, 11, 0, "select 64 bit on plus" },
  { "selgro", OP32(0xb9e30100LL), MASK_RRF_R0RR3, INSTR_RRF_R0RR3, 2, 11, 0, "select 64 bit on overflow / if ones" },
  { "selgr", OP16(0xb9e3LL), MASK_RRF_RURR, INSTR_RRF_RURR, 2, 11, 0, "select 64 bit" },
  { "locgrno", OP32(0xb9e2e000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 7, 0, "load on condition 64  bit on not overflow / if not ones" },
  { "locgrnh", OP32(0xb9e2d000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 7, 0, "load on condition 64  bit on A not high" },
  { "locgrnp", OP32(0xb9e2d000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 7, 0, "load on condition 64  bit on not plus" },
  { "locgrle", OP32(0xb9e2c000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 7, 0, "load on condition 64  bit on low or equal" },
  { "locgrnl", OP32(0xb9e2b000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 7, 0, "load on condition 64  bit on A not low" },
  { "locgrnm", OP32(0xb9e2b000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 7, 0, "load on condition 64  bit on not minus / if not mixed" },
  { "locgrhe", OP32(0xb9e2a000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 7, 0, "load on condition 64  bit on high or equal" },
  { "locgrnlh", OP32(0xb9e29000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 7, 0, "load on condition 64  bit on not low or high" },
  { "locgre", OP32(0xb9e28000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 7, 0, "load on condition 64  bit on A equal B" },
  { "locgrz", OP32(0xb9e28000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 7, 0, "load on condition 64  bit on zero / if zeros" },
  { "locgrne", OP32(0xb9e27000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 7, 0, "load on condition 64  bit on A not equal B" },
  { "locgrnz", OP32(0xb9e27000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 7, 0, "load on condition 64  bit on not zero / if not zeros" },
  { "locgrlh", OP32(0xb9e26000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 7, 0, "load on condition 64  bit on low or high" },
  { "locgrnhe", OP32(0xb9e25000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 7, 0, "load on condition 64  bit on not high or equal" },
  { "locgrl", OP32(0xb9e24000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 7, 0, "load on condition 64  bit on A low" },
  { "locgrm", OP32(0xb9e24000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 7, 0, "load on condition 64  bit on minus / if mixed" },
  { "locgrnle", OP32(0xb9e23000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 7, 0, "load on condition 64  bit on not low or equal" },
  { "locgrh", OP32(0xb9e22000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 7, 0, "load on condition 64  bit on A high" },
  { "locgrp", OP32(0xb9e22000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 7, 0, "load on condition 64  bit on plus" },
  { "locgro", OP32(0xb9e21000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 7, 0, "load on condition 64  bit on overflow / if ones" },
  { "locgr", OP16(0xb9e2LL), MASK_RRF_U0RR, INSTR_RRF_U0RR, 2, 7, 0, "load on condition 64  bit" },
  { "popcnt", OP16(0xb9e1LL), MASK_RRF_U0RR, INSTR_RRF_U0RR, 2, 11, 1, "population count arch13" },
  { "popcnt", OP16(0xb9e1LL), MASK_RRE_RR, INSTR_RRE_RR, 2, 7, 0, "population count" },
  { "locfhrno", OP32(0xb9e0e000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 9, 0, "load high on condition from gpr on not overflow / if not ones" },
  { "locfhrnh", OP32(0xb9e0d000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 9, 0, "load high on condition from gpr on A not high" },
  { "locfhrnp", OP32(0xb9e0d000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 9, 0, "load high on condition from gpr on not plus" },
  { "locfhrle", OP32(0xb9e0c000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 9, 0, "load high on condition from gpr on low or equal" },
  { "locfhrnl", OP32(0xb9e0b000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 9, 0, "load high on condition from gpr on A not low" },
  { "locfhrnm", OP32(0xb9e0b000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 9, 0, "load high on condition from gpr on not minus / if not mixed" },
  { "locfhrhe", OP32(0xb9e0a000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 9, 0, "load high on condition from gpr on high or equal" },
  { "locfhrnlh", OP32(0xb9e09000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 9, 0, "load high on condition from gpr on not low or high" },
  { "locfhre", OP32(0xb9e08000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 9, 0, "load high on condition from gpr on A equal B" },
  { "locfhrz", OP32(0xb9e08000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 9, 0, "load high on condition from gpr on zero / if zeros" },
  { "locfhrne", OP32(0xb9e07000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 9, 0, "load high on condition from gpr on A not equal B" },
  { "locfhrnz", OP32(0xb9e07000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 9, 0, "load high on condition from gpr on not zero / if not zeros" },
  { "locfhrlh", OP32(0xb9e06000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 9, 0, "load high on condition from gpr on low or high" },
  { "locfhrnhe", OP32(0xb9e05000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 9, 0, "load high on condition from gpr on not high or equal" },
  { "locfhrl", OP32(0xb9e04000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 9, 0, "load high on condition from gpr on A low" },
  { "locfhrm", OP32(0xb9e04000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 9, 0, "load high on condition from gpr on minus / if mixed" },
  { "locfhrnle", OP32(0xb9e03000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 9, 0, "load high on condition from gpr on not low or equal" },
  { "locfhrh", OP32(0xb9e02000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 9, 0, "load high on condition from gpr on A high" },
  { "locfhrp", OP32(0xb9e02000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 9, 0, "load high on condition from gpr on plus" },
  { "locfhro", OP32(0xb9e01000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 9, 0, "load high on condition from gpr on overflow / if ones" },
  { "locfhr", OP16(0xb9e0LL), MASK_RRF_U0RR, INSTR_RRF_U0RR, 2, 9, 0, "load high on condition from gpr" },
  { "clhlr", OP16(0xb9dfLL), MASK_RRE_RR, INSTR_RRE_RR, 2, 7, 0, "compare logical high low" },
  { "chlr", OP16(0xb9ddLL), MASK_RRE_RR, INSTR_RRE_RR, 2, 7, 0, "compare high low" },
  { "slhhlr", OP16(0xb9dbLL), MASK_RRF_R0RR2, INSTR_RRF_R0RR2, 2, 7, 0, "subtract logical high low" },
  { "alhhlr", OP16(0xb9daLL), MASK_RRF_R0RR2, INSTR_RRF_R0RR2, 2, 7, 0, "add logical high low" },
  { "shhlr", OP16(0xb9d9LL), MASK_RRF_R0RR2, INSTR_RRF_R0RR2, 2, 7, 0, "subtract high low" },
  { "ahhlr", OP16(0xb9d8LL), MASK_RRF_R0RR2, INSTR_RRF_R0RR2, 2, 7, 0, "add high low" },
  { "clhhr", OP16(0xb9cfLL), MASK_RRE_RR, INSTR_RRE_RR, 2, 7, 0, "compare logical high high" },
  { "chhr", OP16(0xb9cdLL), MASK_RRE_RR, INSTR_RRE_RR, 2, 7, 0, "compare high high" },
  { "slhhhr", OP16(0xb9cbLL), MASK_RRF_R0RR2, INSTR_RRF_R0RR2, 2, 7, 0, "subtract logical high high" },
  { "alhhhr", OP16(0xb9caLL), MASK_RRF_R0RR2, INSTR_RRF_R0RR2, 2, 7, 0, "add logical high high" },
  { "shhhr", OP16(0xb9c9LL), MASK_RRF_R0RR2, INSTR_RRF_R0RR2, 2, 7, 0, "subtract high high" },
  { "ahhhr", OP16(0xb9c8LL), MASK_RRF_R0RR2, INSTR_RRF_R0RR2, 2, 7, 0, "add high high" },
  { "selfhrno", OP32(0xb9c00e00LL), MASK_RRF_R0RR3, INSTR_RRF_R0RR3, 2, 11, 0, "select high on not overflow / if not ones" },
  { "selfhrnh", OP32(0xb9c00d00LL), MASK_RRF_R0RR3, INSTR_RRF_R0RR3, 2, 11, 0, "select high on A not high" },
  { "selfhrnp", OP32(0xb9c00d00LL), MASK_RRF_R0RR3, INSTR_RRF_R0RR3, 2, 11, 0, "select high on not plus" },
  { "selfhrle", OP32(0xb9c00c00LL), MASK_RRF_R0RR3, INSTR_RRF_R0RR3, 2, 11, 0, "select high on low or equal" },
  { "selfhrnl", OP32(0xb9c00b00LL), MASK_RRF_R0RR3, INSTR_RRF_R0RR3, 2, 11, 0, "select high on A not low" },
  { "selfhrnm", OP32(0xb9c00b00LL), MASK_RRF_R0RR3, INSTR_RRF_R0RR3, 2, 11, 0, "select high on not minus / if not mixed" },
  { "selfhrhe", OP32(0xb9c00a00LL), MASK_RRF_R0RR3, INSTR_RRF_R0RR3, 2, 11, 0, "select high on high or equal" },
  { "selfhrnlh", OP32(0xb9c00900LL), MASK_RRF_R0RR3, INSTR_RRF_R0RR3, 2, 11, 0, "select high on not low or high" },
  { "selfhre", OP32(0xb9c00800LL), MASK_RRF_R0RR3, INSTR_RRF_R0RR3, 2, 11, 0, "select high on A equal B" },
  { "selfhrz", OP32(0xb9c00800LL), MASK_RRF_R0RR3, INSTR_RRF_R0RR3, 2, 11, 0, "select high on zero / if zeros" },
  { "selfhrne", OP32(0xb9c00700LL), MASK_RRF_R0RR3, INSTR_RRF_R0RR3, 2, 11, 0, "select high on A not equal B" },
  { "selfhrnz", OP32(0xb9c00700LL), MASK_RRF_R0RR3, INSTR_RRF_R0RR3, 2, 11, 0, "select high on not zero / if not zeros" },
  { "selfhrlh", OP32(0xb9c00600LL), MASK_RRF_R0RR3, INSTR_RRF_R0RR3, 2, 11, 0, "select high on low or high" },
  { "selfhrnhe", OP32(0xb9c00500LL), MASK_RRF_R0RR3, INSTR_RRF_R0RR3, 2, 11, 0, "select high on not high or equal" },
  { "selfhrl", OP32(0xb9c00400LL), MASK_RRF_R0RR3, INSTR_RRF_R0RR3, 2, 11, 0, "select high on A low" },
  { "selfhrm", OP32(0xb9c00400LL), MASK_RRF_R0RR3, INSTR_RRF_R0RR3, 2, 11, 0, "select high on minus / if mixed" },
  { "selfhrnle", OP32(0xb9c00300LL), MASK_RRF_R0RR3, INSTR_RRF_R0RR3, 2, 11, 0, "select high on not low or equal" },
  { "selfhrh", OP32(0xb9c00200LL), MASK_RRF_R0RR3, INSTR_RRF_R0RR3, 2, 11, 0, "select high on A high" },
  { "selfhrp", OP32(0xb9c00200LL), MASK_RRF_R0RR3, INSTR_RRF_R0RR3, 2, 11, 0, "select high on plus" },
  { "selfhro", OP32(0xb9c00100LL), MASK_RRF_R0RR3, INSTR_RRF_R0RR3, 2, 11, 0, "select high on overflow / if ones" },
  { "selfhr", OP16(0xb9c0LL), MASK_RRF_RURR, INSTR_RRF_RURR, 2, 11, 0, "select high" },
  { "trte", OP16(0xb9bfLL), MASK_RRF_U0RER, INSTR_RRF_U0RER, 2, 6, 1, "translate and test extended" },
  { "srstu", OP16(0xb9beLL), MASK_RRE_RR, INSTR_RRE_RR, 2, 4, 0, "search string unicode" },
  { "trtre", OP16(0xb9bdLL), MASK_RRF_U0RER, INSTR_RRF_U0RER, 2, 6, 1, "translate and test reverse extended" },
  { "cu42", OP16(0xb9b3LL), MASK_RRE_RERE, INSTR_RRE_RERE, 2, 4, 0, "convert utf-32 to utf-16" },
  { "cu41", OP16(0xb9b2LL), MASK_RRE_RERE, INSTR_RRE_RERE, 2, 4, 0, "convert utf-32 to utf-8" },
  { "cu24", OP16(0xb9b1LL), MASK_RRF_U0RERE, INSTR_RRF_U0RERE, 2, 4, 1, "convert utf-16 to utf-32" },
  { "cu14", OP16(0xb9b0LL), MASK_RRF_U0RERE, INSTR_RRF_U0RERE, 2, 4, 1, "convert utf-8 to utf-32" },
  { "pfmf", OP16(0xb9afLL), MASK_RRE_RR, INSTR_RRE_RR, 2, 6, 0, "perform frame management function" },
  { "rrbm", OP16(0xb9aeLL), MASK_RRE_RR, INSTR_RRE_RR, 2, 7, 0, "reset reference bits multiple" },
  { "irbm", OP16(0xb9acLL), MASK_RRE_RR, INSTR_RRE_RR, 2, 10, 0, "insert reference bits multiple" },
  { "lptea", OP16(0xb9aaLL), MASK_RRF_RURR2, INSTR_RRF_RURR2, 2, 4, 0, "load page-table-entry address" },
  { "ptf", OP16(0xb9a2LL), MASK_RRE_R0, INSTR_RRE_R0, 2, 6, 0, "perform topology function" },
  { "tpei", OP16(0xb9a1LL), MASK_RRE_RR, INSTR_RRE_RR, 2, 10, 0, "test pending external interruption" },
  { "ssair", OP16(0xb99fLL), MASK_RRE_R0, INSTR_RRE_R0, 3, 3, 0, "set secondary ASN with instance" },
  { "pti", OP16(0xb99eLL), MASK_RRE_RR, INSTR_RRE_RR, 3, 3, 0, "program transfer with instance" },
  { "esea", OP16(0xb99dLL), MASK_RRE_R0, INSTR_RRE_R0, 2, 2, 0, "extract and set extended authority" },
  { "esair", OP16(0xb99bLL), MASK_RRE_R0, INSTR_RRE_R0, 3, 3, 0, "extract secondary ASN and instance" },
  { "epair", OP16(0xb99aLL), MASK_RRE_R0, INSTR_RRE_R0, 3, 3, 0, "extract primary ASN and instance" },
  { "slbr", OP16(0xb999LL), MASK_RRE_RR, INSTR_RRE_RR, 3, 2, 0, "subtract logical with borrow 32" },
  { "alcr", OP16(0xb998LL), MASK_RRE_RR, INSTR_RRE_RR, 3, 2, 0, "add logical with carry 32" },
  { "dlr", OP16(0xb997LL), MASK_RRE_RER, INSTR_RRE_RER, 3, 2, 0, "divide logical 32" },
  { "mlr", OP16(0xb996LL), MASK_RRE_RER, INSTR_RRE_RER, 3, 2, 0, "multiply logical 32" },
  { "llhr", OP16(0xb995LL), MASK_RRE_RR, INSTR_RRE_RR, 2, 4, 0, "load logical halfword 32" },
  { "llcr", OP16(0xb994LL), MASK_RRE_RR, INSTR_RRE_RR, 2, 4, 0, "load logical character 32" },
  { "troo", OP16(0xb993LL), MASK_RRF_U0RER, INSTR_RRF_U0RER, 3, 4, 1, "translate one to one" },
  { "troo", OP16(0xb993LL), MASK_RRE_RER, INSTR_RRE_RER, 3, 0, 0, "translate one to one" },
  { "trot", OP16(0xb992LL), MASK_RRF_U0RER, INSTR_RRF_U0RER, 3, 4, 1, "translate one to two" },
  { "trot", OP16(0xb992LL), MASK_RRE_RER, INSTR_RRE_RER, 3, 0, 0, "translate one to two" },
  { "trto", OP16(0xb991LL), MASK_RRF_U0RER, INSTR_RRF_U0RER, 3, 4, 1, "translate two to one" },
  { "trto", OP16(0xb991LL), MASK_RRE_RER, INSTR_RRE_RER, 3, 0, 0, "translate two to one" },
  { "trtt", OP16(0xb990LL), MASK_RRF_U0RER, INSTR_RRF_U0RER, 3, 4, 1, "translate two to two" },
  { "trtt", OP16(0xb990LL), MASK_RRE_RER, INSTR_RRE_RER, 3, 0, 0, "translate two to two" },
  { "crdte", OP16(0xb98fLL), MASK_RRF_RURR2, INSTR_RRF_RURR2, 2, 8, 1, "compare and replace DAT table entry" },
  { "idte", OP16(0xb98eLL), MASK_RRF_RURR2, INSTR_RRF_RURR2, 2, 3, 1, "invalidate dat table entry" },
  { "epsw", OP16(0xb98dLL), MASK_RRE_RR, INSTR_RRE_RR, 3, 2, 0, "extract psw" },
  { "rdp", OP16(0xb98bLL), MASK_RRF_RURR2, INSTR_RRF_RURR2, 2, 12, 1, "reset dat protection" },
  { "cspg", OP16(0xb98aLL), MASK_RRE_RR, INSTR_RRE_RR, 2, 3, 0, "compare and swap and purge" },
  { "slbgr", OP16(0xb989LL), MASK_RRE_RR, INSTR_RRE_RR, 2, 2, 0, "subtract logical with borrow 64" },
  { "alcgr", OP16(0xb988LL), MASK_RRE_RR, INSTR_RRE_RR, 2, 2, 0, "add logical with carry 64" },
  { "dlgr", OP16(0xb987LL), MASK_RRE_RER, INSTR_RRE_RER, 2, 2, 0, "divide logical 64" },
  { "mlgr", OP16(0xb986LL), MASK_RRE_RER, INSTR_RRE_RER, 2, 2, 0, "multiply logical 64" },
  { "llghr", OP16(0xb985LL), MASK_RRE_RR, INSTR_RRE_RR, 2, 4, 0, "load logical halfword 64" },
  { "llgcr", OP16(0xb984LL), MASK_RRE_RR, INSTR_RRE_RR, 2, 4, 0, "load logical character 64" },
  { "flogr", OP16(0xb983LL), MASK_RRE_RER, INSTR_RRE_RER, 2, 4, 0, "find leftmost one" },
  { "xgr", OP16(0xb982LL), MASK_RRE_RR, INSTR_RRE_RR, 2, 2, 0, "exclusive or 64" },
  { "ogr", OP16(0xb981LL), MASK_RRE_RR, INSTR_RRE_RR, 2, 2, 0, "or 64" },
  { "ngr", OP16(0xb980LL), MASK_RRE_RR, INSTR_RRE_RR, 2, 2, 0, "and 64" },
  { "nxrk", OP16(0xb977LL), MASK_RRF_R0RR2, INSTR_RRF_R0RR2, 2, 11, 0, "not exclusive or 32 bit" },
  { "nork", OP16(0xb976LL), MASK_RRF_R0RR2, INSTR_RRF_R0RR2, 2, 11, 0, "nor 32 bit" },
  { "notr", OP16(0xb976LL), MASK_RRF_R0RR4, INSTR_RRF_R0RR4, 2, 11, 0, "not 32 bit" },
  { "ocrk", OP16(0xb975LL), MASK_RRF_R0RR2, INSTR_RRF_R0RR2, 2, 11, 0, "or with complement 32 bit" },
  { "nnrk", OP16(0xb974LL), MASK_RRF_R0RR2, INSTR_RRF_R0RR2, 2, 11, 0, "nand 32 bit" },
  { "clrtnh", OP32(0xb973c000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 6, 0, "compare logical and trap (32) on A not high" },
  { "clrtle", OP32(0xb973c000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 6, 0, "compare logical and trap (32) on low or equal" },
  { "clrtnl", OP32(0xb973a000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 6, 0, "compare logical and trap (32) on A not low" },
  { "clrthe", OP32(0xb973a000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 6, 0, "compare logical and trap (32) on high or equal" },
  { "clrte", OP32(0xb9738000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 6, 0, "compare logical and trap (32) on A equal B" },
  { "clrtnlh", OP32(0xb9738000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 6, 0, "compare logical and trap (32) on not low or high" },
  { "clrtne", OP32(0xb9736000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 6, 0, "compare logical and trap (32) on A not equal B" },
  { "clrtlh", OP32(0xb9736000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 6, 0, "compare logical and trap (32) on low or high" },
  { "clrtl", OP32(0xb9734000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 6, 0, "compare logical and trap (32) on A low" },
  { "clrtnhe", OP32(0xb9734000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 6, 0, "compare logical and trap (32) on not high or equal" },
  { "clrth", OP32(0xb9732000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 6, 0, "compare logical and trap (32) on A high" },
  { "clrtnle", OP32(0xb9732000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 6, 0, "compare logical and trap (32) on not low or equal" },
  { "clrt", OP16(0xb973LL), MASK_RRF_U0RR, INSTR_RRF_U0RR, 2, 6, 0, "compare logical and trap (32)" },
  { "crtnh", OP32(0xb972c000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 6, 0, "compare and trap on A not high" },
  { "crtle", OP32(0xb972c000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 6, 0, "compare and trap on low or equal" },
  { "crtnl", OP32(0xb972a000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 6, 0, "compare and trap on A not low" },
  { "crthe", OP32(0xb972a000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 6, 0, "compare and trap on high or equal" },
  { "crte", OP32(0xb9728000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 6, 0, "compare and trap on A equal B" },
  { "crtnlh", OP32(0xb9728000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 6, 0, "compare and trap on not low or high" },
  { "crtne", OP32(0xb9726000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 6, 0, "compare and trap on A not equal B" },
  { "crtlh", OP32(0xb9726000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 6, 0, "compare and trap on low or high" },
  { "crtl", OP32(0xb9724000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 6, 0, "compare and trap on A low" },
  { "crtnhe", OP32(0xb9724000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 6, 0, "compare and trap on not high or equal" },
  { "crth", OP32(0xb9722000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 6, 0, "compare and trap on A high" },
  { "crtnle", OP32(0xb9722000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 6, 0, "compare and trap on not low or equal" },
  { "crt", OP16(0xb972LL), MASK_RRF_U0RR, INSTR_RRF_U0RR, 2, 6, 0, "compare and trap" },
  { "bdepg", OP16(0xb96dLL), MASK_RRF_R0RR2, INSTR_RRF_R0RR2, 2, 13, 0, "bit deposit" },
  { "bextg", OP16(0xb96cLL), MASK_RRF_R0RR2, INSTR_RRF_R0RR2, 2, 13, 0, "bit extract" },
  { "ctzg", OP16(0xb969LL), MASK_RRE_RR, INSTR_RRE_RR, 2, 13, 0, "count trailing zeros" },
  { "clzg", OP16(0xb968LL), MASK_RRE_RR, INSTR_RRE_RR, 2, 13, 0, "count leading zeros" },
  { "nxgrk", OP16(0xb967LL), MASK_RRF_R0RR2, INSTR_RRF_R0RR2, 2, 11, 0, "not exclusive or 64 bit" },
  { "nogrk", OP16(0xb966LL), MASK_RRF_R0RR2, INSTR_RRF_R0RR2, 2, 11, 0, "nor 64 bit" },
  { "notgr", OP16(0xb966LL), MASK_RRF_R0RR4, INSTR_RRF_R0RR4, 2, 11, 0, "not 64 bit" },
  { "ocgrk", OP16(0xb965LL), MASK_RRF_R0RR2, INSTR_RRF_R0RR2, 2, 11, 0, "or with complement 64 bit" },
  { "nngrk", OP16(0xb964LL), MASK_RRF_R0RR2, INSTR_RRF_R0RR2, 2, 11, 0, "nand 64 bit" },
  { "clgrtnh", OP32(0xb961c000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 6, 0, "compare logical and trap (64) on A not high" },
  { "clgrtle", OP32(0xb961c000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 6, 0, "compare logical and trap (64) on low or equal" },
  { "clgrtnl", OP32(0xb961a000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 6, 0, "compare logical and trap (64) on A not low" },
  { "clgrthe", OP32(0xb961a000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 6, 0, "compare logical and trap (64) on high or equal" },
  { "clgrte", OP32(0xb9618000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 6, 0, "compare logical and trap (64) on A equal B" },
  { "clgrtnlh", OP32(0xb9618000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 6, 0, "compare logical and trap (64) on not low or high" },
  { "clgrtne", OP32(0xb9616000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 6, 0, "compare logical and trap (64) on A not equal B" },
  { "clgrtlh", OP32(0xb9616000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 6, 0, "compare logical and trap (64) on low or high" },
  { "clgrtl", OP32(0xb9614000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 6, 0, "compare logical and trap (64) on A low" },
  { "clgrtnhe", OP32(0xb9614000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 6, 0, "compare logical and trap (64) on not high or equal" },
  { "clgrth", OP32(0xb9612000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 6, 0, "compare logical and trap (64) on A high" },
  { "clgrtnle", OP32(0xb9612000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 6, 0, "compare logical and trap (64) on not low or equal" },
  { "clgrt", OP16(0xb961LL), MASK_RRF_U0RR, INSTR_RRF_U0RR, 2, 6, 0, "compare logical and trap (64)" },
  { "cgrtnh", OP32(0xb960c000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 6, 0, "compare and trap 64 on A not high" },
  { "cgrtle", OP32(0xb960c000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 6, 0, "compare and trap 64 on low or equal" },
  { "cgrtnl", OP32(0xb960a000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 6, 0, "compare and trap 64 on A not low" },
  { "cgrthe", OP32(0xb960a000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 6, 0, "compare and trap 64 on high or equal" },
  { "cgrte", OP32(0xb9608000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 6, 0, "compare and trap 64 on A equal B" },
  { "cgrtnlh", OP32(0xb9608000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 6, 0, "compare and trap 64 on not low or high" },
  { "cgrtne", OP32(0xb9606000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 6, 0, "compare and trap 64 on A not equal B" },
  { "cgrtlh", OP32(0xb9606000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 6, 0, "compare and trap 64 on low or high" },
  { "cgrtl", OP32(0xb9604000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 6, 0, "compare and trap 64 on A low" },
  { "cgrtnhe", OP32(0xb9604000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 6, 0, "compare and trap 64 on not high or equal" },
  { "cgrth", OP32(0xb9602000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 6, 0, "compare and trap 64 on A high" },
  { "cgrtnle", OP32(0xb9602000LL), MASK_RRF_00RR, INSTR_RRF_00RR, 2, 6, 0, "compare and trap 64 on not low or equal" },
  { "cgrt", OP16(0xb960LL), MASK_RRF_U0RR, INSTR_RRF_U0RR, 2, 6, 0, "compare and trap 64" },
  { "cxlftr", OP16(0xb95bLL), MASK_RRF_UUFR, INSTR_RRF_UUFR, 2, 7, 0, "convert from 32 bit fixed logical to extended dfp with rounding mode" },
  { "cxlgtr", OP16(0xb95aLL), MASK_RRF_UUFER, INSTR_RRF_UUFER, 2, 7, 0, "convert from 64 bit fixed logical to extended dfp with rounding mode" },
  { "cxftr", OP16(0xb959LL), MASK_RRF_UUFER, INSTR_RRF_UUFER, 2, 7, 0, "convert from 32 bit fixed to extended dfp with rounding mode" },
  { "cdlftr", OP16(0xb953LL), MASK_RRF_UUFR, INSTR_RRF_UUFR, 2, 7, 0, "convert from 32 bit fixed logical to long dfp with rounding mode" },
  { "cdlgtr", OP16(0xb952LL), MASK_RRF_UUFR, INSTR_RRF_UUFR, 2, 7, 0, "convert from 64 bit fixed logical to long dfp with rounding mode" },
  { "cdftr", OP16(0xb951LL), MASK_RRF_UUFR, INSTR_RRF_UUFR, 2, 7, 0, "convert from 32 bit fixed to long dfp with rounding mode" },
  { "clfxtr", OP16(0xb94bLL), MASK_RRF_UURFE, INSTR_RRF_UURFE, 2, 7, 0, "convert to 32 bit fixed logical from extended dfp with rounding mode" },
  { "clgxtr", OP16(0xb94aLL), MASK_RRF_UURFE, INSTR_RRF_UURFE, 2, 7, 0, "convert to 64 bit fixed logical from extended dfp with rounding mode" },
  { "cfxtr", OP16(0xb949LL), MASK_RRF_UURF, INSTR_RRF_UURF, 2, 7, 0, "convert to 32 bit fixed from extended dfp source with rounding mode" },
  { "bctgr", OP16(0xb946LL), MASK_RRE_RR, INSTR_RRE_RR, 2, 2, 0, "branch on count 64" },
  { "clfdtr", OP16(0xb943LL), MASK_RRF_UURF, INSTR_RRF_UURF, 2, 7, 0, "convert to 32 bit fixed logical from long dfp with rounding mode" },
  { "clgdtr", OP16(0xb942LL), MASK_RRF_UURF, INSTR_RRF_UURF, 2, 7, 0, "convert to 64 bit fixed logical from long dfp with rounding mode" },
  { "cfdtr", OP16(0xb941LL), MASK_RRF_UURF, INSTR_RRF_UURF, 2, 7, 0, "convert to 32 bit fixed from long dfp source with rounding mode" },
  { "klmd", OP16(0xb93fLL), MASK_RRF_U0RR, INSTR_RRF_U0RR, 2, 13, 1, "compute last message digest" },
  { "klmd", OP16(0xb93fLL), MASK_RRE_RR, INSTR_RRE_RR, 3, 3, 0, "compute last message digest" },
  { "kimd", OP16(0xb93eLL), MASK_RRF_U0RR, INSTR_RRF_U0RR, 2, 13, 1, "compute intermediate message digest" },
  { "kimd", OP16(0xb93eLL), MASK_RRE_RR, INSTR_RRE_RR, 3, 3, 0, "compute intermediate message digest" },
  { "prno", OP16(0xb93cLL), MASK_RRE_RR, INSTR_RRE_RR, 2, 10, 0, "perform random number operation" },
  { "ppno", OP16(0xb93cLL), MASK_RRE_RR, INSTR_RRE_RR, 2, 9, 0, "perform pseudorandom number operation" },
  { "nnpa", OP16(0xb93bLL), MASK_RRE_00, INSTR_RRE_00, 2, 12, 0, "neural network processing assist" },
  { "kdsa", OP16(0xb93aLL), MASK_RRE_RR, INSTR_RRE_RR, 2, 11, 0, "compute digital signature authentication" },
  { "dfltcc", OP16(0xb939LL), MASK_RRF_R0RR2, INSTR_RRF_R0RR2, 2, 11, 0, "deflate conversion call" },
  { "sortl", OP16(0xb938LL), MASK_RRE_RR, INSTR_RRE_RR, 2, 11, 0, "sort lists" },
  { "clgfr", OP16(0xb931LL), MASK_RRE_RR, INSTR_RRE_RR, 2, 2, 0, "compare logical 64<32" },
  { "cgfr", OP16(0xb930LL), MASK_RRE_RR, INSTR_RRE_RR, 2, 2, 0, "compare 64<32" },
  { "kmc", OP16(0xb92fLL), MASK_RRE_RR, INSTR_RRE_RR, 3, 3, 0, "cipher message with chaining" },
  { "km", OP16(0xb92eLL), MASK_RRE_RR, INSTR_RRE_RR, 3, 3, 0, "cipher message" },
  { "kmctr", OP16(0xb92dLL), MASK_RRF_R0RR, INSTR_RRF_R0RR, 2, 7, 0, "cipher message with counter" },
  { "pcc", OP16(0xb92cLL), MASK_RRE_00, INSTR_RRE_00, 2, 7, 0, "perform cryptographic computation" },
  { "kmo", OP16(0xb92bLL), MASK_RRE_RR, INSTR_RRE_RR, 2, 7, 0, "cipher message with OFB" },
  { "kmf", OP16(0xb92aLL), MASK_RRE_RR, INSTR_RRE_RR, 2, 7, 0, "cipher message with CFB" },
  { "kma", OP16(0xb929LL), MASK_RRF_R0RR, INSTR_RRF_R0RR, 2, 10, 0, "cipher message with galois counter mode" },
  { "pckmo", OP16(0xb928LL), MASK_RRE_00, INSTR_RRE_00, 2, 7, 0, "perform cryptographic key management operation" },
  { "lhr", OP16(0xb927LL), MASK_RRE_RR, INSTR_RRE_RR, 2, 4, 0, "load halfword 32" },
  { "lbr", OP16(0xb926LL), MASK_RRE_RR, INSTR_RRE_RR, 2, 4, 0, "load byte 32" },
  { "sturg", OP16(0xb925LL), MASK_RRE_RR, INSTR_RRE_RR, 2, 2, 0, "store using real address 64" },
  { "clgr", OP16(0xb921LL), MASK_RRE_RR, INSTR_RRE_RR, 2, 2, 0, "compare logical 64" },
  { "cgr", OP16(0xb920LL), MASK_RRE_RR, INSTR_RRE_RR, 2, 2, 0, "compare 64" },
  { "lrvr", OP16(0xb91fLL), MASK_RRE_RR, INSTR_RRE_RR, 3, 2, 0, "load reversed 32" },
  { "kmac", OP16(0xb91eLL), MASK_RRE_RR, INSTR_RRE_RR, 3, 3, 0, "compute message authentication code" },
  { "dsgfr", OP16(0xb91dLL), MASK_RRE_RER, INSTR_RRE_RER, 2, 2, 0, "divide single 64<32" },
  { "msgfr", OP16(0xb91cLL), MASK_RRE_RR, INSTR_RRE_RR, 2, 2, 0, "multiply single 64<32" },
  { "slgfr", OP16(0xb91bLL), MASK_RRE_RR, INSTR_RRE_RR, 2, 2, 0, "subtract logical 64<32" },
  { "algfr", OP16(0xb91aLL), MASK_RRE_RR, INSTR_RRE_RR, 2, 2, 0, "add logical 64<32" },
  { "sgfr", OP16(0xb919LL), MASK_RRE_RR, INSTR_RRE_RR, 2, 2, 0, "subtract 64<32" },
  { "agfr", OP16(0xb918LL), MASK_RRE_RR, INSTR_RRE_RR, 2, 2, 0, "add 64<32" },
  { "llgtr", OP16(0xb917LL), MASK_RRE_RR, INSTR_RRE_RR, 2, 2, 0, "load logical thirty one bits" },
  { "llgfr", OP16(0xb916LL), MASK_RRE_RR, INSTR_RRE_RR, 2, 2, 0, "load logical 64<32" },
  { "lgfr", OP16(0xb914LL), MASK_RRE_RR, INSTR_RRE_RR, 2, 2, 0, "load 64<32" },
  { "lcgfr", OP16(0xb913LL), MASK_RRE_RR, INSTR_RRE_RR, 2, 2, 0, "load complement 64<32" },
  { "ltgfr", OP16(0xb912LL), MASK_RRE_RR, INSTR_RRE_RR, 2, 2, 0, "load and test 64<32" },
  { "lngfr", OP16(0xb911LL), MASK_RRE_RR, INSTR_RRE_RR, 2, 2, 0, "load negative 64<32" },
  { "lpgfr", OP16(0xb910LL), MASK_RRE_RR, INSTR_RRE_RR, 2, 2, 0, "load positive 64<32" },
  { "lrvgr", OP16(0xb90fLL), MASK_RRE_RR, INSTR_RRE_RR, 2, 2, 0, "load reversed 64" },
  { "eregg", OP16(0xb90eLL), MASK_RRE_RR, INSTR_RRE_RR, 2, 2, 0, "extract stacked registers 64" },
  { "dsgr", OP16(0xb90dLL), MASK_RRE_RER, INSTR_RRE_RER, 2, 2, 0, "divide single 64" },
  { "msgr", OP16(0xb90cLL), MASK_RRE_RR, INSTR_RRE_RR, 2, 2, 0, "multiply single 64" },
  { "slgr", OP16(0xb90bLL), MASK_RRE_RR, INSTR_RRE_RR, 2, 2, 0, "subtract logical 64" },
  { "algr", OP16(0xb90aLL), MASK_RRE_RR, INSTR_RRE_RR, 2, 2, 0, "add logical 64" },
  { "sgr", OP16(0xb909LL), MASK_RRE_RR, INSTR_RRE_RR, 2, 2, 0, "subtract 64" },
  { "agr", OP16(0xb908LL), MASK_RRE_RR, INSTR_RRE_RR, 2, 2, 0, "add 64" },
  { "lghr", OP16(0xb907LL), MASK_RRE_RR, INSTR_RRE_RR, 2, 4, 0, "load halfword 64" },
  { "lgbr", OP16(0xb906LL), MASK_RRE_RR, INSTR_RRE_RR, 2, 4, 0, "load byte 64" },
  { "lurag", OP16(0xb905LL), MASK_RRE_RR, INSTR_RRE_RR, 2, 2, 0, "load using real address 64" },
  { "lgr", OP16(0xb904LL), MASK_RRE_RR, INSTR_RRE_RR, 2, 2, 0, "load 64" },
  { "lcgr", OP16(0xb903LL), MASK_RRE_RR, INSTR_RRE_RR, 2, 2, 0, "load complement 64" },
  { "ltgr", OP16(0xb902LL), MASK_RRE_RR, INSTR_RRE_RR, 2, 2, 0, "load and test 64" },
  { "lngr", OP16(0xb901LL), MASK_RRE_RR, INSTR_RRE_RR, 2, 2, 0, "load negative 64" },
  { "lpgr", OP16(0xb900LL), MASK_RRE_RR, INSTR_RRE_RR, 2, 2, 0, "load positive 64" },
  { "lctl", OP8(0xb7LL), MASK_RS_CCRD, INSTR_RS_CCRD, 3, 0, 0, "load control" },
  { "stctl", OP8(0xb6LL), MASK_RS_CCRD, INSTR_RS_CCRD, 3, 0, 0, "store control" },
  { "rrxtr", OP16(0xb3ffLL), MASK_RRF_FEFERU, INSTR_RRF_FEFERU, 2, 5, 0, "Reround extended dfp" },
  { "iextr", OP16(0xb3feLL), MASK_RRF_FE0FER, INSTR_RRF_FE0FER, 2, 5, 0, "insert biased exponent extended dfp" },
  { "qaxtr", OP16(0xb3fdLL), MASK_RRF_FEUFEFE, INSTR_RRF_FEUFEFE, 2, 5, 0, "Quantize extended dfp" },
  { "cextr", OP16(0xb3fcLL), MASK_RRE_FEFE, INSTR_RRE_FEFE, 2, 5, 0, "compare exponent extended dfp" },
  { "cxstr", OP16(0xb3fbLL), MASK_RRE_FR, INSTR_RRE_FR, 2, 5, 0, "convert from signed bcd extended dfp" },
  { "cxutr", OP16(0xb3faLL), MASK_RRE_FER, INSTR_RRE_FER, 2, 5, 0, "convert from unsigned bcd to extended dfp" },
  { "cxgtra", OP16(0xb3f9LL), MASK_RRF_UUFER, INSTR_RRF_UUFER, 2, 7, 0, "convert from fixed extended dfp with rounding mode" },
  { "cxgtr", OP16(0xb3f9LL), MASK_RRE_FER, INSTR_RRE_FER, 2, 5, 0, "convert from fixed extended dfp" },
  { "rrdtr", OP16(0xb3f7LL), MASK_RRF_FFRU, INSTR_RRF_FFRU, 2, 5, 0, "Reround long dfp" },
  { "iedtr", OP16(0xb3f6LL), MASK_RRF_F0FR, INSTR_RRF_F0FR, 2, 5, 0, "insert biased exponent long dfp" },
  { "qadtr", OP16(0xb3f5LL), MASK_RRF_FUFF, INSTR_RRF_FUFF, 2, 5, 0, "Quantize long dfp" },
  { "cedtr", OP16(0xb3f4LL), MASK_RRE_FF, INSTR_RRE_FF, 2, 5, 0, "compare exponent long dfp" },
  { "cdstr", OP16(0xb3f3LL), MASK_RRE_FR, INSTR_RRE_FR, 2, 5, 0, "convert from signed bcd long dfp" },
  { "cdutr", OP16(0xb3f2LL), MASK_RRE_FR, INSTR_RRE_FR, 2, 5, 0, "convert from unsigned bcd to long dfp" },
  { "cdgtra", OP16(0xb3f1LL), MASK_RRF_UUFR, INSTR_RRF_UUFR, 2, 7, 0, "convert from fixed long dfp with rounding mode" },
  { "cdgtr", OP16(0xb3f1LL), MASK_RRE_FR, INSTR_RRE_FR, 2, 5, 0, "convert from fixed long dfp" },
  { "esxtr", OP16(0xb3efLL), MASK_RRE_RFE, INSTR_RRE_RFE, 2, 5, 0, "extract significance from extended dfp" },
  { "eextr", OP16(0xb3edLL), MASK_RRE_RFE, INSTR_RRE_RFE, 2, 5, 0, "extract biased exponent from extended dfp" },
  { "cxtr", OP16(0xb3ecLL), MASK_RRE_FEFE, INSTR_RRE_FEFE, 2, 5, 0, "compare extended dfp" },
  { "csxtr", OP16(0xb3ebLL), MASK_RRF_0UREFE, INSTR_RRF_0UREFE, 2, 5, 0, "convert from extended dfp to signed bcd" },
  { "cuxtr", OP16(0xb3eaLL), MASK_RRE_RFE, INSTR_RRE_RFE, 2, 5, 0, "convert from extended dfp to unsigned bcd" },
  { "cgxtra", OP16(0xb3e9LL), MASK_RRF_UURFE, INSTR_RRF_UURFE, 2, 7, 0, "convert to 64 bit fixed from extended dfp with rounding mode" },
  { "cgxtr", OP16(0xb3e9LL), MASK_RRF_U0RFE, INSTR_RRF_U0RFE, 2, 5, 0, "convert from extended dfp to fixed" },
  { "kxtr", OP16(0xb3e8LL), MASK_RRE_FF, INSTR_RRE_FF, 2, 5, 0, "compare and signal extended dfp" },
  { "esdtr", OP16(0xb3e7LL), MASK_RRE_RF, INSTR_RRE_RF, 2, 5, 0, "extract significance from long dfp" },
  { "eedtr", OP16(0xb3e5LL), MASK_RRE_RF, INSTR_RRE_RF, 2, 5, 0, "extract biased exponent from long dfp" },
  { "cdtr", OP16(0xb3e4LL), MASK_RRE_FF, INSTR_RRE_FF, 2, 5, 0, "compare long dfp" },
  { "csdtr", OP16(0xb3e3LL), MASK_RRF_0URF, INSTR_RRF_0URF, 2, 5, 0, "convert from long dfp to signed bcd" },
  { "cudtr", OP16(0xb3e2LL), MASK_RRE_RF, INSTR_RRE_RF, 2, 5, 0, "convert from long dfp to unsigned bcd" },
  { "cgdtra", OP16(0xb3e1LL), MASK_RRF_UURF, INSTR_RRF_UURF, 2, 7, 0, "convert to 64 bit fixed from long dfp with rounding mode" },
  { "cgdtr", OP16(0xb3e1LL), MASK_RRF_U0RF, INSTR_RRF_U0RF, 2, 5, 0, "convert from long dfp to fixed" },
  { "kdtr", OP16(0xb3e0LL), MASK_RRE_FF, INSTR_RRE_FF, 2, 5, 0, "compare and signal long dfp" },
  { "fixtr", OP16(0xb3dfLL), MASK_RRF_UUFEFE, INSTR_RRF_UUFEFE, 2, 5, 0, "load fp integer extended dfp" },
  { "ltxtr", OP16(0xb3deLL), MASK_RRE_FEFE, INSTR_RRE_FEFE, 2, 5, 0, "load and test extended dfp" },
  { "ldxtr", OP16(0xb3ddLL), MASK_RRF_UUFFE, INSTR_RRF_UUFFE, 2, 5, 0, "load rounded extended dfp" },
  { "lxdtr", OP16(0xb3dcLL), MASK_RRF_0UFEF, INSTR_RRF_0UFEF, 2, 5, 0, "load lengthened extended dfp" },
  { "sxtra", OP16(0xb3dbLL), MASK_RRF_FEUFEFE2, INSTR_RRF_FEUFEFE2, 2, 7, 0, "subtract extended dfp with rounding mode" },
  { "sxtr", OP16(0xb3dbLL), MASK_RRR_FE0FEFE, INSTR_RRR_FE0FEFE, 2, 5, 0, "subtract extended dfp" },
  { "axtra", OP16(0xb3daLL), MASK_RRF_FEUFEFE2, INSTR_RRF_FEUFEFE2, 2, 7, 0, "add extended dfp with rounding mode" },
  { "axtr", OP16(0xb3daLL), MASK_RRR_FE0FEFE, INSTR_RRR_FE0FEFE, 2, 5, 0, "add extended dfp" },
  { "dxtra", OP16(0xb3d9LL), MASK_RRF_FEUFEFE2, INSTR_RRF_FEUFEFE2, 2, 7, 0, "divide extended dfp with rounding mode" },
  { "dxtr", OP16(0xb3d9LL), MASK_RRR_FE0FEFE, INSTR_RRR_FE0FEFE, 2, 5, 0, "divide extended dfp" },
  { "mxtra", OP16(0xb3d8LL), MASK_RRF_FEUFEFE2, INSTR_RRF_FEUFEFE2, 2, 7, 0, "multiply extended dfp with rounding mode" },
  { "mxtr", OP16(0xb3d8LL), MASK_RRR_FE0FEFE, INSTR_RRR_FE0FEFE, 2, 5, 0, "multiply extended dfp" },
  { "fidtr", OP16(0xb3d7LL), MASK_RRF_UUFF, INSTR_RRF_UUFF, 2, 5, 0, "load fp integer long dfp" },
  { "ltdtr", OP16(0xb3d6LL), MASK_RRE_FF, INSTR_RRE_FF, 2, 5, 0, "load and test long dfp" },
  { "ledtr", OP16(0xb3d5LL), MASK_RRF_UUFF, INSTR_RRF_UUFF, 2, 5, 0, "load rounded long dfp" },
  { "ldetr", OP16(0xb3d4LL), MASK_RRF_0UFF, INSTR_RRF_0UFF, 2, 5, 0, "load lengthened long dfp" },
  { "sdtra", OP16(0xb3d3LL), MASK_RRF_FUFF2, INSTR_RRF_FUFF2, 2, 7, 0, "subtract long dfp with rounding mode" },
  { "sdtr", OP16(0xb3d3LL), MASK_RRR_F0FF, INSTR_RRR_F0FF, 2, 5, 0, "subtract long dfp" },
  { "adtra", OP16(0xb3d2LL), MASK_RRF_FUFF2, INSTR_RRF_FUFF2, 2, 7, 0, "add long dfp with rounding mode" },
  { "adtr", OP16(0xb3d2LL), MASK_RRR_F0FF, INSTR_RRR_F0FF, 2, 5, 0, "add long dfp" },
  { "ddtra", OP16(0xb3d1LL), MASK_RRF_FUFF2, INSTR_RRF_FUFF2, 2, 7, 0, "divide long dfp with rounding mode" },
  { "ddtr", OP16(0xb3d1LL), MASK_RRR_F0FF, INSTR_RRR_F0FF, 2, 5, 0, "divide long dfp" },
  { "mdtra", OP16(0xb3d0LL), MASK_RRF_FUFF2, INSTR_RRF_FUFF2, 2, 7, 0, "multiply long dfp with rounding mode" },
  { "mdtr", OP16(0xb3d0LL), MASK_RRR_F0FF, INSTR_RRR_F0FF, 2, 5, 0, "multiply long dfp" },
  { "lgdr", OP16(0xb3cdLL), MASK_RRE_RF, INSTR_RRE_RF, 2, 5, 0, "load GR from FPR" },
  { "cgxr", OP16(0xb3caLL), MASK_RRF_U0RFE, INSTR_RRF_U0RFE, 2, 2, 0, "convert to fixed extended hfp to 64" },
  { "cgdr", OP16(0xb3c9LL), MASK_RRF_U0RF, INSTR_RRF_U0RF, 2, 2, 0, "convert to fixed long hfp to 64" },
  { "cger", OP16(0xb3c8LL), MASK_RRF_U0RF, INSTR_RRF_U0RF, 2, 2, 0, "convert to fixed short hfp to 64" },
  { "cxgr", OP16(0xb3c6LL), MASK_RRE_FER, INSTR_RRE_FER, 2, 2, 0, "convert from fixed 64 to extended hfp" },
  { "cdgr", OP16(0xb3c5LL), MASK_RRE_FR, INSTR_RRE_FR, 2, 2, 0, "convert from fixed 64 to long hfp" },
  { "cegr", OP16(0xb3c4LL), MASK_RRE_FR, INSTR_RRE_FR, 2, 2, 0, "convert from fixed 64 to short hfp" },
  { "ldgr", OP16(0xb3c1LL), MASK_RRE_FR, INSTR_RRE_FR, 2, 5, 0, "load FPR from GR" },
  { "cfxr", OP16(0xb3baLL), MASK_RRF_U0RFE, INSTR_RRF_U0RFE, 3, 0, 0, "convert to fixed extended hfp to 32" },
  { "cfdr", OP16(0xb3b9LL), MASK_RRF_U0RF, INSTR_RRF_U0RF, 3, 0, 0, "convert to fixed long hfp to 32" },
  { "cfer", OP16(0xb3b8LL), MASK_RRF_U0RF, INSTR_RRF_U0RF, 3, 0, 0, "convert to fixed short hfp to 32" },
  { "cxfr", OP16(0xb3b6LL), MASK_RRE_FER, INSTR_RRE_FER, 3, 0, 0, "convert from fixed 32 to extended hfp" },
  { "cdfr", OP16(0xb3b5LL), MASK_RRE_FR, INSTR_RRE_FR, 3, 0, 0, "convert from fixed 32 to long hfp" },
  { "cefr", OP16(0xb3b4LL), MASK_RRE_FR, INSTR_RRE_FR, 3, 0, 0, "convert from fixed 32 to short hfp" },
  { "clgxbr", OP16(0xb3aeLL), MASK_RRF_UURFE, INSTR_RRF_UURFE, 2, 7, 0, "convert to 64 bit fixed logical from extended bfp with rounding mode" },
  { "clgdbr", OP16(0xb3adLL), MASK_RRF_UURF, INSTR_RRF_UURF, 2, 7, 0, "convert to 64 bit fixed logical from long bfp with rounding mode" },
  { "clgebr", OP16(0xb3acLL), MASK_RRF_UURF, INSTR_RRF_UURF, 2, 7, 0, "convert to 64 bit fixed logical from short bfp with rounding mode" },
  { "cgxbra", OP16(0xb3aaLL), MASK_RRF_UURFE, INSTR_RRF_UURFE, 2, 7, 0, "convert to 64 bit fixed from extended bfp with rounding mode" },
  { "cgxbr", OP16(0xb3aaLL), MASK_RRF_U0RFE, INSTR_RRF_U0RFE, 2, 2, 0, "convert to fixed extended bfp to 64" },
  { "cgdbra", OP16(0xb3a9LL), MASK_RRF_UURF, INSTR_RRF_UURF, 2, 7, 0, "convert to 64 bit fixed from long bfp with rounding mode" },
  { "cgdbr", OP16(0xb3a9LL), MASK_RRF_U0RF, INSTR_RRF_U0RF, 2, 2, 0, "convert to fixed long bfp to 64" },
  { "cgebra", OP16(0xb3a8LL), MASK_RRF_UURF, INSTR_RRF_UURF, 2, 7, 0, "convert to 64 bit fixed from short bfp with rounding mode" },
  { "cgebr", OP16(0xb3a8LL), MASK_RRF_U0RF, INSTR_RRF_U0RF, 2, 2, 0, "convert to fixed short bfd to 64" },
  { "cxgbra", OP16(0xb3a6LL), MASK_RRF_UUFER, INSTR_RRF_UUFER, 2, 7, 0, "convert from 64 bit fixed to extended bfp with rounding mode" },
  { "cxgbr", OP16(0xb3a6LL), MASK_RRE_FER, INSTR_RRE_FER, 2, 2, 0, "convert from fixed 64 to extended bfp" },
  { "cdgbra", OP16(0xb3a5LL), MASK_RRF_UUFR, INSTR_RRF_UUFR, 2, 7, 0, "convert from 64 bit fixed to long bfp with rounding mode" },
  { "cdgbr", OP16(0xb3a5LL), MASK_RRE_FR, INSTR_RRE_FR, 2, 2, 0, "convert from fixed 64 to long bfp" },
  { "cegbra", OP16(0xb3a4LL), MASK_RRF_UUFR, INSTR_RRF_UUFR, 2, 7, 0, "convert from 64 bit fixed to short bfp with rounding mode" },
  { "cegbr", OP16(0xb3a4LL), MASK_RRE_FR, INSTR_RRE_FR, 2, 2, 0, "convert from fixed 64 to short bfp" },
  { "cxlgbr", OP16(0xb3a2LL), MASK_RRF_UUFER, INSTR_RRF_UUFER, 2, 7, 0, "convert from 64 bit logical fixed to extended bfp with rounding mode" },
  { "cdlgbr", OP16(0xb3a1LL), MASK_RRF_UUFR, INSTR_RRF_UUFR, 2, 7, 0, "convert from 64 bit logical fixed to long bfp with rounding mode" },
  { "celgbr", OP16(0xb3a0LL), MASK_RRF_UUFR, INSTR_RRF_UUFR, 2, 7, 0, "convert from 64 bit logical fixed to short bfp with rounding mode" },
  { "clfxbr", OP16(0xb39eLL), MASK_RRF_UURFE, INSTR_RRF_UURFE, 2, 7, 0, "convert to 32 bit fixed logical from extended bfp with rounding mode" },
  { "clfdbr", OP16(0xb39dLL), MASK_RRF_UURF, INSTR_RRF_UURF, 2, 7, 0, "convert to 32 bit fixed logical from long bfp with rounding mode" },
  { "clfebr", OP16(0xb39cLL), MASK_RRF_UURF, INSTR_RRF_UURF, 2, 7, 0, "convert to 32 bit fixed logical from short bfp with rounding mode" },
  { "cfxbra", OP16(0xb39aLL), MASK_RRF_UURFE, INSTR_RRF_UURFE, 2, 7, 0, "convert to 32 bit fixed from extended bfp with rounding mode" },
  { "cfxbr", OP16(0xb39aLL), MASK_RRF_U0RFE, INSTR_RRF_U0RFE, 3, 0, 0, "convert to fixed extended bfp to 32" },
  { "cfdbra", OP16(0xb399LL), MASK_RRF_UURF, INSTR_RRF_UURF, 2, 7, 0, "convert to 32 bit fixed from long bfp with rounding mode" },
  { "cfdbr", OP16(0xb399LL), MASK_RRF_U0RF, INSTR_RRF_U0RF, 3, 0, 0, "convert to fixed long bfp to 32" },
  { "cfebra", OP16(0xb398LL), MASK_RRF_UURF, INSTR_RRF_UURF, 2, 7, 0, "convert to 32 bit fixed from short bfp with rounding mode" },
  { "cfebr", OP16(0xb398LL), MASK_RRF_U0RF, INSTR_RRF_U0RF, 3, 0, 0, "convert to fixed short bfp to 32" },
  { "cxfbra", OP16(0xb396LL), MASK_RRF_UUFER, INSTR_RRF_UUFER, 2, 7, 0, "convert from 32 bit fixed to extended bfp with rounding mode" },
  { "cxfbr", OP16(0xb396LL), MASK_RRE_FER, INSTR_RRE_FER, 3, 0, 0, "convert from fixed 32 to extended bfp" },
  { "cdfbra", OP16(0xb395LL), MASK_RRF_UUFR, INSTR_RRF_UUFR, 2, 7, 0, "convert from 32 bit fixed to long bfp with rounding mode" },
  { "cdfbr", OP16(0xb395LL), MASK_RRE_FR, INSTR_RRE_FR, 3, 0, 0, "convert from fixed 32 to long bfp" },
  { "cefbra", OP16(0xb394LL), MASK_RRF_UUFR, INSTR_RRF_UUFR, 2, 7, 0, "convert from 32 bit fixed to short bfp with rounding mode" },
  { "cefbr", OP16(0xb394LL), MASK_RRE_FR, INSTR_RRE_FR, 3, 0, 0, "convert from fixed 32 to short bfp" },
  { "cxlfbr", OP16(0xb392LL), MASK_RRF_UUFER, INSTR_RRF_UUFER, 2, 7, 0, "convert from 32 bit logical fixed to extended bfp with rounding mode" },
  { "cdlfbr", OP16(0xb391LL), MASK_RRF_UUFR, INSTR_RRF_UUFR, 2, 7, 0, "convert from 32 bit logical fixed to long bfp with rounding mode" },
  { "celfbr", OP16(0xb390LL), MASK_RRF_UUFR, INSTR_RRF_UUFR, 2, 7, 0, "convert from 32 bit logical fixed to short bfp with rounding mode" },
  { "efpc", OP16(0xb38cLL), MASK_RRE_RR, INSTR_RRE_RR, 3, 0, 1, "extract fpc" },
  { "sfasr", OP16(0xb385LL), MASK_RRE_R0, INSTR_RRE_R0, 2, 5, 0, "set fpc and signal" },
  { "sfpc", OP16(0xb384LL), MASK_RRE_RR, INSTR_RRE_RR, 3, 0, 1, "set fpc" },
  { "fidr", OP16(0xb37fLL), MASK_RRE_FF, INSTR_RRE_FF, 3, 0, 0, "load fp integer long hfp" },
  { "fier", OP16(0xb377LL), MASK_RRE_FF, INSTR_RRE_FF, 3, 0, 0, "load fp integer short hfp" },
  { "lzxr", OP16(0xb376LL), MASK_RRE_FE0, INSTR_RRE_FE0, 3, 0, 0, "load extended zero" },
  { "lzdr", OP16(0xb375LL), MASK_RRE_F0, INSTR_RRE_F0, 3, 0, 0, "load long zero" },
  { "lzer", OP16(0xb374LL), MASK_RRE_F0, INSTR_RRE_F0, 3, 0, 0, "load short zero" },
  { "lcdfr", OP16(0xb373LL), MASK_RRE_FF, INSTR_RRE_FF, 2, 5, 0, "load complement no cc" },
  { "cpsdr", OP16(0xb372LL), MASK_RRF_F0FF2, INSTR_RRF_F0FF2, 2, 5, 0, "copy sign" },
  { "lndfr", OP16(0xb371LL), MASK_RRE_FF, INSTR_RRE_FF, 2, 5, 0, "load negative no cc" },
  { "lpdfr", OP16(0xb370LL), MASK_RRE_FF, INSTR_RRE_FF, 2, 5, 0, "load positive no cc" },
  { "cxr", OP16(0xb369LL), MASK_RRE_FEFE, INSTR_RRE_FEFE, 3, 0, 0, "compare extended hfp" },
  { "fixr", OP16(0xb367LL), MASK_RRE_FEFE, INSTR_RRE_FEFE, 3, 0, 0, "load fp integer extended hfp" },
  { "lexr", OP16(0xb366LL), MASK_RRE_FFE, INSTR_RRE_FFE, 3, 0, 0, "load rounded extended to short hfp" },
  { "lxr", OP16(0xb365LL), MASK_RRE_FEFE, INSTR_RRE_FEFE, 3, 0, 0, "load extended fp" },
  { "lcxr", OP16(0xb363LL), MASK_RRE_FEFE, INSTR_RRE_FEFE, 3, 0, 0, "load complement extended hfp" },
  { "ltxr", OP16(0xb362LL), MASK_RRE_FEFE, INSTR_RRE_FEFE, 3, 0, 0, "load and test extended hfp" },
  { "lnxr", OP16(0xb361LL), MASK_RRE_FEFE, INSTR_RRE_FEFE, 3, 0, 0, "load negative extended hfp" },
  { "lpxr", OP16(0xb360LL), MASK_RRE_FEFE, INSTR_RRE_FEFE, 3, 0, 0, "load positive extended hfp" },
  { "fidbra", OP16(0xb35fLL), MASK_RRF_UUFF, INSTR_RRF_UUFF, 2, 7, 0, "load fp integer long bfp with inexact suppression" },
  { "fidbr", OP16(0xb35fLL), MASK_RRF_U0FF, INSTR_RRF_U0FF, 3, 0, 0, "load fp integer long bfp" },
  { "didbr", OP16(0xb35bLL), MASK_RRF_FUFF, INSTR_RRF_FUFF, 3, 0, 0, "divide to integer long bfp" },
  { "thdr", OP16(0xb359LL), MASK_RRE_FF, INSTR_RRE_FF, 3, 0, 0, "convert long bfp to long hfp" },
  { "thder", OP16(0xb358LL), MASK_RRE_FF, INSTR_RRE_FF, 3, 0, 0, "convert short bfp to long hfp" },
  { "fiebra", OP16(0xb357LL), MASK_RRF_UUFF, INSTR_RRF_UUFF, 2, 7, 0, "load fp integer short bfp with inexact suppression" },
  { "fiebr", OP16(0xb357LL), MASK_RRF_U0FF, INSTR_RRF_U0FF, 3, 0, 0, "load fp integer short bfp" },
  { "diebr", OP16(0xb353LL), MASK_RRF_FUFF, INSTR_RRF_FUFF, 3, 0, 0, "divide to integer short bfp" },
  { "tbdr", OP16(0xb351LL), MASK_RRF_U0FF, INSTR_RRF_U0FF, 3, 0, 0, "convert long hfp to long bfp" },
  { "tbedr", OP16(0xb350LL), MASK_RRF_U0FF, INSTR_RRF_U0FF, 3, 0, 0, "convert long hfp to short bfp" },
  { "dxbr", OP16(0xb34dLL), MASK_RRE_FEFE, INSTR_RRE_FEFE, 3, 0, 0, "divide extended bfp" },
  { "mxbr", OP16(0xb34cLL), MASK_RRE_FEFE, INSTR_RRE_FEFE, 3, 0, 0, "multiply extended bfp" },
  { "sxbr", OP16(0xb34bLL), MASK_RRE_FEFE, INSTR_RRE_FEFE, 3, 0, 0, "subtract extended bfp" },
  { "axbr", OP16(0xb34aLL), MASK_RRE_FEFE, INSTR_RRE_FEFE, 3, 0, 0, "add extended bfp" },
  { "cxbr", OP16(0xb349LL), MASK_RRE_FEFE, INSTR_RRE_FEFE, 3, 0, 0, "compare extended bfp" },
  { "kxbr", OP16(0xb348LL), MASK_RRE_FF, INSTR_RRE_FF, 3, 0, 0, "compare and signal extended bfp" },
  { "fixbra", OP16(0xb347LL), MASK_RRF_UUFEFE, INSTR_RRF_UUFEFE, 2, 7, 0, "load fp integer extended bfp with inexact suppression" },
  { "fixbr", OP16(0xb347LL), MASK_RRF_U0FEFE, INSTR_RRF_U0FEFE, 3, 0, 0, "load fp integer extended bfp" },
  { "lexbra", OP16(0xb346LL), MASK_RRF_UUFEFE, INSTR_RRF_UUFEFE, 2, 7, 0, "load rounded short/extended bfp to short/extended bfp with rounding mode" },
  { "lexbr", OP16(0xb346LL), MASK_RRE_FEFE, INSTR_RRE_FEFE, 3, 0, 0, "load rounded extended to short bfp" },
  { "ldxbra", OP16(0xb345LL), MASK_RRF_UUFEFE, INSTR_RRF_UUFEFE, 2, 7, 0, "load rounded long/extended bfp to long/extended bfp with rounding mode" },
  { "ldxbr", OP16(0xb345LL), MASK_RRE_FEFE, INSTR_RRE_FEFE, 3, 0, 0, "load rounded extended to long bfp" },
  { "ledbra", OP16(0xb344LL), MASK_RRF_UUFF, INSTR_RRF_UUFF, 2, 7, 0, "load rounded short/long bfp to short/long bfp with rounding mode" },
  { "ledbr", OP16(0xb344LL), MASK_RRE_FF, INSTR_RRE_FF, 3, 0, 0, "load rounded long to short bfp" },
  { "lcxbr", OP16(0xb343LL), MASK_RRE_FEFE, INSTR_RRE_FEFE, 3, 0, 0, "load complement extended bfp" },
  { "ltxbr", OP16(0xb342LL), MASK_RRE_FEFE, INSTR_RRE_FEFE, 3, 0, 0, "load and test extended bfp" },
  { "lnxbr", OP16(0xb341LL), MASK_RRE_FEFE, INSTR_RRE_FEFE, 3, 0, 0, "load negative extended bfp" },
  { "lpxbr", OP16(0xb340LL), MASK_RRE_FEFE, INSTR_RRE_FEFE, 3, 0, 0, "load positive extended bfp" },
  { "msdr", OP16(0xb33fLL), MASK_RRF_F0FF, INSTR_RRF_F0FF, 3, 3, 0, "multiply and subtract long hfp" },
  { "madr", OP16(0xb33eLL), MASK_RRF_F0FF, INSTR_RRF_F0FF, 3, 3, 0, "multiply and add long hfp" },
  { "myhr", OP16(0xb33dLL), MASK_RRF_F0FF, INSTR_RRF_F0FF, 2, 4, 0, "multiply unnormalized long hfp high" },
  { "mayhr", OP16(0xb33cLL), MASK_RRF_F0FF, INSTR_RRF_F0FF, 2, 4, 0, "multiply and add unnormalized long hfp high" },
  { "myr", OP16(0xb33bLL), MASK_RRF_FE0FF, INSTR_RRF_FE0FF, 2, 4, 0, "multiply unnormalized long hfp" },
  { "mayr", OP16(0xb33aLL), MASK_RRF_F0FF, INSTR_RRF_F0FF, 2, 4, 0, "multiply and add unnormalized long hfp" },
  { "mylr", OP16(0xb339LL), MASK_RRF_F0FF, INSTR_RRF_F0FF, 2, 4, 0, "multiply unnormalized long hfp low" },
  { "maylr", OP16(0xb338LL), MASK_RRF_F0FF, INSTR_RRF_F0FF, 2, 4, 0, "multiply and add unnormalized long hfp low" },
  { "meer", OP16(0xb337LL), MASK_RRE_FF, INSTR_RRE_FF, 3, 0, 0, "multiply short hfp" },
  { "sqxr", OP16(0xb336LL), MASK_RRE_FEFE, INSTR_RRE_FEFE, 3, 0, 0, "square root extended hfp" },
  { "mser", OP16(0xb32fLL), MASK_RRF_F0FF, INSTR_RRF_F0FF, 3, 3, 0, "mutliply and subtract short hfp" },
  { "maer", OP16(0xb32eLL), MASK_RRF_F0FF, INSTR_RRF_F0FF, 3, 3, 0, "multiply and add short hfp" },
  { "lxer", OP16(0xb326LL), MASK_RRE_FEF, INSTR_RRE_FEF, 3, 0, 0, "load lengthened short to extended hfp" },
  { "lxdr", OP16(0xb325LL), MASK_RRE_FEF, INSTR_RRE_FEF, 3, 0, 0, "load lengthened long to extended hfp" },
  { "lder", OP16(0xb324LL), MASK_RRE_FF, INSTR_RRE_FF, 3, 0, 0, "load lengthened short to long hfp" },
  { "msdbr", OP16(0xb31fLL), MASK_RRF_F0FF, INSTR_RRF_F0FF, 3, 0, 0, "multiply and subtract long bfp" },
  { "madbr", OP16(0xb31eLL), MASK_RRF_F0FF, INSTR_RRF_F0FF, 3, 0, 0, "multiply and add long bfp" },
  { "ddbr", OP16(0xb31dLL), MASK_RRE_FF, INSTR_RRE_FF, 3, 0, 0, "divide long bfp" },
  { "mdbr", OP16(0xb31cLL), MASK_RRE_FF, INSTR_RRE_FF, 3, 0, 0, "multiply long bfp" },
  { "sdbr", OP16(0xb31bLL), MASK_RRE_FF, INSTR_RRE_FF, 3, 0, 0, "subtract long bfp" },
  { "adbr", OP16(0xb31aLL), MASK_RRE_FF, INSTR_RRE_FF, 3, 0, 0, "add long bfp" },
  { "cdbr", OP16(0xb319LL), MASK_RRE_FF, INSTR_RRE_FF, 3, 0, 0, "compare long bfp" },
  { "kdbr", OP16(0xb318LL), MASK_RRE_FF, INSTR_RRE_FF, 3, 0, 0, "compare and signal long bfp" },
  { "meebr", OP16(0xb317LL), MASK_RRE_FF, INSTR_RRE_FF, 3, 0, 0, "multiply short bfp" },
  { "sqxbr", OP16(0xb316LL), MASK_RRE_FEFE, INSTR_RRE_FEFE, 3, 0, 0, "square root extended bfp" },
  { "sqdbr", OP16(0xb315LL), MASK_RRE_FF, INSTR_RRE_FF, 3, 0, 0, "square root long bfp" },
  { "sqebr", OP16(0xb314LL), MASK_RRE_FF, INSTR_RRE_FF, 3, 0, 0, "square root short bfp" },
  { "lcdbr", OP16(0xb313LL), MASK_RRE_FF, INSTR_RRE_FF, 3, 0, 0, "load complement long bfp" },
  { "ltdbr", OP16(0xb312LL), MASK_RRE_FF, INSTR_RRE_FF, 3, 0, 0, "load and test long bfp" },
  { "lndbr", OP16(0xb311LL), MASK_RRE_FF, INSTR_RRE_FF, 3, 0, 0, "load negative long bfp" },
  { "lpdbr", OP16(0xb310LL), MASK_RRE_FF, INSTR_RRE_FF, 3, 0, 0, "load positive long bfp" },
  { "msebr", OP16(0xb30fLL), MASK_RRF_F0FF, INSTR_RRF_F0FF, 3, 0, 0, "multiply and subtract short bfp" },
  { "maebr", OP16(0xb30eLL), MASK_RRF_F0FF, INSTR_RRF_F0FF, 3, 0, 0, "multiply and add short bfp" },
  { "debr", OP16(0xb30dLL), MASK_RRE_FF, INSTR_RRE_FF, 3, 0, 0, "divide short bfp" },
  { "mdebr", OP16(0xb30cLL), MASK_RRE_FF, INSTR_RRE_FF, 3, 0, 0, "multiply short to long bfp" },
  { "sebr", OP16(0xb30bLL), MASK_RRE_FF, INSTR_RRE_FF, 3, 0, 0, "subtract short bfp" },
  { "aebr", OP16(0xb30aLL), MASK_RRE_FF, INSTR_RRE_FF, 3, 0, 0, "add short bfp" },
  { "cebr", OP16(0xb309LL), MASK_RRE_FF, INSTR_RRE_FF, 3, 0, 0, "compare short bfp" },
  { "kebr", OP16(0xb308LL), MASK_RRE_FF, INSTR_RRE_FF, 3, 0, 0, "compare and signal short bfp" },
  { "mxdbr", OP16(0xb307LL), MASK_RRE_FEF, INSTR_RRE_FEF, 3, 0, 0, "multiply long to extended bfp" },
  { "lxebr", OP16(0xb306LL), MASK_RRE_FEF, INSTR_RRE_FEF, 3, 0, 0, "load lengthened short to extended bfp" },
  { "lxdbr", OP16(0xb305LL), MASK_RRE_FEF, INSTR_RRE_FEF, 3, 0, 0, "load lengthened long to extended bfp" },
  { "ldebr", OP16(0xb304LL), MASK_RRE_FF, INSTR_RRE_FF, 3, 0, 0, "load lengthened short to long bfp" },
  { "lcebr", OP16(0xb303LL), MASK_RRE_FF, INSTR_RRE_FF, 3, 0, 0, "load complement short bfp" },
  { "ltebr", OP16(0xb302LL), MASK_RRE_FF, INSTR_RRE_FF, 3, 0, 0, "load and test short bfp" },
  { "lnebr", OP16(0xb301LL), MASK_RRE_FF, INSTR_RRE_FF, 3, 0, 0, "load negative short bfp" },
  { "lpebr", OP16(0xb300LL), MASK_RRE_FF, INSTR_RRE_FF, 3, 0, 0, "load positive short bfp" },
  { "trap4", OP16(0xb2ffLL), MASK_S_RD, INSTR_S_RD, 3, 0, 0, "trap4" },
  { "tabort", OP16(0xb2fcLL), MASK_S_RD, INSTR_S_RD, 2, 8, 4, "transaction abort" },
  { "niai", OP16(0xb2faLL), MASK_IE_UU, INSTR_IE_UU, 2, 8, 0, "next instruction access intent" },
  { "tend", OP16(0xb2f8LL), MASK_S_00, INSTR_S_00, 2, 8, 4, "transaction end" },
  { "ecpga", OP16(0xb2edLL), MASK_RRE_RR, INSTR_RRE_RR, 2, 6, 0, "extract coprocessor-group address" },
  { "etnd", OP16(0xb2ecLL), MASK_RRE_R0, INSTR_RRE_R0, 2, 8, 4, "extract transaction nesting depth" },
  { "ppa", OP16(0xb2e8LL), MASK_RRF_U0RR, INSTR_RRF_U0RR, 2, 8, 4, "perform processor assist" },
  { "epctr", OP16(0xb2e5LL), MASK_RRE_RR, INSTR_RRE_RR, 2, 6, 0, "extract peripheral counter" },
  { "ecctr", OP16(0xb2e4LL), MASK_RRE_RR, INSTR_RRE_RR, 2, 6, 0, "extract cpu counter" },
  { "spctr", OP16(0xb2e1LL), MASK_RRE_RR, INSTR_RRE_RR, 2, 6, 0, "set peripheral counter" },
  { "scctr", OP16(0xb2e0LL), MASK_RRE_RR, INSTR_RRE_RR, 2, 6, 0, "set cpu counter" },
  { "lfas", OP16(0xb2bdLL), MASK_S_RD, INSTR_S_RD, 2, 5, 0, "load fpd and signal" },
  { "srnmt", OP16(0xb2b9LL), MASK_S_RD, INSTR_S_RD, 2, 5, 0, "set rounding mode dfp" },
  { "srnmb", OP16(0xb2b8LL), MASK_S_RD, INSTR_S_RD, 2, 7, 0, "set 3 bit bfp rounding mode" },
  { "lpswe", OP16(0xb2b2LL), MASK_S_RD, INSTR_S_RD, 2, 2, 0, "load psw extended" },
  { "stfl", OP16(0xb2b1LL), MASK_S_RD, INSTR_S_RD, 3, 2, 0, "store facility list" },
  { "stfle", OP16(0xb2b0LL), MASK_S_RD, INSTR_S_RD, 2, 4, 0, "store facility list extended" },
  { "cu12", OP16(0xb2a7LL), MASK_RRF_U0RERE, INSTR_RRF_U0RERE, 2, 4, 1, "convert utf-8 to utf-16" },
  { "cutfu", OP16(0xb2a7LL), MASK_RRF_U0RERE, INSTR_RRF_U0RERE, 2, 4, 1, "convert utf-8 to unicode" },
  { "cutfu", OP16(0xb2a7LL), MASK_RRE_RR, INSTR_RRE_RR, 3, 0, 0, "convert utf-8 to unicode" },
  { "cu21", OP16(0xb2a6LL), MASK_RRF_U0RERE, INSTR_RRF_U0RERE, 2, 4, 1, "convert utf-16 to utf-8" },
  { "cuutf", OP16(0xb2a6LL), MASK_RRF_U0RERE, INSTR_RRF_U0RERE, 2, 4, 1, "convert unicode to utf-8" },
  { "cuutf", OP16(0xb2a6LL), MASK_RRE_RERE, INSTR_RRE_RERE, 3, 0, 0, "convert unicode to utf-8" },
  { "tre", OP16(0xb2a5LL), MASK_RRE_RER, INSTR_RRE_RER, 3, 0, 0, "translate extended" },
  { "lfpc", OP16(0xb29dLL), MASK_S_RD, INSTR_S_RD, 3, 0, 0, "load fpc" },
  { "stfpc", OP16(0xb29cLL), MASK_S_RD, INSTR_S_RD, 3, 0, 0, "store fpc" },
  { "srnm", OP16(0xb299LL), MASK_S_RD, INSTR_S_RD, 3, 0, 0, "set rounding mode" },
  { "qpaci", OP16(0xb28fLL), MASK_S_RD, INSTR_S_RD, 2, 12, 0, "query processor activity counter information" },
  { "qctri", OP16(0xb28eLL), MASK_S_RD, INSTR_S_RD, 2, 6, 0, "query counter information" },
  { "lsctl", OP16(0xb287LL), MASK_S_RD, INSTR_S_RD, 2, 6, 0, "load sampling controls" },
  { "qsi", OP16(0xb286LL), MASK_S_RD, INSTR_S_RD, 2, 6, 0, "query sampling information" },
  { "lpctl", OP16(0xb285LL), MASK_S_RD, INSTR_S_RD, 2, 6, 0, "load peripheral-counter-set controls" },
  { "lcctl", OP16(0xb284LL), MASK_S_RD, INSTR_S_RD, 2, 6, 0, "load cpu-counter-set controls" },
  { "lpp", OP16(0xb280LL), MASK_S_RD, INSTR_S_RD, 2, 6, 0, "load program parameter" },
  { "stsi", OP16(0xb27dLL), MASK_S_RD, INSTR_S_RD, 3, 0, 0, "store system information" },
  { "stckf", OP16(0xb27cLL), MASK_S_RD, INSTR_S_RD, 2, 4, 0, "store clock fast" },
  { "sacf", OP16(0xb279LL), MASK_S_RD, INSTR_S_RD, 3, 0, 0, "set address space control fast" },
  { "stcke", OP16(0xb278LL), MASK_S_RD, INSTR_S_RD, 3, 0, 0, "store clock extended" },
  { "rp", OP16(0xb277LL), MASK_S_RD, INSTR_S_RD, 3, 0, 0, "resume program" },
  { "xsch", OP16(0xb276LL), MASK_S_00, INSTR_S_00, 3, 0, 0, "cancel subchannel" },
  { "siga", OP16(0xb274LL), MASK_S_RD, INSTR_S_RD, 3, 0, 0, "signal adapter" },
  { "cmpsc", OP16(0xb263LL), MASK_RRE_RR, INSTR_RRE_RR, 3, 0, 0, "compression call" },
  { "srst", OP16(0xb25eLL), MASK_RRE_RR, INSTR_RRE_RR, 3, 0, 0, "search string" },
  { "clst", OP16(0xb25dLL), MASK_RRE_RR, INSTR_RRE_RR, 3, 0, 0, "compare logical string" },
  { "bsa", OP16(0xb25aLL), MASK_RRE_RR, INSTR_RRE_RR, 3, 0, 0, "branch and set authority" },
  { "bsg", OP16(0xb258LL), MASK_RRE_RR, INSTR_RRE_RR, 3, 0, 0, "branch in subspace group" },
  { "cuse", OP16(0xb257LL), MASK_RRE_RERE, INSTR_RRE_RERE, 3, 0, 0, "compare until substring equal" },
  { "mvst", OP16(0xb255LL), MASK_RRE_RR, INSTR_RRE_RR, 3, 0, 0, "move string" },
  { "mvpg", OP16(0xb254LL), MASK_RRE_RR, INSTR_RRE_RR, 3, 0, 0, "move page" },
  { "msr", OP16(0xb252LL), MASK_RRE_RR, INSTR_RRE_RR, 3, 0, 0, "multiply single" },
  { "csp", OP16(0xb250LL), MASK_RRE_RR, INSTR_RRE_RR, 3, 0, 0, "compare and swap and purge" },
  { "ear", OP16(0xb24fLL), MASK_RRE_RA, INSTR_RRE_RA, 3, 0, 0, "extract access" },
  { "sar", OP16(0xb24eLL), MASK_RRE_AR, INSTR_RRE_AR, 3, 0, 0, "set access" },
  { "cpya", OP16(0xb24dLL), MASK_RRE_AA, INSTR_RRE_AA, 3, 0, 0, "copy access" },
  { "tar", OP16(0xb24cLL), MASK_RRE_AR, INSTR_RRE_AR, 3, 0, 0, "test access" },
  { "lura", OP16(0xb24bLL), MASK_RRE_RR, INSTR_RRE_RR, 3, 0, 0, "load using real address" },
  { "esta", OP16(0xb24aLL), MASK_RRE_RR, INSTR_RRE_RR, 3, 0, 0, "extract stacked state" },
  { "ereg", OP16(0xb249LL), MASK_RRE_RR, INSTR_RRE_RR, 3, 0, 0, "extract stacked registers" },
  { "palb", OP16(0xb248LL), MASK_RRE_00, INSTR_RRE_00, 3, 0, 0, "purge ALB" },
  { "msta", OP16(0xb247LL), MASK_RRE_R0, INSTR_RRE_R0, 3, 0, 0, "modify stacked state" },
  { "stura", OP16(0xb246LL), MASK_RRE_RR, INSTR_RRE_RR, 3, 0, 0, "store using real address" },
  { "sqer", OP16(0xb245LL), MASK_RRE_FF, INSTR_RRE_FF, 3, 0, 0, "square root (short)" },
  { "sqdr", OP16(0xb244LL), MASK_RRE_FF, INSTR_RRE_FF, 3, 0, 0, "square root (long)" },
  { "cksm", OP16(0xb241LL), MASK_RRE_RR, INSTR_RRE_RR, 3, 0, 0, "checksum" },
  { "bakr", OP16(0xb240LL), MASK_RRE_RR, INSTR_RRE_RR, 3, 0, 0, "branch and stack" },
  { "schm", OP16(0xb23cLL), MASK_S_00, INSTR_S_00, 3, 0, 0, "set channel monitor" },
  { "rchp", OP16(0xb23bLL), MASK_S_00, INSTR_S_00, 3, 0, 0, "reset channel path" },
  { "stcps", OP16(0xb23aLL), MASK_S_RD, INSTR_S_RD, 3, 0, 0, "store channel path status" },
  { "stcrw", OP16(0xb239LL), MASK_S_RD, INSTR_S_RD, 3, 0, 0, "store channel report word" },
  { "rsch", OP16(0xb238LL), MASK_S_00, INSTR_S_00, 3, 0, 0, "resume subchannel" },
  { "sal", OP16(0xb237LL), MASK_S_00, INSTR_S_00, 3, 0, 0, "set address limit" },
  { "tpi", OP16(0xb236LL), MASK_S_RD, INSTR_S_RD, 3, 0, 0, "test pending interruption" },
  { "tsch", OP16(0xb235LL), MASK_S_RD, INSTR_S_RD, 3, 0, 0, "test subchannel" },
  { "stsch", OP16(0xb234LL), MASK_S_RD, INSTR_S_RD, 3, 0, 0, "store subchannel" },
  { "ssch", OP16(0xb233LL), MASK_S_RD, INSTR_S_RD, 3, 0, 0, "start subchannel" },
  { "msch", OP16(0xb232LL), MASK_S_RD, INSTR_S_RD, 3, 0, 0, "modify subchannel" },
  { "hsch", OP16(0xb231LL), MASK_S_00, INSTR_S_00, 3, 0, 0, "halt subchannel" },
  { "csch", OP16(0xb230LL), MASK_S_00, INSTR_S_00, 3, 0, 0, "clear subchannel" },
  { "pgout", OP16(0xb22fLL), MASK_RRE_RR, INSTR_RRE_RR, 3, 0, 0, "page out" },
  { "pgin", OP16(0xb22eLL), MASK_RRE_RR, INSTR_RRE_RR, 3, 0, 0, "page in" },
  { "dxr", OP16(0xb22dLL), MASK_RRE_FEFE, INSTR_RRE_FEFE, 3, 0, 0, "divide (ext.)" },
  { "tb", OP16(0xb22cLL), MASK_RRE_RR, INSTR_RRE_RR, 3, 0, 0, "test block" },
  { "sske", OP16(0xb22bLL), MASK_RRF_U0RR, INSTR_RRF_U0RR, 2, 4, 1, "set storage key extended" },
  { "sske", OP16(0xb22bLL), MASK_RRE_RR, INSTR_RRE_RR, 3, 0, 0, "set storage key extended" },
  { "rrbe", OP16(0xb22aLL), MASK_RRE_RR, INSTR_RRE_RR, 3, 0, 0, "reset reference bit extended" },
  { "iske", OP16(0xb229LL), MASK_RRE_RR, INSTR_RRE_RR, 3, 0, 0, "insert storage key extended" },
  { "pt", OP16(0xb228LL), MASK_RRE_RR, INSTR_RRE_RR, 3, 0, 0, "program transfer" },
  { "esar", OP16(0xb227LL), MASK_RRE_R0, INSTR_RRE_R0, 3, 0, 0, "extract secondary ASN" },
  { "epar", OP16(0xb226LL), MASK_RRE_R0, INSTR_RRE_R0, 3, 0, 0, "extract primary ASN" },
  { "ssar", OP16(0xb225LL), MASK_RRE_R0, INSTR_RRE_R0, 3, 0, 0, "set secondary ASN" },
  { "iac", OP16(0xb224LL), MASK_RRE_R0, INSTR_RRE_R0, 3, 0, 0, "insert address space control" },
  { "ivsk", OP16(0xb223LL), MASK_RRE_RR, INSTR_RRE_RR, 3, 0, 0, "insert virtual storage key" },
  { "ipm", OP16(0xb222LL), MASK_RRE_R0, INSTR_RRE_R0, 3, 0, 0, "insert program mask" },
  { "ipte", OP16(0xb221LL), MASK_RRF_RURR, INSTR_RRF_RURR, 3, 0, 2, "invalidate page table entry" },
  { "cfc", OP16(0xb21aLL), MASK_S_RD, INSTR_S_RD, 3, 0, 0, "compare and form codeword" },
  { "sac", OP16(0xb219LL), MASK_S_RD, INSTR_S_RD, 3, 0, 0, "set address space control" },
  { "pc", OP16(0xb218LL), MASK_S_RD, INSTR_S_RD, 3, 0, 0, "program call" },
  { "sie", OP16(0xb214LL), MASK_S_RD, INSTR_S_RD, 3, 0, 0, "start interpretive execution" },
  { "stap", OP16(0xb212LL), MASK_S_RD, INSTR_S_RD, 3, 0, 0, "store CPU address" },
  { "stpx", OP16(0xb211LL), MASK_S_RD, INSTR_S_RD, 3, 0, 0, "store prefix" },
  { "spx", OP16(0xb210LL), MASK_S_RD, INSTR_S_RD, 3, 0, 0, "set prefix" },
  { "ptlb", OP16(0xb20dLL), MASK_S_00, INSTR_S_00, 3, 0, 0, "purge TLB" },
  { "ipk", OP16(0xb20bLL), MASK_S_00, INSTR_S_00, 3, 0, 0, "insert PSW key" },
  { "spka", OP16(0xb20aLL), MASK_S_RD, INSTR_S_RD, 3, 0, 0, "set PSW key from address" },
  { "stpt", OP16(0xb209LL), MASK_S_RD, INSTR_S_RD, 3, 0, 0, "store CPU timer" },
  { "spt", OP16(0xb208LL), MASK_S_RD, INSTR_S_RD, 3, 0, 0, "set CPU timer" },
  { "stckc", OP16(0xb207LL), MASK_S_RD, INSTR_S_RD, 3, 0, 0, "store clock comparator" },
  { "sckc", OP16(0xb206LL), MASK_S_RD, INSTR_S_RD, 3, 0, 0, "set clock comparator" },
  { "stck", OP16(0xb205LL), MASK_S_RD, INSTR_S_RD, 3, 0, 0, "store clock" },
  { "sck", OP16(0xb204LL), MASK_S_RD, INSTR_S_RD, 3, 0, 0, "set clock" },
  { "stidp", OP16(0xb202LL), MASK_S_RD, INSTR_S_RD, 3, 0, 0, "store CPU id" },
  { "stbear", OP16(0xb201LL), MASK_S_RD, INSTR_S_RD, 2, 12, 0, "store bear" },
  { "lbear", OP16(0xb200LL), MASK_S_RD, INSTR_S_RD, 2, 12, 0, "load bear" },
  { "lra", OP8(0xb1LL), MASK_RX_RRRD, INSTR_RX_RRRD, 3, 0, 0, "load real address" },
  { "mc", OP16(0xaf00LL), MASK_SI_URD, INSTR_SI_URD, 2, 6, 0, "monitor call" },
  { "mc", OP8(0xafLL), MASK_SI_URD, INSTR_SI_URD, 3, 0, 0, "monitor call" },
  { "sigp", OP8(0xaeLL), MASK_RS_RRRD, INSTR_RS_RRRD, 3, 0, 0, "signal processor" },
  { "stosm", OP8(0xadLL), MASK_SI_URD, INSTR_SI_URD, 3, 0, 0, "store then or system mask" },
  { "stnsm", OP8(0xacLL), MASK_SI_URD, INSTR_SI_URD, 3, 0, 0, "store then and system mask" },
  { "clcle", OP8(0xa9LL), MASK_RS_RRRD, INSTR_RS_RRRD, 3, 0, 0, "compare logical long extended" },
  { "mvcle", OP8(0xa8LL), MASK_RS_RERERD, INSTR_RS_RERERD, 3, 0, 0, "move long extended" },
  { "j", OP16(0xa7f4LL), MASK_RI_0P, INSTR_RI_0P, 3, 0, 48, "unconditional jump" },
  { "bru", OP16(0xa7f4LL), MASK_RI_0P, INSTR_RI_0P, 3, 0, 48, "unconditional jump" },
  { "jno", OP16(0xa7e4LL), MASK_RI_0P, INSTR_RI_0P, 3, 0, 112, "conditional jump on not overflow / if not ones" },
  { "brno", OP16(0xa7e4LL), MASK_RI_0P, INSTR_RI_0P, 3, 0, 112, "conditional jump on not overflow / if not ones" },
  { "jnh", OP16(0xa7d4LL), MASK_RI_0P, INSTR_RI_0P, 3, 0, 112, "conditional jump on A not high" },
  { "jnp", OP16(0xa7d4LL), MASK_RI_0P, INSTR_RI_0P, 3, 0, 112, "conditional jump on not plus" },
  { "brnh", OP16(0xa7d4LL), MASK_RI_0P, INSTR_RI_0P, 3, 0, 112, "conditional jump on A not high" },
  { "brnp", OP16(0xa7d4LL), MASK_RI_0P, INSTR_RI_0P, 3, 0, 112, "conditional jump on not plus" },
  { "jle", OP16(0xa7c4LL), MASK_RI_0P, INSTR_RI_0P, 3, 0, 112, "conditional jump on low or equal" },
  { "brle", OP16(0xa7c4LL), MASK_RI_0P, INSTR_RI_0P, 3, 0, 112, "conditional jump on low or equal" },
  { "jnl", OP16(0xa7b4LL), MASK_RI_0P, INSTR_RI_0P, 3, 0, 112, "conditional jump on A not low" },
  { "jnm", OP16(0xa7b4LL), MASK_RI_0P, INSTR_RI_0P, 3, 0, 112, "conditional jump on not minus / if not mixed" },
  { "brnl", OP16(0xa7b4LL), MASK_RI_0P, INSTR_RI_0P, 3, 0, 112, "conditional jump on A not low" },
  { "brnm", OP16(0xa7b4LL), MASK_RI_0P, INSTR_RI_0P, 3, 0, 112, "conditional jump on not minus / if not mixed" },
  { "jhe", OP16(0xa7a4LL), MASK_RI_0P, INSTR_RI_0P, 3, 0, 112, "conditional jump on high or equal" },
  { "brhe", OP16(0xa7a4LL), MASK_RI_0P, INSTR_RI_0P, 3, 0, 112, "conditional jump on high or equal" },
  { "jnlh", OP16(0xa794LL), MASK_RI_0P, INSTR_RI_0P, 3, 0, 112, "conditional jump on not low or high" },
  { "brnlh", OP16(0xa794LL), MASK_RI_0P, INSTR_RI_0P, 3, 0, 112, "conditional jump on not low or high" },
  { "je", OP16(0xa784LL), MASK_RI_0P, INSTR_RI_0P, 3, 0, 112, "conditional jump on A equal B" },
  { "jz", OP16(0xa784LL), MASK_RI_0P, INSTR_RI_0P, 3, 0, 112, "conditional jump on zero / if zeros" },
  { "bre", OP16(0xa784LL), MASK_RI_0P, INSTR_RI_0P, 3, 0, 112, "conditional jump on A equal B" },
  { "brz", OP16(0xa784LL), MASK_RI_0P, INSTR_RI_0P, 3, 0, 112, "conditional jump on zero / if zeros" },
  { "jne", OP16(0xa774LL), MASK_RI_0P, INSTR_RI_0P, 3, 0, 112, "conditional jump on A not equal B" },
  { "jnz", OP16(0xa774LL), MASK_RI_0P, INSTR_RI_0P, 3, 0, 112, "conditional jump on not zero / if not zeros" },
  { "brne", OP16(0xa774LL), MASK_RI_0P, INSTR_RI_0P, 3, 0, 112, "conditional jump on A not equal B" },
  { "brnz", OP16(0xa774LL), MASK_RI_0P, INSTR_RI_0P, 3, 0, 112, "conditional jump on not zero / if not zeros" },
  { "jlh", OP16(0xa764LL), MASK_RI_0P, INSTR_RI_0P, 3, 0, 112, "conditional jump on low or high" },
  { "brlh", OP16(0xa764LL), MASK_RI_0P, INSTR_RI_0P, 3, 0, 112, "conditional jump on low or high" },
  { "jnhe", OP16(0xa754LL), MASK_RI_0P, INSTR_RI_0P, 3, 0, 112, "conditional jump on not high or equal" },
  { "brnhe", OP16(0xa754LL), MASK_RI_0P, INSTR_RI_0P, 3, 0, 112, "conditional jump on not high or equal" },
  { "jl", OP16(0xa744LL), MASK_RI_0P, INSTR_RI_0P, 3, 0, 112, "conditional jump on A low" },
  { "jm", OP16(0xa744LL), MASK_RI_0P, INSTR_RI_0P, 3, 0, 112, "conditional jump on minus / if mixed" },
  { "brl", OP16(0xa744LL), MASK_RI_0P, INSTR_RI_0P, 3, 0, 112, "conditional jump on A low" },
  { "brm", OP16(0xa744LL), MASK_RI_0P, INSTR_RI_0P, 3, 0, 112, "conditional jump on minus / if mixed" },
  { "jnle", OP16(0xa734LL), MASK_RI_0P, INSTR_RI_0P, 3, 0, 112, "conditional jump on not low or equal" },
  { "brnle", OP16(0xa734LL), MASK_RI_0P, INSTR_RI_0P, 3, 0, 112, "conditional jump on not low or equal" },
  { "jh", OP16(0xa724LL), MASK_RI_0P, INSTR_RI_0P, 3, 0, 112, "conditional jump on A high" },
  { "jp", OP16(0xa724LL), MASK_RI_0P, INSTR_RI_0P, 3, 0, 112, "conditional jump on plus" },
  { "brh", OP16(0xa724LL), MASK_RI_0P, INSTR_RI_0P, 3, 0, 112, "conditional jump on A high" },
  { "brp", OP16(0xa724LL), MASK_RI_0P, INSTR_RI_0P, 3, 0, 112, "conditional jump on plus" },
  { "jo", OP16(0xa714LL), MASK_RI_0P, INSTR_RI_0P, 3, 0, 112, "conditional jump on overflow / if ones" },
  { "bro", OP16(0xa714LL), MASK_RI_0P, INSTR_RI_0P, 3, 0, 112, "conditional jump on overflow / if ones" },
  { "cghi", OP16(0xa70fLL), MASK_RI_RI, INSTR_RI_RI, 2, 2, 0, "compare halfword immediate 64" },
  { "chi", OP16(0xa70eLL), MASK_RI_RI, INSTR_RI_RI, 3, 0, 0, "compare halfword immediate" },
  { "mghi", OP16(0xa70dLL), MASK_RI_RI, INSTR_RI_RI, 2, 2, 0, "multiply halfword immediate 64" },
  { "mhi", OP16(0xa70cLL), MASK_RI_RI, INSTR_RI_RI, 3, 0, 0, "multiply halfword immediate" },
  { "aghi", OP16(0xa70bLL), MASK_RI_RI, INSTR_RI_RI, 2, 2, 0, "add halfword immediate 64" },
  { "ahi", OP16(0xa70aLL), MASK_RI_RI, INSTR_RI_RI, 3, 0, 0, "add halfword immediate" },
  { "lghi", OP16(0xa709LL), MASK_RI_RI, INSTR_RI_RI, 2, 2, 0, "load halfword immediate 64" },
  { "lhi", OP16(0xa708LL), MASK_RI_RI, INSTR_RI_RI, 3, 0, 0, "load halfword immediate" },
  { "brctg", OP16(0xa707LL), MASK_RI_RP, INSTR_RI_RP, 2, 2, 112, "branch relative on count 64" },
  { "jctg", OP16(0xa707LL), MASK_RI_RP, INSTR_RI_RP, 2, 2, 112, "branch relative on count 64" },
  { "brct", OP16(0xa706LL), MASK_RI_RP, INSTR_RI_RP, 3, 0, 112, "branch relative on count" },
  { "jct", OP16(0xa706LL), MASK_RI_RP, INSTR_RI_RP, 3, 0, 112, "branch relative on count" },
  { "bras", OP16(0xa705LL), MASK_RI_RP, INSTR_RI_RP, 3, 0, 176, "branch relative and save" },
  { "jas", OP16(0xa705LL), MASK_RI_RP, INSTR_RI_RP, 3, 0, 176, "branch relative and save" },
  { "brc", OP16(0xa704LL), MASK_RI_UP, INSTR_RI_UP, 3, 0, 112, "branch relative on condition" },
  { "jc", OP16(0xa704LL), MASK_RI_UP, INSTR_RI_UP, 3, 0, 112, "conditional jump" },
  { "jnop", OP16(0xa704LL), MASK_RI_0P, INSTR_RI_0P, 3, 0, 0, "nop jump" },
  { "tmhl", OP16(0xa703LL), MASK_RI_RU, INSTR_RI_RU, 2, 2, 0, "test under mask high low" },
  { "tmhh", OP16(0xa702LL), MASK_RI_RU, INSTR_RI_RU, 2, 2, 0, "test under mask high high" },
  { "tmll", OP16(0xa701LL), MASK_RI_RU, INSTR_RI_RU, 3, 0, 0, "test under mask low low" },
  { "tml", OP16(0xa701LL), MASK_RI_RU, INSTR_RI_RU, 3, 0, 0, "test under mask low" },
  { "tmlh", OP16(0xa700LL), MASK_RI_RU, INSTR_RI_RU, 3, 0, 0, "test under mask low high" },
  { "tmh", OP16(0xa700LL), MASK_RI_RU, INSTR_RI_RU, 3, 0, 0, "test under mask high" },
  { "llill", OP16(0xa50fLL), MASK_RI_RU, INSTR_RI_RU, 2, 2, 0, "load logical immediate low low" },
  { "llghi", OP16(0xa50fLL), MASK_RI_RU, INSTR_RI_RU, 2, 2, 0, "load logical immediate" },
  { "llilh", OP16(0xa50eLL), MASK_RI_RU, INSTR_RI_RU, 2, 2, 0, "load logical immediate low high" },
  { "llihl", OP16(0xa50dLL), MASK_RI_RU, INSTR_RI_RU, 2, 2, 0, "load logical immediate high low" },
  { "llihh", OP16(0xa50cLL), MASK_RI_RU, INSTR_RI_RU, 2, 2, 0, "load logical immediate high high" },
  { "oill", OP16(0xa50bLL), MASK_RI_RU, INSTR_RI_RU, 2, 2, 0, "or immediate low low" },
  { "oilh", OP16(0xa50aLL), MASK_RI_RU, INSTR_RI_RU, 2, 2, 0, "or immediate low high" },
  { "oihl", OP16(0xa509LL), MASK_RI_RU, INSTR_RI_RU, 2, 2, 0, "or immediate high low" },
  { "oihh", OP16(0xa508LL), MASK_RI_RU, INSTR_RI_RU, 2, 2, 0, "or immediate high high" },
  { "nill", OP16(0xa507LL), MASK_RI_RU, INSTR_RI_RU, 2, 2, 0, "and immediate low low" },
  { "nilh", OP16(0xa506LL), MASK_RI_RU, INSTR_RI_RU, 2, 2, 0, "and immediate low high" },
  { "nihl", OP16(0xa505LL), MASK_RI_RU, INSTR_RI_RU, 2, 2, 0, "and immediate high low" },
  { "nihh", OP16(0xa504LL), MASK_RI_RU, INSTR_RI_RU, 2, 2, 0, "and immediate high high" },
  { "iill", OP16(0xa503LL), MASK_RI_RU, INSTR_RI_RU, 2, 2, 0, "insert immediate low low" },
  { "iilh", OP16(0xa502LL), MASK_RI_RU, INSTR_RI_RU, 2, 2, 0, "insert immediate low high" },
  { "iihl", OP16(0xa501LL), MASK_RI_RU, INSTR_RI_RU, 2, 2, 0, "insert immediate high low" },
  { "iihh", OP16(0xa500LL), MASK_RI_RU, INSTR_RI_RU, 2, 2, 0, "insert immediate high high" },
  { "stam", OP8(0x9bLL), MASK_RS_AARD, INSTR_RS_AARD, 3, 0, 0, "store access multiple" },
  { "lam", OP8(0x9aLL), MASK_RS_AARD, INSTR_RS_AARD, 3, 0, 0, "load access multiple" },
  { "trace", OP8(0x99LL), MASK_RS_RRRD, INSTR_RS_RRRD, 3, 0, 0, "trace" },
  { "lm", OP8(0x98LL), MASK_RS_RRRD, INSTR_RS_RRRD, 3, 0, 0, "load multiple" },
  { "xi", OP8(0x97LL), MASK_SI_URD, INSTR_SI_URD, 3, 0, 0, "exclusive or" },
  { "oi", OP8(0x96LL), MASK_SI_URD, INSTR_SI_URD, 3, 0, 0, "or" },
  { "cli", OP8(0x95LL), MASK_SI_URD, INSTR_SI_URD, 3, 0, 0, "compare logical" },
  { "ni", OP8(0x94LL), MASK_SI_URD, INSTR_SI_URD, 3, 0, 0, "and" },
  { "ts", OP8(0x93LL), MASK_SI_RD, INSTR_SI_RD, 3, 0, 0, "test and set" },
  { "mvi", OP8(0x92LL), MASK_SI_URD, INSTR_SI_URD, 3, 0, 0, "move" },
  { "tm", OP8(0x91LL), MASK_SI_URD, INSTR_SI_URD, 3, 0, 0, "test under mask" },
  { "stm", OP8(0x90LL), MASK_RS_RRRD, INSTR_RS_RRRD, 3, 0, 0, "store multiple" },
  { "slda", OP8(0x8fLL), MASK_RS_RE0RD, INSTR_RS_RE0RD, 3, 0, 0, "shift left double (long)" },
  { "srda", OP8(0x8eLL), MASK_RS_RE0RD, INSTR_RS_RE0RD, 3, 0, 0, "shift right double (long)" },
  { "sldl", OP8(0x8dLL), MASK_RS_RE0RD, INSTR_RS_RE0RD, 3, 0, 0, "shift left double logical (long)" },
  { "srdl", OP8(0x8cLL), MASK_RS_RE0RD, INSTR_RS_RE0RD, 3, 0, 0, "shift right double logical (long)" },
  { "sla", OP8(0x8bLL), MASK_RS_R0RD, INSTR_RS_R0RD, 3, 0, 0, "shift left single" },
  { "sra", OP8(0x8aLL), MASK_RS_R0RD, INSTR_RS_R0RD, 3, 0, 0, "shift right single" },
  { "sll", OP8(0x89LL), MASK_RS_R0RD, INSTR_RS_R0RD, 3, 0, 0, "shift left single logical" },
  { "srl", OP8(0x88LL), MASK_RS_R0RD, INSTR_RS_R0RD, 3, 0, 0, "shift right single logical" },
  { "bxle", OP8(0x87LL), MASK_RS_RRRD, INSTR_RS_RRRD, 3, 0, 0, "branch on index low or equal" },
  { "bxh", OP8(0x86LL), MASK_RS_RRRD, INSTR_RS_RRRD, 3, 0, 0, "branch on index high" },
  { "brxle", OP8(0x85LL), MASK_RSI_RRP, INSTR_RSI_RRP, 3, 0, 112, "branch relative on index low or equal" },
  { "jxle", OP8(0x85LL), MASK_RSI_RRP, INSTR_RSI_RRP, 3, 0, 112, "branch relative on index low or equal" },
  { "brxh", OP8(0x84LL), MASK_RSI_RRP, INSTR_RSI_RRP, 3, 0, 112, "branch relative on index high" },
  { "jxh", OP8(0x84LL), MASK_RSI_RRP, INSTR_RSI_RRP, 3, 0, 112, "branch relative on index high" },
  { "diag", OP8(0x83LL), MASK_RS_RRRD, INSTR_RS_RRRD, 3, 0, 0, "diagnose" },
  { "lpsw", OP8(0x82LL), MASK_SI_RD, INSTR_SI_RD, 3, 0, 0, "load PSW" },
  { "ssm", OP8(0x80LL), MASK_SI_RD, INSTR_SI_RD, 3, 0, 0, "set system mask" },
  { "su", OP8(0x7fLL), MASK_RX_FRRD, INSTR_RX_FRRD, 3, 0, 0, "subtract unnormalized (short)" },
  { "au", OP8(0x7eLL), MASK_RX_FRRD, INSTR_RX_FRRD, 3, 0, 0, "add unnormalized (short)" },
  { "de", OP8(0x7dLL), MASK_RX_FRRD, INSTR_RX_FRRD, 3, 0, 0, "divide (short)" },
  { "mde", OP8(0x7cLL), MASK_RX_FRRD, INSTR_RX_FRRD, 3, 0, 0, "multiply (short to long)" },
  { "me", OP8(0x7cLL), MASK_RX_FRRD, INSTR_RX_FRRD, 3, 0, 0, "multiply (short to long)" },
  { "se", OP8(0x7bLL), MASK_RX_FRRD, INSTR_RX_FRRD, 3, 0, 0, "subtract normalized (short)" },
  { "ae", OP8(0x7aLL), MASK_RX_FRRD, INSTR_RX_FRRD, 3, 0, 0, "add normalized (short)" },
  { "ce", OP8(0x79LL), MASK_RX_FRRD, INSTR_RX_FRRD, 3, 0, 0, "compare (short)" },
  { "le", OP8(0x78LL), MASK_RX_FRRD, INSTR_RX_FRRD, 3, 0, 0, "load (short)" },
  { "ms", OP8(0x71LL), MASK_RX_RRRD, INSTR_RX_RRRD, 3, 0, 0, "multiply single" },
  { "ste", OP8(0x70LL), MASK_RX_FRRD, INSTR_RX_FRRD, 3, 0, 0, "store (short)" },
  { "sw", OP8(0x6fLL), MASK_RX_FRRD, INSTR_RX_FRRD, 3, 0, 0, "subtract unnormalized (long)" },
  { "aw", OP8(0x6eLL), MASK_RX_FRRD, INSTR_RX_FRRD, 3, 0, 0, "add unnormalized (long)" },
  { "dd", OP8(0x6dLL), MASK_RX_FRRD, INSTR_RX_FRRD, 3, 0, 0, "divide (long)" },
  { "md", OP8(0x6cLL), MASK_RX_FRRD, INSTR_RX_FRRD, 3, 0, 0, "multiply (long)" },
  { "sd", OP8(0x6bLL), MASK_RX_FRRD, INSTR_RX_FRRD, 3, 0, 0, "subtract normalized (long)" },
  { "ad", OP8(0x6aLL), MASK_RX_FRRD, INSTR_RX_FRRD, 3, 0, 0, "add normalized (long)" },
  { "cd", OP8(0x69LL), MASK_RX_FRRD, INSTR_RX_FRRD, 3, 0, 0, "compare (long)" },
  { "ld", OP8(0x68LL), MASK_RX_FRRD, INSTR_RX_FRRD, 3, 0, 0, "load (long)" },
  { "mxd", OP8(0x67LL), MASK_RX_FERRD, INSTR_RX_FERRD, 3, 0, 0, "multiply (long to ext.)" },
  { "std", OP8(0x60LL), MASK_RX_FRRD, INSTR_RX_FRRD, 3, 0, 0, "store (long)" },
  { "sl", OP8(0x5fLL), MASK_RX_RRRD, INSTR_RX_RRRD, 3, 0, 0, "subtract logical" },
  { "al", OP8(0x5eLL), MASK_RX_RRRD, INSTR_RX_RRRD, 3, 0, 0, "add logical" },
  { "d", OP8(0x5dLL), MASK_RX_RERRD, INSTR_RX_RERRD, 3, 0, 0, "divide" },
  { "m", OP8(0x5cLL), MASK_RX_RERRD, INSTR_RX_RERRD, 3, 0, 0, "multiply" },
  { "s", OP8(0x5bLL), MASK_RX_RRRD, INSTR_RX_RRRD, 3, 0, 0, "subtract" },
  { "a", OP8(0x5aLL), MASK_RX_RRRD, INSTR_RX_RRRD, 3, 0, 0, "add" },
  { "c", OP8(0x59LL), MASK_RX_RRRD, INSTR_RX_RRRD, 3, 0, 0, "compare" },
  { "l", OP8(0x58LL), MASK_RX_RRRD, INSTR_RX_RRRD, 3, 0, 0, "load" },
  { "x", OP8(0x57LL), MASK_RX_RRRD, INSTR_RX_RRRD, 3, 0, 0, "exclusive or" },
  { "o", OP8(0x56LL), MASK_RX_RRRD, INSTR_RX_RRRD, 3, 0, 0, "or" },
  { "cl", OP8(0x55LL), MASK_RX_RRRD, INSTR_RX_RRRD, 3, 0, 0, "compare logical" },
  { "n", OP8(0x54LL), MASK_RX_RRRD, INSTR_RX_RRRD, 3, 0, 0, "and" },
  { "lae", OP8(0x51LL), MASK_RX_RRRD, INSTR_RX_RRRD, 3, 0, 0, "load address extended" },
  { "st", OP8(0x50LL), MASK_RX_RRRD, INSTR_RX_RRRD, 3, 0, 0, "store" },
  { "cvb", OP8(0x4fLL), MASK_RX_RRRD, INSTR_RX_RRRD, 3, 0, 0, "convert to binary" },
  { "cvd", OP8(0x4eLL), MASK_RX_RRRD, INSTR_RX_RRRD, 3, 0, 0, "convert to decimal" },
  { "bas", OP8(0x4dLL), MASK_RX_RRRD, INSTR_RX_RRRD, 3, 0, 0, "branch and save" },
  { "mh", OP8(0x4cLL), MASK_RX_RRRD, INSTR_RX_RRRD, 3, 0, 0, "multiply halfword" },
  { "sh", OP8(0x4bLL), MASK_RX_RRRD, INSTR_RX_RRRD, 3, 0, 0, "subtract halfword" },
  { "ah", OP8(0x4aLL), MASK_RX_RRRD, INSTR_RX_RRRD, 3, 0, 0, "add halfword" },
  { "ch", OP8(0x49LL), MASK_RX_RRRD, INSTR_RX_RRRD, 3, 0, 0, "compare halfword" },
  { "lh", OP8(0x48LL), MASK_RX_RRRD, INSTR_RX_RRRD, 3, 0, 0, "load halfword" },
  { "b", OP16(0x47f0LL), MASK_RX_0RRD, INSTR_RX_0RRD, 3, 0, 0, "unconditional branch" },
  { "bno", OP16(0x47e0LL), MASK_RX_0RRD, INSTR_RX_0RRD, 3, 0, 0, "conditional branch on not overflow / if not ones" },
  { "bnh", OP16(0x47d0LL), MASK_RX_0RRD, INSTR_RX_0RRD, 3, 0, 0, "conditional branch on A not high" },
  { "bnp", OP16(0x47d0LL), MASK_RX_0RRD, INSTR_RX_0RRD, 3, 0, 0, "conditional branch on not plus" },
  { "ble", OP16(0x47c0LL), MASK_RX_0RRD, INSTR_RX_0RRD, 3, 0, 0, "conditional branch on low or equal" },
  { "bnl", OP16(0x47b0LL), MASK_RX_0RRD, INSTR_RX_0RRD, 3, 0, 0, "conditional branch on A not low" },
  { "bnm", OP16(0x47b0LL), MASK_RX_0RRD, INSTR_RX_0RRD, 3, 0, 0, "conditional branch on not minus / if not mixed" },
  { "bhe", OP16(0x47a0LL), MASK_RX_0RRD, INSTR_RX_0RRD, 3, 0, 0, "conditional branch on high or equal" },
  { "bnlh", OP16(0x4790LL), MASK_RX_0RRD, INSTR_RX_0RRD, 3, 0, 0, "conditional branch on not low or high" },
  { "be", OP16(0x4780LL), MASK_RX_0RRD, INSTR_RX_0RRD, 3, 0, 0, "conditional branch on A equal B" },
  { "bz", OP16(0x4780LL), MASK_RX_0RRD, INSTR_RX_0RRD, 3, 0, 0, "conditional branch on zero / if zeros" },
  { "bne", OP16(0x4770LL), MASK_RX_0RRD, INSTR_RX_0RRD, 3, 0, 0, "conditional branch on A not equal B" },
  { "bnz", OP16(0x4770LL), MASK_RX_0RRD, INSTR_RX_0RRD, 3, 0, 0, "conditional branch on not zero / if not zeros" },
  { "blh", OP16(0x4760LL), MASK_RX_0RRD, INSTR_RX_0RRD, 3, 0, 0, "conditional branch on low or high" },
  { "bnhe", OP16(0x4750LL), MASK_RX_0RRD, INSTR_RX_0RRD, 3, 0, 0, "conditional branch on not high or equal" },
  { "bl", OP16(0x4740LL), MASK_RX_0RRD, INSTR_RX_0RRD, 3, 0, 0, "conditional branch on A low" },
  { "bm", OP16(0x4740LL), MASK_RX_0RRD, INSTR_RX_0RRD, 3, 0, 0, "conditional branch on minus / if mixed" },
  { "bnle", OP16(0x4730LL), MASK_RX_0RRD, INSTR_RX_0RRD, 3, 0, 0, "conditional branch on not low or equal" },
  { "bh", OP16(0x4720LL), MASK_RX_0RRD, INSTR_RX_0RRD, 3, 0, 0, "conditional branch on A high" },
  { "bp", OP16(0x4720LL), MASK_RX_0RRD, INSTR_RX_0RRD, 3, 0, 0, "conditional branch on plus" },
  { "bo", OP16(0x4710LL), MASK_RX_0RRD, INSTR_RX_0RRD, 3, 0, 0, "conditional branch on overflow / if ones" },
  { "bc", OP8(0x47LL), MASK_RX_URRD, INSTR_RX_URRD, 3, 0, 0, "branch on condition" },
  { "nop", OP16(0x4700LL), MASK_RX_0RRD, INSTR_RX_0RRD, 3, 0, 1, "no operation" },
  { "bct", OP8(0x46LL), MASK_RX_RRRD, INSTR_RX_RRRD, 3, 0, 0, "branch on count" },
  { "bal", OP8(0x45LL), MASK_RX_RRRD, INSTR_RX_RRRD, 3, 0, 0, "branch and link" },
  { "ex", OP8(0x44LL), MASK_RX_RRRD, INSTR_RX_RRRD, 3, 0, 0, "execute" },
  { "ic", OP8(0x43LL), MASK_RX_RRRD, INSTR_RX_RRRD, 3, 0, 0, "insert character" },
  { "stc", OP8(0x42LL), MASK_RX_RRRD, INSTR_RX_RRRD, 3, 0, 0, "store character" },
  { "la", OP8(0x41LL), MASK_RX_RRRD, INSTR_RX_RRRD, 3, 0, 0, "load address" },
  { "sth", OP8(0x40LL), MASK_RX_RRRD, INSTR_RX_RRRD, 3, 0, 0, "store halfword" },
  { "sur", OP8(0x3fLL), MASK_RR_FF, INSTR_RR_FF, 3, 0, 0, "subtract unnormalized (short)" },
  { "aur", OP8(0x3eLL), MASK_RR_FF, INSTR_RR_FF, 3, 0, 0, "add unnormalized (short)" },
  { "der", OP8(0x3dLL), MASK_RR_FF, INSTR_RR_FF, 3, 0, 0, "divide (short)" },
  { "mder", OP8(0x3cLL), MASK_RR_FF, INSTR_RR_FF, 3, 0, 0, "multiply short to long hfp" },
  { "mer", OP8(0x3cLL), MASK_RR_FF, INSTR_RR_FF, 3, 0, 0, "multiply (short to long)" },
  { "ser", OP8(0x3bLL), MASK_RR_FF, INSTR_RR_FF, 3, 0, 0, "subtract normalized (short)" },
  { "aer", OP8(0x3aLL), MASK_RR_FF, INSTR_RR_FF, 3, 0, 0, "add normalized (short)" },
  { "cer", OP8(0x39LL), MASK_RR_FF, INSTR_RR_FF, 3, 0, 0, "compare (short)" },
  { "ler", OP8(0x38LL), MASK_RR_FF, INSTR_RR_FF, 3, 0, 0, "load (short)" },
  { "sxr", OP8(0x37LL), MASK_RR_FEFE, INSTR_RR_FEFE, 3, 0, 0, "subtract normalized (ext.)" },
  { "axr", OP8(0x36LL), MASK_RR_FEFE, INSTR_RR_FEFE, 3, 0, 0, "add normalized" },
  { "ledr", OP8(0x35LL), MASK_RR_FF, INSTR_RR_FF, 3, 0, 0, "load rounded (long to short)" },
  { "lrer", OP8(0x35LL), MASK_RR_FF, INSTR_RR_FF, 3, 0, 0, "load rounded (long to short)" },
  { "her", OP8(0x34LL), MASK_RR_FF, INSTR_RR_FF, 3, 0, 0, "halve (short)" },
  { "lcer", OP8(0x33LL), MASK_RR_FF, INSTR_RR_FF, 3, 0, 0, "load complement (short)" },
  { "lter", OP8(0x32LL), MASK_RR_FF, INSTR_RR_FF, 3, 0, 0, "load and test (short)" },
  { "lner", OP8(0x31LL), MASK_RR_FF, INSTR_RR_FF, 3, 0, 0, "load negative (short)" },
  { "lper", OP8(0x30LL), MASK_RR_FF, INSTR_RR_FF, 3, 0, 0, "load positive (short)" },
  { "swr", OP8(0x2fLL), MASK_RR_FF, INSTR_RR_FF, 3, 0, 0, "subtract unnormalized (long)" },
  { "awr", OP8(0x2eLL), MASK_RR_FF, INSTR_RR_FF, 3, 0, 0, "add unnormalized (long)" },
  { "ddr", OP8(0x2dLL), MASK_RR_FF, INSTR_RR_FF, 3, 0, 0, "divide (long)" },
  { "mdr", OP8(0x2cLL), MASK_RR_FF, INSTR_RR_FF, 3, 0, 0, "multiply (long)" },
  { "sdr", OP8(0x2bLL), MASK_RR_FF, INSTR_RR_FF, 3, 0, 0, "subtract normalized (long)" },
  { "adr", OP8(0x2aLL), MASK_RR_FF, INSTR_RR_FF, 3, 0, 0, "add normalized (long)" },
  { "cdr", OP8(0x29LL), MASK_RR_FF, INSTR_RR_FF, 3, 0, 0, "compare (long)" },
  { "ldr", OP8(0x28LL), MASK_RR_FF, INSTR_RR_FF, 3, 0, 0, "load (long)" },
  { "mxdr", OP8(0x27LL), MASK_RR_FEF, INSTR_RR_FEF, 3, 0, 0, "multiply (long to ext.)" },
  { "mxr", OP8(0x26LL), MASK_RR_FEFE, INSTR_RR_FEFE, 3, 0, 0, "multiply (ext.)" },
  { "ldxr", OP8(0x25LL), MASK_RR_FFE, INSTR_RR_FFE, 3, 0, 0, "load rounded (ext. to long)" },
  { "lrdr", OP8(0x25LL), MASK_RR_FFE, INSTR_RR_FFE, 3, 0, 0, "load rounded (ext. to long)" },
  { "hdr", OP8(0x24LL), MASK_RR_FF, INSTR_RR_FF, 3, 0, 0, "halve (long)" },
  { "lcdr", OP8(0x23LL), MASK_RR_FF, INSTR_RR_FF, 3, 0, 0, "load complement (long)" },
  { "ltdr", OP8(0x22LL), MASK_RR_FF, INSTR_RR_FF, 3, 0, 0, "load and test (long)" },
  { "lndr", OP8(0x21LL), MASK_RR_FF, INSTR_RR_FF, 3, 0, 0, "load negative (long)" },
  { "lpdr", OP8(0x20LL), MASK_RR_FF, INSTR_RR_FF, 3, 0, 0, "load positive (long)" },
  { "slr", OP8(0x1fLL), MASK_RR_RR, INSTR_RR_RR, 3, 0, 0, "subtract logical" },
  { "alr", OP8(0x1eLL), MASK_RR_RR, INSTR_RR_RR, 3, 0, 0, "add logical" },
  { "dr", OP8(0x1dLL), MASK_RR_RER, INSTR_RR_RER, 3, 0, 0, "divide" },
  { "mr", OP8(0x1cLL), MASK_RR_RER, INSTR_RR_RER, 3, 0, 0, "multiply" },
  { "sr", OP8(0x1bLL), MASK_RR_RR, INSTR_RR_RR, 3, 0, 0, "subtract" },
  { "ar", OP8(0x1aLL), MASK_RR_RR, INSTR_RR_RR, 3, 0, 0, "add" },
  { "cr", OP8(0x19LL), MASK_RR_RR, INSTR_RR_RR, 3, 0, 0, "compare" },
  { "lr", OP8(0x18LL), MASK_RR_RR, INSTR_RR_RR, 3, 0, 0, "load" },
  { "xr", OP8(0x17LL), MASK_RR_RR, INSTR_RR_RR, 3, 0, 0, "exclusive or" },
  { "or", OP8(0x16LL), MASK_RR_RR, INSTR_RR_RR, 3, 0, 0, "or" },
  { "clr", OP8(0x15LL), MASK_RR_RR, INSTR_RR_RR, 3, 0, 0, "compare logical" },
  { "nr", OP8(0x14LL), MASK_RR_RR, INSTR_RR_RR, 3, 0, 0, "and" },
  { "lcr", OP8(0x13LL), MASK_RR_RR, INSTR_RR_RR, 3, 0, 0, "load complement" },
  { "ltr", OP8(0x12LL), MASK_RR_RR, INSTR_RR_RR, 3, 0, 0, "load and test" },
  { "lnr", OP8(0x11LL), MASK_RR_RR, INSTR_RR_RR, 3, 0, 0, "load negative" },
  { "lpr", OP8(0x10LL), MASK_RR_RR, INSTR_RR_RR, 3, 0, 0, "load positive" },
  { "clcl", OP8(0x0fLL), MASK_RR_RR, INSTR_RR_RR, 3, 0, 0, "compare logical long" },
  { "mvcl", OP8(0x0eLL), MASK_RR_RR, INSTR_RR_RR, 3, 0, 0, "move long" },
  { "basr", OP8(0x0dLL), MASK_RR_RR, INSTR_RR_RR, 3, 0, 0, "branch and save" },
  { "bassm", OP8(0x0cLL), MASK_RR_RR, INSTR_RR_RR, 3, 0, 0, "branch and save and set mode" },
  { "bsm", OP8(0x0bLL), MASK_RR_RR, INSTR_RR_RR, 3, 0, 0, "branch and set mode" },
  { "svc", OP8(0x0aLL), MASK_RR_U0, INSTR_RR_U0, 3, 0, 0, "supervisor call" },
  { "br", OP16(0x07f0LL), MASK_RR_0R, INSTR_RR_0R, 3, 0, 0, "unconditional branch" },
  { "bnor", OP16(0x07e0LL), MASK_RR_0R, INSTR_RR_0R, 3, 0, 0, "conditional branch on not overflow / if not ones" },
  { "bnhr", OP16(0x07d0LL), MASK_RR_0R, INSTR_RR_0R, 3, 0, 0, "conditional branch on A not high" },
  { "bnpr", OP16(0x07d0LL), MASK_RR_0R, INSTR_RR_0R, 3, 0, 0, "conditional branch on not plus" },
  { "bler", OP16(0x07c0LL), MASK_RR_0R, INSTR_RR_0R, 3, 0, 0, "conditional branch on low or equal" },
  { "bnlr", OP16(0x07b0LL), MASK_RR_0R, INSTR_RR_0R, 3, 0, 0, "conditional branch on A not low" },
  { "bnmr", OP16(0x07b0LL), MASK_RR_0R, INSTR_RR_0R, 3, 0, 0, "conditional branch on not minus / if not mixed" },
  { "bher", OP16(0x07a0LL), MASK_RR_0R, INSTR_RR_0R, 3, 0, 0, "conditional branch on high or equal" },
  { "bnlhr", OP16(0x0790LL), MASK_RR_0R, INSTR_RR_0R, 3, 0, 0, "conditional branch on not low or high" },
  { "ber", OP16(0x0780LL), MASK_RR_0R, INSTR_RR_0R, 3, 0, 0, "conditional branch on A equal B" },
  { "bzr", OP16(0x0780LL), MASK_RR_0R, INSTR_RR_0R, 3, 0, 0, "conditional branch on zero / if zeros" },
  { "bner", OP16(0x0770LL), MASK_RR_0R, INSTR_RR_0R, 3, 0, 0, "conditional branch on A not equal B" },
  { "bnzr", OP16(0x0770LL), MASK_RR_0R, INSTR_RR_0R, 3, 0, 0, "conditional branch on not zero / if not zeros" },
  { "blhr", OP16(0x0760LL), MASK_RR_0R, INSTR_RR_0R, 3, 0, 0, "conditional branch on low or high" },
  { "bnher", OP16(0x0750LL), MASK_RR_0R, INSTR_RR_0R, 3, 0, 0, "conditional branch on not high or equal" },
  { "blr", OP16(0x0740LL), MASK_RR_0R, INSTR_RR_0R, 3, 0, 0, "conditional branch on A low" },
  { "bmr", OP16(0x0740LL), MASK_RR_0R, INSTR_RR_0R, 3, 0, 0, "conditional branch on minus / if mixed" },
  { "bnler", OP16(0x0730LL), MASK_RR_0R, INSTR_RR_0R, 3, 0, 0, "conditional branch on not low or equal" },
  { "bhr", OP16(0x0720LL), MASK_RR_0R, INSTR_RR_0R, 3, 0, 0, "conditional branch on A high" },
  { "bpr", OP16(0x0720LL), MASK_RR_0R, INSTR_RR_0R, 3, 0, 0, "conditional branch on plus" },
  { "bor", OP16(0x0710LL), MASK_RR_0R, INSTR_RR_0R, 3, 0, 0, "conditional branch on overflow / if ones" },
  { "bcr", OP8(0x07LL), MASK_RR_UR, INSTR_RR_UR, 3, 0, 0, "branch on condition" },
  { "nopr", OP16(0x0700LL), MASK_RR_0R, INSTR_RR_0R, 3, 0, 1, "no operation" },
  { "bctr", OP8(0x06LL), MASK_RR_RR, INSTR_RR_RR, 3, 0, 0, "branch on count" },
  { "balr", OP8(0x05LL), MASK_RR_RR, INSTR_RR_RR, 3, 0, 0, "branch and link" },
  { "spm", OP8(0x04LL), MASK_RR_R0, INSTR_RR_R0, 3, 0, 0, "set program mask" },
  { "trap2", OP16(0x01ffLL), MASK_E, INSTR_E, 3, 0, 0, "trap" },
  { "sam64", OP16(0x010eLL), MASK_E, INSTR_E, 2, 2, 0, "set addressing mode 64" },
  { "sam31", OP16(0x010dLL), MASK_E, INSTR_E, 3, 2, 0, "set addressing mode 31" },
  { "sam24", OP16(0x010cLL), MASK_E, INSTR_E, 3, 2, 0, "set addressing mode 24" },
  { "tam", OP16(0x010bLL), MASK_E, INSTR_E, 3, 2, 0, "test addressing mode" },
  { "pfpo", OP16(0x010aLL), MASK_E, INSTR_E, 2, 5, 0, "perform floating point operation" },
  { "sckpf", OP16(0x0107LL), MASK_E, INSTR_E, 3, 0, 0, "set clock programmable field" },
  { "ptff", OP16(0x0104LL), MASK_E, INSTR_E, 2, 4, 0, "perform timing facility function" },
  { "upt", OP16(0x0102LL), MASK_E, INSTR_E, 3, 0, 0, "update tree" },
  { "pr", OP16(0x0101LL), MASK_E, INSTR_E, 3, 0, 0, "program return" }
};

const int s390_num_opcodes =
  sizeof (s390_opcodes) / sizeof (s390_opcodes[0]);
